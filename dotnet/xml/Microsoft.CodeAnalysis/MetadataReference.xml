<Type Name="MetadataReference" FullName="Microsoft.CodeAnalysis.MetadataReference">
  <TypeSignature Language="C#" Value="public abstract class MetadataReference" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MetadataReference extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.MetadataReference" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MetadataReference" />
  <TypeSignature Language="F#" Value="type MetadataReference = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class MetadataReference abstract" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
    <AssemblyVersion>2.9.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            Represents metadata image reference.
            </summary>
    <remarks>
            Represents a logical location of the image, not the content of the image. 
            The content might change in time. A snapshot is taken when the compiler queries the reference for its metadata.
            </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MetadataReference (Microsoft.CodeAnalysis.MetadataReferenceProperties properties);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype Microsoft.CodeAnalysis.MetadataReferenceProperties properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.MetadataReference.#ctor(Microsoft.CodeAnalysis.MetadataReferenceProperties)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (properties As MetadataReferenceProperties)" />
      <MemberSignature Language="F#" Value="new Microsoft.CodeAnalysis.MetadataReference : Microsoft.CodeAnalysis.MetadataReferenceProperties -&gt; Microsoft.CodeAnalysis.MetadataReference" Usage="new Microsoft.CodeAnalysis.MetadataReference properties" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MetadataReference(Microsoft::CodeAnalysis::MetadataReferenceProperties properties);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="properties" Type="Microsoft.CodeAnalysis.MetadataReferenceProperties" />
      </Parameters>
      <Docs>
        <param name="properties">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFromAssembly">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.MetadataReference CreateFromAssembly (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.MetadataReference CreateFromAssembly(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.MetadataReference.CreateFromAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="F#" Value="static member CreateFromAssembly : System.Reflection.Assembly -&gt; Microsoft.CodeAnalysis.MetadataReference" Usage="Microsoft.CodeAnalysis.MetadataReference.CreateFromAssembly assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::CodeAnalysis::MetadataReference ^ CreateFromAssembly(System::Reflection::Assembly ^ assembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use CreateFromFile(assembly.Location) instead", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.MetadataReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">Path to the module file.</param>
        <summary>
            Creates a reference to a loaded assembly.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            Performance considerations:
            <para>
            It is recommended to use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)" /> API when creating multiple references to the same assembly.
            Reusing <see cref="T:Microsoft.CodeAnalysis.AssemblyMetadata" /> object allows for sharing data across these references.
            </para></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assembly" /> is null.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assembly" /> is dynamic, doesn't have a location, or the platform doesn't support reading from the location.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromAssembly">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.MetadataReference CreateFromAssembly (System.Reflection.Assembly assembly, Microsoft.CodeAnalysis.MetadataReferenceProperties properties, Microsoft.CodeAnalysis.DocumentationProvider documentation = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.MetadataReference CreateFromAssembly(class System.Reflection.Assembly assembly, valuetype Microsoft.CodeAnalysis.MetadataReferenceProperties properties, class Microsoft.CodeAnalysis.DocumentationProvider documentation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.MetadataReference.CreateFromAssembly(System.Reflection.Assembly,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)" />
      <MemberSignature Language="F#" Value="static member CreateFromAssembly : System.Reflection.Assembly * Microsoft.CodeAnalysis.MetadataReferenceProperties * Microsoft.CodeAnalysis.DocumentationProvider -&gt; Microsoft.CodeAnalysis.MetadataReference" Usage="Microsoft.CodeAnalysis.MetadataReference.CreateFromAssembly (assembly, properties, documentation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use CreateFromFile(assembly.Location) instead", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.MetadataReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
        <Parameter Name="properties" Type="Microsoft.CodeAnalysis.MetadataReferenceProperties" />
        <Parameter Name="documentation" Type="Microsoft.CodeAnalysis.DocumentationProvider" />
      </Parameters>
      <Docs>
        <param name="assembly">Path to the module file.</param>
        <param name="properties">Reference properties (extern aliases, type embedding).</param>
        <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
        <summary>
            Creates a reference to a loaded assembly.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            Performance considerations:
            <para>
            It is recommended to use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)" /> API when creating multiple references to the same assembly.
            Reusing <see cref="T:Microsoft.CodeAnalysis.AssemblyMetadata" /> object allows for sharing data across these references.
            </para></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assembly" /> is null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="properties" />.<see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Kind" /> is not <see cref="F:Microsoft.CodeAnalysis.MetadataImageKind.Assembly" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assembly" /> is dynamic, doesn't have a location, or the platform doesn't support reading from the location.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.PortableExecutableReference CreateFromFile (string path, Microsoft.CodeAnalysis.MetadataReferenceProperties properties = null, Microsoft.CodeAnalysis.DocumentationProvider documentation = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.PortableExecutableReference CreateFromFile(string path, valuetype Microsoft.CodeAnalysis.MetadataReferenceProperties properties, class Microsoft.CodeAnalysis.DocumentationProvider documentation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, Optional properties As MetadataReferenceProperties = null, Optional documentation As DocumentationProvider = null) As PortableExecutableReference" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * Microsoft.CodeAnalysis.MetadataReferenceProperties * Microsoft.CodeAnalysis.DocumentationProvider -&gt; Microsoft.CodeAnalysis.PortableExecutableReference" Usage="Microsoft.CodeAnalysis.MetadataReference.CreateFromFile (path, properties, documentation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.PortableExecutableReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="properties" Type="Microsoft.CodeAnalysis.MetadataReferenceProperties" />
        <Parameter Name="documentation" Type="Microsoft.CodeAnalysis.DocumentationProvider" />
      </Parameters>
      <Docs>
        <param name="path">Path to the assembly file.</param>
        <param name="properties">Reference properties (extern aliases, type embedding, <see cref="T:Microsoft.CodeAnalysis.MetadataImageKind" />).</param>
        <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
        <summary>
            Creates a reference to an assembly or standalone module stored in a file.
            Reads the content of the file into memory.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            Performance considerations:
            <para>
            It is recommended to use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)" /> or <see cref="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromFile(System.String)" /> 
            API when creating multiple references to the same file.
            Reusing <see cref="T:Microsoft.CodeAnalysis.Metadata" /> object allows for sharing data across these references.
            </para><para>
            The method eagerly reads the entire content of the file into native heap. The native memory block is released 
            when the resulting reference becomes unreachable and GC collects it. To decrease memory footprint of the reference and/or manage
            the lifetime deterministically use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)" /> 
            to create an <see cref="T:System.IDisposable" /> metadata object and 
            <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.String,System.String)" /> 
            to get a reference to it.
            </para></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is invalid.</exception>
        <exception cref="T:System.IO.IOException">An error occurred while reading the file.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromImage">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.PortableExecutableReference CreateFromImage (System.Collections.Generic.IEnumerable&lt;byte&gt; peImage, Microsoft.CodeAnalysis.MetadataReferenceProperties properties = null, Microsoft.CodeAnalysis.DocumentationProvider documentation = null, string filePath = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.PortableExecutableReference CreateFromImage(class System.Collections.Generic.IEnumerable`1&lt;unsigned int8&gt; peImage, valuetype Microsoft.CodeAnalysis.MetadataReferenceProperties properties, class Microsoft.CodeAnalysis.DocumentationProvider documentation, string filePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.MetadataReference.CreateFromImage(System.Collections.Generic.IEnumerable{System.Byte},Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromImage (peImage As IEnumerable(Of Byte), Optional properties As MetadataReferenceProperties = null, Optional documentation As DocumentationProvider = null, Optional filePath As String = null) As PortableExecutableReference" />
      <MemberSignature Language="F#" Value="static member CreateFromImage : seq&lt;byte&gt; * Microsoft.CodeAnalysis.MetadataReferenceProperties * Microsoft.CodeAnalysis.DocumentationProvider * string -&gt; Microsoft.CodeAnalysis.PortableExecutableReference" Usage="Microsoft.CodeAnalysis.MetadataReference.CreateFromImage (peImage, properties, documentation, filePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.PortableExecutableReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peImage" Type="System.Collections.Generic.IEnumerable&lt;System.Byte&gt;" />
        <Parameter Name="properties" Type="Microsoft.CodeAnalysis.MetadataReferenceProperties" />
        <Parameter Name="documentation" Type="Microsoft.CodeAnalysis.DocumentationProvider" />
        <Parameter Name="filePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="peImage">Assembly image.</param>
        <param name="properties">Reference properties (extern aliases, type embedding, <see cref="T:Microsoft.CodeAnalysis.MetadataImageKind" />).</param>
        <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
        <param name="filePath">Optional path that describes the location of the metadata. The file doesn't need to exist on disk. The path is opaque to the compiler.</param>
        <summary>
            Creates a reference to a single-module assembly or a standalone module stored in memory.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            Performance considerations: 
            <para>
            It is recommended to use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(System.Collections.Generic.IEnumerable{System.Byte})" /> or <see cref="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(System.Collections.Generic.IEnumerable{System.Byte})" /> 
            API when creating multiple references to the same metadata.
            Reusing <see cref="T:Microsoft.CodeAnalysis.Metadata" /> object to create multiple references allows for sharing data across these references.
            </para><para>
            The method makes a copy of the data and pins it. To avoid making a copy use an overload that takes an <see cref="T:System.Collections.Immutable.ImmutableArray`1" />.
            The pinned memory is released when the resulting reference becomes unreachable and GC collects it. To control the lifetime of the pinned memory 
            deterministically use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)" /> 
            to create an <see cref="T:System.IDisposable" /> metadata object and 
            <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.String,System.String)" /> to get a reference to it.
            to get a reference to it.
            </para></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="peImage" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromImage">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.PortableExecutableReference CreateFromImage (System.Collections.Immutable.ImmutableArray&lt;byte&gt; peImage, Microsoft.CodeAnalysis.MetadataReferenceProperties properties = null, Microsoft.CodeAnalysis.DocumentationProvider documentation = null, string filePath = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.PortableExecutableReference CreateFromImage(valuetype System.Collections.Immutable.ImmutableArray`1&lt;unsigned int8&gt; peImage, valuetype Microsoft.CodeAnalysis.MetadataReferenceProperties properties, class Microsoft.CodeAnalysis.DocumentationProvider documentation, string filePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.MetadataReference.CreateFromImage(System.Collections.Immutable.ImmutableArray{System.Byte},Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromImage (peImage As ImmutableArray(Of Byte), Optional properties As MetadataReferenceProperties = null, Optional documentation As DocumentationProvider = null, Optional filePath As String = null) As PortableExecutableReference" />
      <MemberSignature Language="F#" Value="static member CreateFromImage : System.Collections.Immutable.ImmutableArray&lt;byte&gt; * Microsoft.CodeAnalysis.MetadataReferenceProperties * Microsoft.CodeAnalysis.DocumentationProvider * string -&gt; Microsoft.CodeAnalysis.PortableExecutableReference" Usage="Microsoft.CodeAnalysis.MetadataReference.CreateFromImage (peImage, properties, documentation, filePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.PortableExecutableReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peImage" Type="System.Collections.Immutable.ImmutableArray&lt;System.Byte&gt;" />
        <Parameter Name="properties" Type="Microsoft.CodeAnalysis.MetadataReferenceProperties" />
        <Parameter Name="documentation" Type="Microsoft.CodeAnalysis.DocumentationProvider" />
        <Parameter Name="filePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="peImage">Assembly image.</param>
        <param name="properties">Reference properties (extern aliases, type embedding, <see cref="T:Microsoft.CodeAnalysis.MetadataImageKind" />).</param>
        <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
        <param name="filePath">Optional path that describes the location of the metadata. The file doesn't need to exist on disk. The path is opaque to the compiler.</param>
        <summary>
            Creates a reference to a single-module assembly or a standalone module stored in memory.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            Performance considerations: 
            <para>
            It is recommended to use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(System.Collections.Immutable.ImmutableArray{System.Byte})" /> or <see cref="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(System.Collections.Immutable.ImmutableArray{System.Byte})" /> 
            API when creating multiple references to the same metadata.
            Reusing <see cref="T:Microsoft.CodeAnalysis.Metadata" /> object to create multiple references allows for sharing data across these references.
            </para><para>
            The method pins <paramref name="peImage" /> in managed heap. The pinned memory is released 
            when the resulting reference becomes unreachable and GC collects it. To control the lifetime of the pinned memory 
            deterministically use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(System.Collections.Immutable.ImmutableArray{System.Byte})" /> 
            to create an <see cref="T:System.IDisposable" /> metadata object and 
            <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.String,System.String)" /> to get a reference to it.
            </para><para>
            The method creates a reference to a single-module assembly. To create a reference to a multi-module assembly or a stand-alone module use 
            <see cref="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(System.Collections.Immutable.ImmutableArray{System.Byte})" /> and <see cref="M:Microsoft.CodeAnalysis.ModuleMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.String,System.String)" />.
            </para></remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="peImage" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromStream">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.PortableExecutableReference CreateFromStream (System.IO.Stream peStream, Microsoft.CodeAnalysis.MetadataReferenceProperties properties = null, Microsoft.CodeAnalysis.DocumentationProvider documentation = null, string filePath = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.PortableExecutableReference CreateFromStream(class System.IO.Stream peStream, valuetype Microsoft.CodeAnalysis.MetadataReferenceProperties properties, class Microsoft.CodeAnalysis.DocumentationProvider documentation, string filePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.MetadataReference.CreateFromStream(System.IO.Stream,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromStream (peStream As Stream, Optional properties As MetadataReferenceProperties = null, Optional documentation As DocumentationProvider = null, Optional filePath As String = null) As PortableExecutableReference" />
      <MemberSignature Language="F#" Value="static member CreateFromStream : System.IO.Stream * Microsoft.CodeAnalysis.MetadataReferenceProperties * Microsoft.CodeAnalysis.DocumentationProvider * string -&gt; Microsoft.CodeAnalysis.PortableExecutableReference" Usage="Microsoft.CodeAnalysis.MetadataReference.CreateFromStream (peStream, properties, documentation, filePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.PortableExecutableReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peStream" Type="System.IO.Stream" />
        <Parameter Name="properties" Type="Microsoft.CodeAnalysis.MetadataReferenceProperties" />
        <Parameter Name="documentation" Type="Microsoft.CodeAnalysis.DocumentationProvider" />
        <Parameter Name="filePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="peStream">Assembly image.</param>
        <param name="properties">Reference properties (extern aliases, type embedding, <see cref="T:Microsoft.CodeAnalysis.MetadataImageKind" />).</param>
        <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
        <param name="filePath">Optional path that describes the location of the metadata. The file doesn't need to exist on disk. The path is opaque to the compiler.</param>
        <summary>
            Creates a reference to a single-module assembly or a stand-alone module from data in specified stream. 
            Reads the content of the stream into memory and closes the stream upon return.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            Performance considerations: 
            <para>
            It is recommended to use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)" /> or <see cref="M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromStream(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)" /> 
            API when creating multiple references to the same metadata.
            Reusing <see cref="T:Microsoft.CodeAnalysis.Metadata" /> object to create multiple references allows for sharing data across these references.
            </para><para>
            The method eagerly reads the entire content of <paramref name="peStream" /> into native heap. The native memory block is released 
            when the resulting reference becomes unreachable and GC collects it. To decrease memory footprint of the reference and/or manage
            the lifetime deterministically use <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)" /> 
            to create an <see cref="T:System.IDisposable" /> metadata object and 
            <see cref="M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.String,System.String)" />
            to get a reference to it.
            </para></remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="peStream" /> doesn't support read and seek operations.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="peStream" /> is null.</exception>
        <exception cref="T:System.IO.IOException">An error occurred while reading the stream.</exception>
      </Docs>
    </Member>
    <Member MemberName="Display">
      <MemberSignature Language="C#" Value="public virtual string Display { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Display" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.MetadataReference.Display" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Display As String" />
      <MemberSignature Language="F#" Value="member this.Display : string" Usage="Microsoft.CodeAnalysis.MetadataReference.Display" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Display { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Path or name used in error messages to identity the reference.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.MetadataReferenceProperties Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.MetadataReferenceProperties Properties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.MetadataReference.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As MetadataReferenceProperties" />
      <MemberSignature Language="F#" Value="member this.Properties : Microsoft.CodeAnalysis.MetadataReferenceProperties" Usage="Microsoft.CodeAnalysis.MetadataReference.Properties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::MetadataReferenceProperties Properties { Microsoft::CodeAnalysis::MetadataReferenceProperties get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.MetadataReferenceProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithAliases">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.MetadataReference WithAliases (System.Collections.Generic.IEnumerable&lt;string&gt; aliases);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.MetadataReference WithAliases(class System.Collections.Generic.IEnumerable`1&lt;string&gt; aliases) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.MetadataReference.WithAliases(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function WithAliases (aliases As IEnumerable(Of String)) As MetadataReference" />
      <MemberSignature Language="F#" Value="member this.WithAliases : seq&lt;string&gt; -&gt; Microsoft.CodeAnalysis.MetadataReference" Usage="metadataReference.WithAliases aliases" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::MetadataReference ^ WithAliases(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ aliases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.MetadataReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aliases" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="aliases">The new aliases for the reference.</param>
        <summary>
            Returns an instance of the reference with specified aliases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Alias is invalid for the metadata kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="WithAliases">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.MetadataReference WithAliases (System.Collections.Immutable.ImmutableArray&lt;string&gt; aliases);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.MetadataReference WithAliases(valuetype System.Collections.Immutable.ImmutableArray`1&lt;string&gt; aliases) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.MetadataReference.WithAliases(System.Collections.Immutable.ImmutableArray{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function WithAliases (aliases As ImmutableArray(Of String)) As MetadataReference" />
      <MemberSignature Language="F#" Value="member this.WithAliases : System.Collections.Immutable.ImmutableArray&lt;string&gt; -&gt; Microsoft.CodeAnalysis.MetadataReference" Usage="metadataReference.WithAliases aliases" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::MetadataReference ^ WithAliases(System::Collections::Immutable::ImmutableArray&lt;System::String ^&gt; aliases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.MetadataReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aliases" Type="System.Collections.Immutable.ImmutableArray&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="aliases">The new aliases for the reference.</param>
        <summary>
            Returns an instance of the reference with specified aliases.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Alias is invalid for the metadata kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="WithEmbedInteropTypes">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.MetadataReference WithEmbedInteropTypes (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.MetadataReference WithEmbedInteropTypes(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.MetadataReference.WithEmbedInteropTypes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function WithEmbedInteropTypes (value As Boolean) As MetadataReference" />
      <MemberSignature Language="F#" Value="member this.WithEmbedInteropTypes : bool -&gt; Microsoft.CodeAnalysis.MetadataReference" Usage="metadataReference.WithEmbedInteropTypes value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::MetadataReference ^ WithEmbedInteropTypes(bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.MetadataReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">The new value for <see cref="P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes" />.</param>
        <summary>
            Returns an instance of the reference with specified interop types embedding.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Interop types can't be embedded from modules.</exception>
      </Docs>
    </Member>
    <Member MemberName="WithProperties">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.MetadataReference WithProperties (Microsoft.CodeAnalysis.MetadataReferenceProperties properties);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.MetadataReference WithProperties(valuetype Microsoft.CodeAnalysis.MetadataReferenceProperties properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.MetadataReference.WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties)" />
      <MemberSignature Language="VB.NET" Value="Public Function WithProperties (properties As MetadataReferenceProperties) As MetadataReference" />
      <MemberSignature Language="F#" Value="member this.WithProperties : Microsoft.CodeAnalysis.MetadataReferenceProperties -&gt; Microsoft.CodeAnalysis.MetadataReference" Usage="metadataReference.WithProperties properties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::MetadataReference ^ WithProperties(Microsoft::CodeAnalysis::MetadataReferenceProperties properties);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.MetadataReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="Microsoft.CodeAnalysis.MetadataReferenceProperties" />
      </Parameters>
      <Docs>
        <param name="properties">The new properties for the reference.</param>
        <summary>
            Returns an instance of the reference with specified properties, or this instance if properties haven't changed.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Specified values not valid for this reference.</exception>
      </Docs>
    </Member>
  </Members>
</Type>