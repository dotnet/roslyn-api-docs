<Type Name="CSharpExtensions" FullName="Microsoft.CodeAnalysis.CSharp.CSharpExtensions">
  <TypeSignature Language="C#" Value="public static class CSharpExtensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit CSharpExtensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.CSharp.CSharpExtensions" />
  <TypeSignature Language="VB.NET" Value="Public Module CSharpExtensions" />
  <TypeSignature Language="F#" Value="type CSharpExtensions = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class CSharpExtensions abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
    <AssemblyVersion>2.9.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AnalyzeControlFlow">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      <MemberSignature Language="F#" Value="static member AnalyzeControlFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax -&gt; Microsoft.CodeAnalysis.ControlFlowAnalysis" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow (semanticModel, statement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::ControlFlowAnalysis ^ AnalyzeControlFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::StatementSyntax ^ statement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="statement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="statement">To be added.</param>
        <summary>
            Analyze control-flow within a part of a method body.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnalyzeControlFlow">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      <MemberSignature Language="F#" Value="static member AnalyzeControlFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax * Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax -&gt; Microsoft.CodeAnalysis.ControlFlowAnalysis" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow (semanticModel, firstStatement, lastStatement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::ControlFlowAnalysis ^ AnalyzeControlFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::StatementSyntax ^ firstStatement, Microsoft::CodeAnalysis::CSharp::Syntax::StatementSyntax ^ lastStatement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
        <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="firstStatement">To be added.</param>
        <param name="lastStatement">To be added.</param>
        <summary>
            Analyze control-flow within a part of a method body.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnalyzeDataFlow">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)" />
      <MemberSignature Language="F#" Value="static member AnalyzeDataFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax -&gt; Microsoft.CodeAnalysis.DataFlowAnalysis" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow (semanticModel, expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::DataFlowAnalysis ^ AnalyzeDataFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::ExpressionSyntax ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <summary>
            Analyze data-flow within an expression.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnalyzeDataFlow">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      <MemberSignature Language="F#" Value="static member AnalyzeDataFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax -&gt; Microsoft.CodeAnalysis.DataFlowAnalysis" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow (semanticModel, statement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::DataFlowAnalysis ^ AnalyzeDataFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::StatementSyntax ^ statement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="statement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="statement">To be added.</param>
        <summary>
            Analyze data-flow within a part of a method body.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnalyzeDataFlow">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      <MemberSignature Language="F#" Value="static member AnalyzeDataFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax * Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax -&gt; Microsoft.CodeAnalysis.DataFlowAnalysis" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow (semanticModel, firstStatement, lastStatement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::DataFlowAnalysis ^ AnalyzeDataFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::StatementSyntax ^ firstStatement, Microsoft::CodeAnalysis::CSharp::Syntax::StatementSyntax ^ lastStatement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
        <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="firstStatement">To be added.</param>
        <param name="lastStatement">To be added.</param>
        <summary>
            Analyze data-flow within a part of a method body.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassifyConversion">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.Compilation compilation, class Microsoft.CodeAnalysis.ITypeSymbol source, class Microsoft.CodeAnalysis.ITypeSymbol destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
      <MemberSignature Language="F#" Value="static member ClassifyConversion : Microsoft.CodeAnalysis.Compilation * Microsoft.CodeAnalysis.ITypeSymbol * Microsoft.CodeAnalysis.ITypeSymbol -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion (compilation, source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::Conversion ClassifyConversion(Microsoft::CodeAnalysis::Compilation ^ compilation, Microsoft::CodeAnalysis::ITypeSymbol ^ source, Microsoft::CodeAnalysis::ITypeSymbol ^ destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
        <Parameter Name="source" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
      </Parameters>
      <Docs>
        <param name="compilation">To be added.</param>
        <param name="source">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassifyConversion">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, class Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)" />
      <MemberSignature Language="F#" Value="static member ClassifyConversion : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.ITypeSymbol * bool -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion (semanticModel, expression, destination, isExplicitInSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        <Parameter Name="isExplicitInSource" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="isExplicitInSource">To be added.</param>
        <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassifyConversion">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, class Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)" />
      <MemberSignature Language="F#" Value="static member ClassifyConversion : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.ITypeSymbol * bool -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion (semanticModel, position, expression, destination, isExplicitInSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        <Parameter Name="isExplicitInSource" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="isExplicitInSource">To be added.</param>
        <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAliasInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetAliasInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo (semanticModel, nameSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="nameSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            If <paramref name="nameSyntax" /> resolves to an alias name, return the AliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAwaitExpressionInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo GetAwaitExpressionInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax awaitExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo GetAwaitExpressionInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax awaitExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)" />
      <MemberSignature Language="F#" Value="static member GetAwaitExpressionInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax -&gt; Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo (semanticModel, awaitExpression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::AwaitExpressionInfo GetAwaitExpressionInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::AwaitExpressionSyntax ^ awaitExpression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="awaitExpression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="awaitExpression">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCollectionInitializerSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetCollectionInitializerSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetCollectionInitializerSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetCollectionInitializerSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo (semanticModel, expression, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax
            within <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.Initializer" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompilationUnitRoot">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax GetCompilationUnitRoot (this Microsoft.CodeAnalysis.SyntaxTree tree, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax GetCompilationUnitRoot(class Microsoft.CodeAnalysis.SyntaxTree tree, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetCompilationUnitRoot : Microsoft.CodeAnalysis.SyntaxTree * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot (tree, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tree" Type="Microsoft.CodeAnalysis.SyntaxTree" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tree">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstantValue">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.Optional&lt;object&gt; GetConstantValue (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.Optional`1&lt;object&gt; GetConstantValue(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetConstantValue : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.Optional&lt;obj&gt;" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue (semanticModel, expression, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Optional&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConversion">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion GetConversion (this Microsoft.CodeAnalysis.Operations.IConversionOperation conversionExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion GetConversion(class Microsoft.CodeAnalysis.Operations.IConversionOperation conversionExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.Operations.IConversionOperation)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetConversion (conversionExpression As IConversionOperation) As Conversion" />
      <MemberSignature Language="F#" Value="static member GetConversion : Microsoft.CodeAnalysis.Operations.IConversionOperation -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion conversionExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::Conversion GetConversion(Microsoft::CodeAnalysis::Operations::IConversionOperation ^ conversionExpression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="conversionExpression" Type="Microsoft.CodeAnalysis.Operations.IConversionOperation" RefType="this" />
      </Parameters>
      <Docs>
        <param name="conversionExpression">The conversion expression to get original info from.</param>
        <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion" /> information from this <see cref="T:Microsoft.CodeAnalysis.Operations.IConversionOperation" />. This
            <see cref="T:Microsoft.CodeAnalysis.Operations.IConversionOperation" /> must have been created from CSharp code.
            </summary>
        <returns>The underlying <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">If the <see cref="T:Microsoft.CodeAnalysis.Operations.IConversionOperation" /> was not created from CSharp code.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConversion">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion GetConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode expression, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion GetConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetConversion : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion (semanticModel, expression, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IMethodSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node that declares a property or member accessor, get the corresponding symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declaratorSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declaratorSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IPropertySymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declaratorSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declaratorSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declaratorSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declaratorSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node of a tuple argument, get the tuple element symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IMethodSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a base method declaration syntax, get the corresponding method symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a type declaration, get the corresponding type symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax catchDeclaration, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax catchDeclaration, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ILocalSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, catchDeclaration, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ILocalSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="catchDeclaration" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="catchDeclaration">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a catch declaration, get the symbol for the exception variable
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a delegate declaration, get the corresponding type symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IFieldSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IFieldSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IFieldSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IFieldSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a enum member declaration, get the corresponding field symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IEventSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IEventSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node that declares a (custom) event, get the corresponding event symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given an extern alias declaration get the corresponding symbol for the alias that was introduced.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ILocalSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, forEachStatement, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ILocalSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="forEachStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="forEachStatement">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a foreach statement, get the symbol for the iteration variable
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IPropertySymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node that declares an indexer, get the corresponding declared symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IRangeVariableSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, node, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Get the query range variable declared in a join into clause.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ILabelSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ILabelSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a labeled statement syntax, get the corresponding label symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a member declaration syntax, get the corresponding symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamespaceSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for
            the declaration assembly.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IParameterSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IParameterSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IParameterSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IParameterSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a parameter declaration syntax node, get the corresponding symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IPropertySymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node that declares a property, get the corresponding declared symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax queryClause, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax queryClause, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IRangeVariableSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, queryClause, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="queryClause" Type="Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="queryClause">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IRangeVariableSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, node, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Get the query range variable declared in a query continuation clause.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax designationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax designationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, designationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="designationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="designationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ILabelSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ILabelSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a switch label syntax, get the corresponding label symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a tuple element syntax, get the corresponding symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declaratorSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declaratorSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node of tuple expression, get the tuple type symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ITypeParameterSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax typeParameter, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ITypeParameterSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax typeParameter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ITypeParameterSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, typeParameter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ITypeParameterSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="typeParameter" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="typeParameter">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a type parameter declaration (field or method), get the corresponding symbol
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a using declaration get the corresponding symbol for the using alias that was introduced.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeconstructionInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.DeconstructionInfo GetDeconstructionInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax assignment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.DeconstructionInfo GetDeconstructionInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax assignment) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeconstructionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax)" />
      <MemberSignature Language="F#" Value="static member GetDeconstructionInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax -&gt; Microsoft.CodeAnalysis.CSharp.DeconstructionInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeconstructionInfo (semanticModel, assignment)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::DeconstructionInfo GetDeconstructionInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::AssignmentExpressionSyntax ^ assignment);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.DeconstructionInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="assignment" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="assignment">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeconstructionInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.DeconstructionInfo GetDeconstructionInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax foreach);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.DeconstructionInfo GetDeconstructionInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax foreach) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeconstructionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax)" />
      <MemberSignature Language="F#" Value="static member GetDeconstructionInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax -&gt; Microsoft.CodeAnalysis.CSharp.DeconstructionInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeconstructionInfo (semanticModel, foreach)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::DeconstructionInfo GetDeconstructionInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::ForEachVariableStatementSyntax ^ foreach);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.DeconstructionInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="foreach" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="foreach">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFirstDirective">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetFirstDirective (this Microsoft.CodeAnalysis.SyntaxNode node, Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,bool&gt; predicate = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetFirstDirective(class Microsoft.CodeAnalysis.SyntaxNode node, class System.Func`2&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetFirstDirective (node As SyntaxNode, Optional predicate As Func(Of DirectiveTriviaSyntax, Boolean) = null) As DirectiveTriviaSyntax" />
      <MemberSignature Language="F#" Value="static member GetFirstDirective : Microsoft.CodeAnalysis.SyntaxNode * Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool&gt; -&gt; Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective (node, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <param name="predicate">To be added.</param>
        <summary>
            Gets the first directive of the tree rooted by this node.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetForEachStatementInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEachStatement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEachStatement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax)" />
      <MemberSignature Language="F#" Value="static member GetForEachStatementInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax -&gt; Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo (semanticModel, forEachStatement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::ForEachStatementInfo GetForEachStatementInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::CommonForEachStatementSyntax ^ forEachStatement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="forEachStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="forEachStatement">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetForEachStatementInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)" />
      <MemberSignature Language="F#" Value="static member GetForEachStatementInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax -&gt; Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo (semanticModel, forEachStatement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::ForEachStatementInfo GetForEachStatementInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::ForEachStatementSyntax ^ forEachStatement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="forEachStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="forEachStatement">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInConversion">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion GetInConversion (this Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation compoundAssignment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion GetInConversion(class Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation compoundAssignment) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetInConversion(Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetInConversion (compoundAssignment As ICompoundAssignmentOperation) As Conversion" />
      <MemberSignature Language="F#" Value="static member GetInConversion : Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetInConversion compoundAssignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::Conversion GetInConversion(Microsoft::CodeAnalysis::Operations::ICompoundAssignmentOperation ^ compoundAssignment);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compoundAssignment" Type="Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" RefType="this" />
      </Parameters>
      <Docs>
        <param name="compoundAssignment">To be added.</param>
        <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion" /> information from this <see cref="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" />. This
            conversion is applied before the operator is applied to the result of this conversion and <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Value" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            This compound assignment must have been created from C# code.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIndexerGroup">
      <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IPropertySymbol&gt; GetIndexerGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.IPropertySymbol&gt; GetIndexerGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetIndexerGroup : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IPropertySymbol&gt;" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup (semanticModel, expression, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IPropertySymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastDirective">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetLastDirective (this Microsoft.CodeAnalysis.SyntaxNode node, Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,bool&gt; predicate = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetLastDirective(class Microsoft.CodeAnalysis.SyntaxNode node, class System.Func`2&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetLastDirective (node As SyntaxNode, Optional predicate As Func(Of DirectiveTriviaSyntax, Boolean) = null) As DirectiveTriviaSyntax" />
      <MemberSignature Language="F#" Value="static member GetLastDirective : Microsoft.CodeAnalysis.SyntaxNode * Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool&gt; -&gt; Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective (node, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <param name="predicate">To be added.</param>
        <summary>
            Gets the last directive of the tree rooted by this node.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMemberGroup">
      <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetMemberGroup : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup (semanticModel, attribute, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="attribute">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMemberGroup">
      <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetMemberGroup : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup (semanticModel, initializer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="initializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="initializer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMemberGroup">
      <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetMemberGroup : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup (semanticModel, expression, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOutConversion">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion GetOutConversion (this Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation compoundAssignment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion GetOutConversion(class Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation compoundAssignment) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetOutConversion(Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetOutConversion (compoundAssignment As ICompoundAssignmentOperation) As Conversion" />
      <MemberSignature Language="F#" Value="static member GetOutConversion : Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetOutConversion compoundAssignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::Conversion GetOutConversion(Microsoft::CodeAnalysis::Operations::ICompoundAssignmentOperation ^ compoundAssignment);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compoundAssignment" Type="Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" RefType="this" />
      </Parameters>
      <Docs>
        <param name="compoundAssignment">To be added.</param>
        <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion" /> information from this <see cref="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" />. This
            conversion is applied after the operator is applied, before the result is assigned to <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Target" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            This compound assignment must have been created from C# code.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetQueryClauseInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.QueryClauseInfo GetQueryClauseInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.QueryClauseInfo GetQueryClauseInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetQueryClauseInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.CSharp.QueryClauseInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo (semanticModel, node, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.QueryClauseInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the semantic information associated with a query clause.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeAliasInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberSignature Language="F#" Value="static member GetSpeculativeAliasInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo (semanticModel, position, nameSyntax, bindingOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::IAliasSymbol ^ GetSpeculativeAliasInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::IdentifierNameSyntax ^ nameSyntax, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="nameSyntax">To be added.</param>
        <param name="bindingOption">To be added.</param>
        <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeConversion">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion GetSpeculativeConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion GetSpeculativeConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberSignature Language="F#" Value="static member GetSpeculativeConversion : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion (semanticModel, position, expression, bindingOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::Conversion GetSpeculativeConversion(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::ExpressionSyntax ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="bindingOption">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)" />
      <MemberSignature Language="F#" Value="static member GetSpeculativeSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo (semanticModel, position, attribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SymbolInfo GetSpeculativeSymbolInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::AttributeSyntax ^ attribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="attribute">To be added.</param>
        <summary>
            Bind the attribute in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about an attribute
            that did not actually appear in the source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)" />
      <MemberSignature Language="F#" Value="static member GetSpeculativeSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo (semanticModel, position, constructorInitializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SymbolInfo GetSpeculativeSymbolInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::ConstructorInitializerSyntax ^ constructorInitializer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="constructorInitializer">To be added.</param>
        <summary>
             Bind the constructor initializer in the context of the specified location and get semantic information
             such as type, symbols and diagnostics. This method is used to get semantic information about a constructor
             initializer that did not actually appear in the source code.
            
             NOTE: This will only work in locations where there is already a constructor initializer.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberSignature Language="F#" Value="static member GetSpeculativeSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo (semanticModel, position, expression, bindingOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SymbolInfo GetSpeculativeSymbolInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::CrefSyntax ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="bindingOption">To be added.</param>
        <summary>
            Binds the CrefSyntax expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberSignature Language="F#" Value="static member GetSpeculativeSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo (semanticModel, position, expression, bindingOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SymbolInfo GetSpeculativeSymbolInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::ExpressionSyntax ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="bindingOption">To be added.</param>
        <summary>
            Binds the expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeTypeInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberSignature Language="F#" Value="static member GetSpeculativeTypeInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo (semanticModel, position, expression, bindingOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::TypeInfo GetSpeculativeTypeInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::ExpressionSyntax ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="bindingOption">To be added.</param>
        <summary>
            Binds the expression in the context of the specified location and gets type information.
            This method is used to get type information about an expression that did not actually
            appear in the source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo (semanticModel, attributeSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="attributeSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="attributeSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Returns what symbol(s), if any, the given attribute syntax bound to in the program.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo (semanticModel, constructorInitializer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="constructorInitializer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo (semanticModel, crefSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="crefSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="crefSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the semantic information associated with a documentation comment cref.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo (semanticModel, expression, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
             Returns what symbol(s), if any, the given expression syntax bound to in the program.
            
             An AliasSymbol will never be returned by this method. What the alias refers to will be
             returned instead. To get information about aliases, call GetAliasInfo.
            
             If binding the type name C in the expression "new C(...)" the actual constructor bound to
             will be returned (or all constructor if overload resolution failed). This occurs as long as C
             unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple
             types, or C binds to a static class, then type(s) are returned.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo (semanticModel, node, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the semantic information for an ordering clause in an orderby query clause.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo (semanticModel, node, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the semantic information associated with a select or group clause.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetTypeInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo (semanticModel, attributeSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="attributeSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="attributeSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets type information about an attribute.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetTypeInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo (semanticModel, constructorInitializer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="constructorInitializer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets type information about a constructor initializer.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetTypeInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo (semanticModel, expression, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets type information about an expression.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member GetTypeInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo (semanticModel, node, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTokenList Insert (this Microsoft.CodeAnalysis.SyntaxTokenList list, int index, params Microsoft.CodeAnalysis.SyntaxToken[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxTokenList Insert(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, int32 index, valuetype Microsoft.CodeAnalysis.SyntaxToken[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Insert (list As SyntaxTokenList, index As Integer, ParamArray items As SyntaxToken()) As SyntaxTokenList" />
      <MemberSignature Language="F#" Value="static member Insert : Microsoft.CodeAnalysis.SyntaxTokenList * int * Microsoft.CodeAnalysis.SyntaxToken[] -&gt; Microsoft.CodeAnalysis.SyntaxTokenList" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert (list, index, items)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxTokenList Insert(Microsoft::CodeAnalysis::SyntaxTokenList list, int index, ... cli::array &lt;Microsoft::CodeAnalysis::SyntaxToken&gt; ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTokenList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="items" Type="Microsoft.CodeAnalysis.SyntaxToken[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="list">To be added.</param>
        <param name="index">To be added.</param>
        <param name="items">To be added.</param>
        <summary>
            Insert one or more tokens in the list at the specified index.
            </summary>
        <returns>A new list with the tokens inserted.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextualKeyword">
      <MemberSignature Language="C#" Value="public static bool IsContextualKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsContextualKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsContextualKeyword (token As SyntaxToken) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsContextualKeyword : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword token" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsContextualKeyword(Microsoft::CodeAnalysis::SyntaxToken token);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="token">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyword">
      <MemberSignature Language="C#" Value="public static bool IsKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsKeyword (token As SyntaxToken) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsKeyword : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword token" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsKeyword(Microsoft::CodeAnalysis::SyntaxToken token);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="token">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReservedKeyword">
      <MemberSignature Language="C#" Value="public static bool IsReservedKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsReservedKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsReservedKeyword (token As SyntaxToken) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsReservedKeyword : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword token" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsReservedKeyword(Microsoft::CodeAnalysis::SyntaxToken token);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="token">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVerbatimIdentifier">
      <MemberSignature Language="C#" Value="public static bool IsVerbatimIdentifier (this Microsoft.CodeAnalysis.SyntaxToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsVerbatimIdentifier(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsVerbatimIdentifier (token As SyntaxToken) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsVerbatimIdentifier : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier token" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsVerbatimIdentifier(Microsoft::CodeAnalysis::SyntaxToken token);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="token">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVerbatimStringLiteral">
      <MemberSignature Language="C#" Value="public static bool IsVerbatimStringLiteral (this Microsoft.CodeAnalysis.SyntaxToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsVerbatimStringLiteral(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsVerbatimStringLiteral (token As SyntaxToken) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsVerbatimStringLiteral : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral token" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsVerbatimStringLiteral(Microsoft::CodeAnalysis::SyntaxToken token);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="token">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Kind">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(class Microsoft.CodeAnalysis.SyntaxNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Kind (node As SyntaxNode) As SyntaxKind" />
      <MemberSignature Language="F#" Value="static member Kind : Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.CSharp.SyntaxKind" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind node" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::SyntaxKind Kind(Microsoft::CodeAnalysis::SyntaxNode ^ node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Kind">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Kind (nodeOrToken As SyntaxNodeOrToken) As SyntaxKind" />
      <MemberSignature Language="F#" Value="static member Kind : Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; Microsoft.CodeAnalysis.CSharp.SyntaxKind" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind nodeOrToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::SyntaxKind Kind(Microsoft::CodeAnalysis::SyntaxNodeOrToken nodeOrToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="nodeOrToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Kind">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Kind (token As SyntaxToken) As SyntaxKind" />
      <MemberSignature Language="F#" Value="static member Kind : Microsoft.CodeAnalysis.SyntaxToken -&gt; Microsoft.CodeAnalysis.CSharp.SyntaxKind" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind token" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::SyntaxKind Kind(Microsoft::CodeAnalysis::SyntaxToken token);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="token">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Kind">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxTrivia trivia);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxTrivia trivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Kind (trivia As SyntaxTrivia) As SyntaxKind" />
      <MemberSignature Language="F#" Value="static member Kind : Microsoft.CodeAnalysis.SyntaxTrivia -&gt; Microsoft.CodeAnalysis.CSharp.SyntaxKind" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind trivia" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::SyntaxKind Kind(Microsoft::CodeAnalysis::SyntaxTrivia trivia);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" RefType="this" />
      </Parameters>
      <Docs>
        <param name="trivia">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceTrivia">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia (this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, Microsoft.CodeAnalysis.SyntaxTrivia newTrivia);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(valuetype Microsoft.CodeAnalysis.SyntaxToken token, valuetype Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia newTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceTrivia (token As SyntaxToken, oldTrivia As SyntaxTrivia, newTrivia As SyntaxTrivia) As SyntaxToken" />
      <MemberSignature Language="F#" Value="static member ReplaceTrivia : Microsoft.CodeAnalysis.SyntaxToken * Microsoft.CodeAnalysis.SyntaxTrivia * Microsoft.CodeAnalysis.SyntaxTrivia -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia (token, oldTrivia, newTrivia)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxToken ReplaceTrivia(Microsoft::CodeAnalysis::SyntaxToken token, Microsoft::CodeAnalysis::SyntaxTrivia oldTrivia, Microsoft::CodeAnalysis::SyntaxTrivia newTrivia);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        <Parameter Name="oldTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
        <Parameter Name="newTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
      </Parameters>
      <Docs>
        <param name="token"></param>
        <param name="oldTrivia">The trivia to be replaced.</param>
        <param name="newTrivia">The new trivia to use in the new tree in place of the old
            trivia.</param>
        <summary>
            Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in
            the token's leading or trailing trivia.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceTrivia">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia (this Microsoft.CodeAnalysis.SyntaxToken token, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(valuetype Microsoft.CodeAnalysis.SyntaxToken token, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, class System.Func`3&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceTrivia (token As SyntaxToken, trivia As IEnumerable(Of SyntaxTrivia), computeReplacementTrivia As Func(Of SyntaxTrivia, SyntaxTrivia, SyntaxTrivia)) As SyntaxToken" />
      <MemberSignature Language="F#" Value="static member ReplaceTrivia : Microsoft.CodeAnalysis.SyntaxToken * seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; * Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia (token, trivia, computeReplacementTrivia)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxToken ReplaceTrivia(Microsoft::CodeAnalysis::SyntaxToken token, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ trivia, Func&lt;Microsoft::CodeAnalysis::SyntaxTrivia, Microsoft::CodeAnalysis::SyntaxTrivia, Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ computeReplacementTrivia);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        <Parameter Name="trivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        <Parameter Name="computeReplacementTrivia" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
      </Parameters>
      <Docs>
        <param name="token"></param>
        <param name="trivia">The trivia to be replaced; descendants of the root token.</param>
        <param name="computeReplacementTrivia">A function that computes a replacement trivia for
            the argument trivia. The first argument is the original trivia. The second argument is
            the same trivia rewritten with replaced structure.</param>
        <summary>
            Creates a new token with the specified old trivia replaced with computed new trivia.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, expressionBody, speculativeModel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::ArrowExpressionClauseSyntax ^ expressionBody, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="expressionBody" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="expressionBody">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with an expression body that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an expression body that did not appear in source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, attribute, speculativeModel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::AttributeSyntax ^ attribute, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="attribute">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with an attribute that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an attribute that did not appear in source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, constructorInitializer, speculativeModel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::ConstructorInitializerSyntax ^ constructorInitializer, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="constructorInitializer">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
             Get a SemanticModel object that is associated with a constructor initializer that did not appear in
             this source code. This can be used to get detailed semantic information about sub-parts
             of a constructor initializer that did not appear in source code.
            
             NOTE: This will only work in locations where there is already a constructor initializer.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, crefSyntax, speculativeModel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::CrefSyntax ^ crefSyntax, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="crefSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="crefSyntax">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with a cref syntax node that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a cref syntax that did not appear in source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, initializer, speculativeModel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::EqualsValueClauseSyntax ^ initializer, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="initializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="initializer">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with an initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a field initializer or default parameter value that did not appear in source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, statement, speculativeModel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::StatementSyntax ^ statement, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="statement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="statement">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with a statement that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a statement that did not appear in source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, out Microsoft.CodeAnalysis.SemanticModel speculativeModel, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption = Microsoft.CodeAnalysis.SpeculativeBindingOption.BindAsExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax *  * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, type, speculativeModel, bindingOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="type" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="type">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <param name="bindingOption">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with a type syntax node that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a type syntax that did not appear in source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModelForMethodBody">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModelForMethodBody (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax accessor, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModelForMethodBody(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax accessor, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModelForMethodBody : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody (semanticModel, position, accessor, speculativeModel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModelForMethodBody(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::AccessorDeclarationSyntax ^ accessor, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="accessor" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="accessor">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position" /> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModelForMethodBody">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModelForMethodBody (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax method, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModelForMethodBody(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax method, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModelForMethodBody : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody (semanticModel, position, method, speculativeModel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModelForMethodBody(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::BaseMethodDeclarationSyntax ^ method, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="method" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="method">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position" /> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VarianceKindFromToken">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VarianceKind VarianceKindFromToken (this Microsoft.CodeAnalysis.SyntaxToken node);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.VarianceKind VarianceKindFromToken(valuetype Microsoft.CodeAnalysis.SyntaxToken node) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function VarianceKindFromToken (node As SyntaxToken) As VarianceKind" />
      <MemberSignature Language="F#" Value="static member VarianceKindFromToken : Microsoft.CodeAnalysis.SyntaxToken -&gt; Microsoft.CodeAnalysis.VarianceKind" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken node" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VarianceKind VarianceKindFromToken(Microsoft::CodeAnalysis::SyntaxToken node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.VarianceKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>