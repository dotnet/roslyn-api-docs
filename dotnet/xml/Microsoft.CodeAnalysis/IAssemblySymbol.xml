<Type Name="IAssemblySymbol" FullName="Microsoft.CodeAnalysis.IAssemblySymbol">
  <TypeSignature Language="C#" Value="public interface IAssemblySymbol : IEquatable&lt;Microsoft.CodeAnalysis.ISymbol&gt;, Microsoft.CodeAnalysis.ISymbol" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IAssemblySymbol implements class Microsoft.CodeAnalysis.ISymbol, class System.IEquatable`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt;" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.IAssemblySymbol" />
  <TypeSignature Language="VB.NET" Value="Public Interface IAssemblySymbol&#xA;Implements IEquatable(Of ISymbol), ISymbol" />
  <TypeSignature Language="F#" Value="type IAssemblySymbol = interface&#xA;    interface ISymbol&#xA;    interface IEquatable&lt;ISymbol&gt;" />
  <TypeSignature Language="C++ CLI" Value="public interface class IAssemblySymbol : IEquatable&lt;Microsoft::CodeAnalysis::ISymbol ^&gt;, Microsoft::CodeAnalysis::ISymbol" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
    <AssemblyVersion>2.9.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.CodeAnalysis.ISymbol</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;Microsoft.CodeAnalysis.ISymbol&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
            Represents a .NET assembly, consisting of one or more modules.
            </summary>
    <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
  </Docs>
  <Members>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.AssemblyMetadata GetMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.CodeAnalysis.AssemblyMetadata GetMetadata() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.IAssemblySymbol.GetMetadata" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata () As AssemblyMetadata" />
      <MemberSignature Language="F#" Value="abstract member GetMetadata : unit -&gt; Microsoft.CodeAnalysis.AssemblyMetadata" Usage="iAssemblySymbol.GetMetadata " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::AssemblyMetadata ^ GetMetadata();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.AssemblyMetadata</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            If this symbol represents a metadata assembly returns the underlying <see cref="T:Microsoft.CodeAnalysis.AssemblyMetadata" />.
            
            Otherwise, this returns <see langword="null" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeByMetadataName">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol GetTypeByMetadataName (string fullyQualifiedMetadataName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.IAssemblySymbol.GetTypeByMetadataName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeByMetadataName (fullyQualifiedMetadataName As String) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="abstract member GetTypeByMetadataName : string -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="iAssemblySymbol.GetTypeByMetadataName fullyQualifiedMetadataName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::INamedTypeSymbol ^ GetTypeByMetadataName(System::String ^ fullyQualifiedMetadataName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fullyQualifiedMetadataName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fullyQualifiedMetadataName">Type name.</param>
        <summary>
            Lookup a type within the assembly using the canonical CLR metadata name of the type.
            </summary>
        <returns>Symbol for the type or null if type cannot be found or is ambiguous. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GivesAccessTo">
      <MemberSignature Language="C#" Value="public bool GivesAccessTo (Microsoft.CodeAnalysis.IAssemblySymbol toAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GivesAccessTo(class Microsoft.CodeAnalysis.IAssemblySymbol toAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.IAssemblySymbol.GivesAccessTo(Microsoft.CodeAnalysis.IAssemblySymbol)" />
      <MemberSignature Language="VB.NET" Value="Public Function GivesAccessTo (toAssembly As IAssemblySymbol) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member GivesAccessTo : Microsoft.CodeAnalysis.IAssemblySymbol -&gt; bool" Usage="iAssemblySymbol.GivesAccessTo toAssembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GivesAccessTo(Microsoft::CodeAnalysis::IAssemblySymbol ^ toAssembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toAssembly" Type="Microsoft.CodeAnalysis.IAssemblySymbol" />
      </Parameters>
      <Docs>
        <param name="toAssembly">To be added.</param>
        <summary>
            Gets a value indicating whether this assembly gives 
            <paramref name="toAssembly" /> access to internal symbols</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalNamespace">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamespaceSymbol GlobalNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamespaceSymbol GlobalNamespace" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.IAssemblySymbol.GlobalNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalNamespace As INamespaceSymbol" />
      <MemberSignature Language="F#" Value="member this.GlobalNamespace : Microsoft.CodeAnalysis.INamespaceSymbol" Usage="Microsoft.CodeAnalysis.IAssemblySymbol.GlobalNamespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::INamespaceSymbol ^ GlobalNamespace { Microsoft::CodeAnalysis::INamespaceSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the merged root namespace that contains all namespaces and types defined in the modules
            of this assembly. If there is just one module in this assembly, this property just returns the 
            GlobalNamespace of that module.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Identity">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.AssemblyIdentity Identity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.AssemblyIdentity Identity" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.IAssemblySymbol.Identity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Identity As AssemblyIdentity" />
      <MemberSignature Language="F#" Value="member this.Identity : Microsoft.CodeAnalysis.AssemblyIdentity" Usage="Microsoft.CodeAnalysis.IAssemblySymbol.Identity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::AssemblyIdentity ^ Identity { Microsoft::CodeAnalysis::AssemblyIdentity ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.AssemblyIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the name of this assembly.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInteractive">
      <MemberSignature Language="C#" Value="public bool IsInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInteractive" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.IAssemblySymbol.IsInteractive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInteractive As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsInteractive : bool" Usage="Microsoft.CodeAnalysis.IAssemblySymbol.IsInteractive" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInteractive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            True if the assembly contains interactive code.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MightContainExtensionMethods">
      <MemberSignature Language="C#" Value="public bool MightContainExtensionMethods { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MightContainExtensionMethods" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.IAssemblySymbol.MightContainExtensionMethods" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MightContainExtensionMethods As Boolean" />
      <MemberSignature Language="F#" Value="member this.MightContainExtensionMethods : bool" Usage="Microsoft.CodeAnalysis.IAssemblySymbol.MightContainExtensionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MightContainExtensionMethods { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines if the assembly might contain extension methods.
            If false, the assembly does not contain extension methods.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.IModuleSymbol&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.IModuleSymbol&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.IAssemblySymbol.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As IEnumerable(Of IModuleSymbol)" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;Microsoft.CodeAnalysis.IModuleSymbol&gt;" Usage="Microsoft.CodeAnalysis.IAssemblySymbol.Modules" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::IModuleSymbol ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::IModuleSymbol ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.IModuleSymbol&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the modules in this assembly. (There must be at least one.) The first one is the main module
            that holds the assembly manifest.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NamespaceNames">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;string&gt; NamespaceNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;string&gt; NamespaceNames" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.IAssemblySymbol.NamespaceNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NamespaceNames As ICollection(Of String)" />
      <MemberSignature Language="F#" Value="member this.NamespaceNames : System.Collections.Generic.ICollection&lt;string&gt;" Usage="Microsoft.CodeAnalysis.IAssemblySymbol.NamespaceNames" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ NamespaceNames { System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the set of namespace names from this assembly.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveForwardedType">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol ResolveForwardedType (string fullyQualifiedMetadataName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol ResolveForwardedType(string fullyQualifiedMetadataName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.IAssemblySymbol.ResolveForwardedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveForwardedType (fullyQualifiedMetadataName As String) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="abstract member ResolveForwardedType : string -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="iAssemblySymbol.ResolveForwardedType fullyQualifiedMetadataName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::INamedTypeSymbol ^ ResolveForwardedType(System::String ^ fullyQualifiedMetadataName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fullyQualifiedMetadataName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fullyQualifiedMetadataName">To be added.</param>
        <summary>
            Returns the type symbol for a forwarded type based its canonical CLR metadata name.
            The name should refer to a non-nested type. If type with this name is not forwarded,
            null is returned.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeNames">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;string&gt; TypeNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;string&gt; TypeNames" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.IAssemblySymbol.TypeNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeNames As ICollection(Of String)" />
      <MemberSignature Language="F#" Value="member this.TypeNames : System.Collections.Generic.ICollection&lt;string&gt;" Usage="Microsoft.CodeAnalysis.IAssemblySymbol.TypeNames" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ TypeNames { System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the set of type identifiers from this assembly.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>