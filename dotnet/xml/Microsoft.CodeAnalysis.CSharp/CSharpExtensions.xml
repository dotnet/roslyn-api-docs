<Type Name="CSharpExtensions" FullName="Microsoft.CodeAnalysis.CSharp.CSharpExtensions">
  <TypeSignature Language="C#" Value="public static class CSharpExtensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit CSharpExtensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.CSharp.CSharpExtensions" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
    <AssemblyVersion>2.4.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AnalyzeControlFlow">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="statement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="statement">To be added.</param>
        <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnalyzeControlFlow">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
        <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="firstStatement">To be added.</param>
        <param name="lastStatement">To be added.</param>
        <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnalyzeDataFlow">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <summary>
            Analyze data-flow within an expression. 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnalyzeDataFlow">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="statement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="statement">To be added.</param>
        <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnalyzeDataFlow">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
        <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="firstStatement">To be added.</param>
        <param name="lastStatement">To be added.</param>
        <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassifyConversion">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.Compilation compilation, class Microsoft.CodeAnalysis.ITypeSymbol source, class Microsoft.CodeAnalysis.ITypeSymbol destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
        <Parameter Name="source" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
      </Parameters>
      <Docs>
        <param name="compilation">To be added.</param>
        <param name="source">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassifyConversion">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, class Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        <Parameter Name="isExplicitInSource" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="isExplicitInSource">To be added.</param>
        <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassifyConversion">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, class Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        <Parameter Name="isExplicitInSource" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="isExplicitInSource">To be added.</param>
        <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAliasInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="nameSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            If <paramref name="nameSyntax" /> resolves to an alias name, return the AliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAwaitExpressionInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo GetAwaitExpressionInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax awaitExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo GetAwaitExpressionInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax awaitExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="awaitExpression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="awaitExpression">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCollectionInitializerSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetCollectionInitializerSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetCollectionInitializerSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax 
            within <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.Initializer" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompilationUnitRoot">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax GetCompilationUnitRoot (this Microsoft.CodeAnalysis.SyntaxTree tree, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax GetCompilationUnitRoot(class Microsoft.CodeAnalysis.SyntaxTree tree, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tree" Type="Microsoft.CodeAnalysis.SyntaxTree" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tree">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstantValue">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.Optional&lt;object&gt; GetConstantValue (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.Optional`1&lt;object&gt; GetConstantValue(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Optional&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConversion">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion GetConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode expression, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion GetConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node that declares a property or member accessor, get the corresponding symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declaratorSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declaratorSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declaratorSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node of a tuple argument, get the tuple element symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a base method declaration syntax, get the corresponding method symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a type declaration, get the corresponding type symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax catchDeclaration, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax catchDeclaration, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ILocalSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="catchDeclaration" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="catchDeclaration">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a catch declaration, get the symbol for the exception variable
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a delegate declaration, get the corresponding type symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IFieldSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IFieldSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IFieldSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a enum member declaration, get the corresponding field symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IEventSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node that declares a (custom) event, get the corresponding event symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given an extern alias declaration get the corresponding symbol for the alias that was introduced.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ILocalSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="forEachStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="forEachStatement">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a foreach statement, get the symbol for the iteration variable
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node that declares an indexer, get the corresponding declared symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Get the query range variable declared in a join into clause.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ILabelSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a labeled statement syntax, get the corresponding label symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a member declaration syntax, get the corresponding symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for
            the declaration assembly.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IParameterSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IParameterSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IParameterSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a parameter declaration syntax node, get the corresponding symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node that declares a property, get the corresponding declared symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax queryClause, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax queryClause, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="queryClause" Type="Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="queryClause">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Get the query range variable declared in a query continuation clause.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax designationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax designationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="designationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="designationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ILabelSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a switch label syntax, get the corresponding label symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a tuple element syntax, get the corresponding symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declaratorSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a syntax node of tuple expression, get the tuple type symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ITypeParameterSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax typeParameter, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ITypeParameterSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax typeParameter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ITypeParameterSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="typeParameter" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="typeParameter">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a type parameter declaration (field or method), get the corresponding symbol
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a using declaration get the corresponding symbol for the using alias that was introduced.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbol">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="declarationSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFirstDirective">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetFirstDirective (this Microsoft.CodeAnalysis.SyntaxNode node, Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,bool&gt; predicate = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetFirstDirective(class Microsoft.CodeAnalysis.SyntaxNode node, class System.Func`2&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <param name="predicate">To be added.</param>
        <summary>
            Gets the first directive of the tree rooted by this node.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetForEachStatementInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEachStatement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEachStatement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="forEachStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="forEachStatement">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetForEachStatementInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="forEachStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="forEachStatement">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIndexerGroup">
      <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IPropertySymbol&gt; GetIndexerGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.IPropertySymbol&gt; GetIndexerGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IPropertySymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastDirective">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetLastDirective (this Microsoft.CodeAnalysis.SyntaxNode node, Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,bool&gt; predicate = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetLastDirective(class Microsoft.CodeAnalysis.SyntaxNode node, class System.Func`2&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <param name="predicate">To be added.</param>
        <summary>
            Gets the last directive of the tree rooted by this node.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMemberGroup">
      <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="attribute">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMemberGroup">
      <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="initializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="initializer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMemberGroup">
      <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetQueryClauseInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.QueryClauseInfo GetQueryClauseInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.QueryClauseInfo GetQueryClauseInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.QueryClauseInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the semantic information associated with a query clause.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeAliasInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="nameSyntax">To be added.</param>
        <param name="bindingOption">To be added.</param>
        <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeConversion">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion GetSpeculativeConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion GetSpeculativeConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="bindingOption">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="attribute">To be added.</param>
        <summary>
            Bind the attribute in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about an attribute
            that did not actually appear in the source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="constructorInitializer">To be added.</param>
        <summary>
            Bind the constructor initializer in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about a constructor
            initializer that did not actually appear in the source code.
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="bindingOption">To be added.</param>
        <summary>
            Binds the CrefSyntax expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="bindingOption">To be added.</param>
        <summary>
            Binds the expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeTypeInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="bindingOption">To be added.</param>
        <summary>
            Binds the expression in the context of the specified location and gets type information.
            This method is used to get type information about an expression that did not actually
            appear in the source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="attributeSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="attributeSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Returns what symbol(s), if any, the given attribute syntax bound to in the program.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="constructorInitializer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="crefSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="crefSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the semantic information associated with a documentation comment cref.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Returns what symbol(s), if any, the given expression syntax bound to in the program.
            
            An AliasSymbol will never be returned by this method. What the alias refers to will be
            returned instead. To get information about aliases, call GetAliasInfo.
            
            If binding the type name C in the expression "new C(...)" the actual constructor bound to
            will be returned (or all constructor if overload resolution failed). This occurs as long as C
            unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple
            types, or C binds to a static class, then type(s) are returned.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the semantic information for an ordering clause in an orderby query clause.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the semantic information associated with a select or group clause.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="attributeSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="attributeSyntax">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets type information about an attribute.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="constructorInitializer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets type information about a constructor initializer.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="expression">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets type information about an expression.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfo">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTokenList Insert (this Microsoft.CodeAnalysis.SyntaxTokenList list, int index, params Microsoft.CodeAnalysis.SyntaxToken[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxTokenList Insert(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, int32 index, valuetype Microsoft.CodeAnalysis.SyntaxToken[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTokenList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="items" Type="Microsoft.CodeAnalysis.SyntaxToken[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="list">To be added.</param>
        <param name="index">To be added.</param>
        <param name="items">To be added.</param>
        <summary>
            Insert one or more tokens in the list at the specified index.
            </summary>
        <returns>A new list with the tokens inserted.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextualKeyword">
      <MemberSignature Language="C#" Value="public static bool IsContextualKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsContextualKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="token">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyword">
      <MemberSignature Language="C#" Value="public static bool IsKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="token">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReservedKeyword">
      <MemberSignature Language="C#" Value="public static bool IsReservedKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsReservedKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="token">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVerbatimIdentifier">
      <MemberSignature Language="C#" Value="public static bool IsVerbatimIdentifier (this Microsoft.CodeAnalysis.SyntaxToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsVerbatimIdentifier(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="token">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVerbatimStringLiteral">
      <MemberSignature Language="C#" Value="public static bool IsVerbatimStringLiteral (this Microsoft.CodeAnalysis.SyntaxToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsVerbatimStringLiteral(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="token">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Kind">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(class Microsoft.CodeAnalysis.SyntaxNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Kind">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="nodeOrToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Kind">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="token">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Kind">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxTrivia trivia);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxTrivia trivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" RefType="this" />
      </Parameters>
      <Docs>
        <param name="trivia">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceTrivia">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia (this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, Microsoft.CodeAnalysis.SyntaxTrivia newTrivia);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(valuetype Microsoft.CodeAnalysis.SyntaxToken token, valuetype Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia newTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        <Parameter Name="oldTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
        <Parameter Name="newTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
      </Parameters>
      <Docs>
        <param name="token"></param>
        <param name="oldTrivia">The trivia to be replaced.</param>
        <param name="newTrivia">The new trivia to use in the new tree in place of the old
            trivia.</param>
        <summary>
            Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in
            the token's leading or trailing trivia.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceTrivia">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia (this Microsoft.CodeAnalysis.SyntaxToken token, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(valuetype Microsoft.CodeAnalysis.SyntaxToken token, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, class System.Func`3&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        <Parameter Name="trivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        <Parameter Name="computeReplacementTrivia" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
      </Parameters>
      <Docs>
        <param name="token"></param>
        <param name="trivia">The trivia to be replaced; descendants of the root token.</param>
        <param name="computeReplacementTrivia">A function that computes a replacement trivia for
            the argument trivia. The first argument is the original trivia. The second argument is
            the same trivia rewritten with replaced structure.</param>
        <summary>
            Creates a new token with the specified old trivia replaced with computed new trivia.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="expressionBody" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="expressionBody">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with an expression body that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an expression body that did not appear in source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="attribute">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with an attribute that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an attribute that did not appear in source code. 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="constructorInitializer">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with a constructor initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a constructor initializer that did not appear in source code. 
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="crefSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="crefSyntax">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with a cref syntax node that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a cref syntax that did not appear in source code. 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="initializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="initializer">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with an initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a field initializer or default parameter value that did not appear in source code.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="statement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="statement">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with a statement that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a statement that did not appear in source code. 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, out Microsoft.CodeAnalysis.SemanticModel speculativeModel, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption = Microsoft.CodeAnalysis.SpeculativeBindingOption.BindAsExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="type" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="type">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <param name="bindingOption">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with a type syntax node that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a type syntax that did not appear in source code. 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModelForMethodBody">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModelForMethodBody (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax accessor, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModelForMethodBody(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax accessor, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="accessor" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="accessor">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position" /> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetSpeculativeSemanticModelForMethodBody">
      <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModelForMethodBody (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax method, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModelForMethodBody(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax method, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="method" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax" />
        <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="semanticModel">To be added.</param>
        <param name="position">To be added.</param>
        <param name="method">To be added.</param>
        <param name="speculativeModel">To be added.</param>
        <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position" /> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VarianceKindFromToken">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VarianceKind VarianceKindFromToken (this Microsoft.CodeAnalysis.SyntaxToken node);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.VarianceKind VarianceKindFromToken(valuetype Microsoft.CodeAnalysis.SyntaxToken node) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.VarianceKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>