<Type Name="INamedTypeSymbol" FullName="Microsoft.CodeAnalysis.INamedTypeSymbol">
  <TypeSignature Language="C#" Value="public interface INamedTypeSymbol : IEquatable&lt;Microsoft.CodeAnalysis.ISymbol&gt;, Microsoft.CodeAnalysis.ITypeSymbol" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract INamedTypeSymbol implements class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol, class Microsoft.CodeAnalysis.ISymbol, class Microsoft.CodeAnalysis.ITypeSymbol, class System.IEquatable`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt;" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.INamedTypeSymbol" />
  <TypeSignature Language="VB.NET" Value="Public Interface INamedTypeSymbol&#xA;Implements IEquatable(Of ISymbol), ITypeSymbol" />
  <TypeSignature Language="F#" Value="type INamedTypeSymbol = interface&#xA;    interface ITypeSymbol&#xA;    interface INamespaceOrTypeSymbol&#xA;    interface ISymbol&#xA;    interface IEquatable&lt;ISymbol&gt;" />
  <TypeSignature Language="C++ CLI" Value="public interface class INamedTypeSymbol : IEquatable&lt;Microsoft::CodeAnalysis::ISymbol ^&gt;, Microsoft::CodeAnalysis::ITypeSymbol" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
    <AssemblyVersion>2.9.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.CodeAnalysis.INamespaceOrTypeSymbol</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.CodeAnalysis.ISymbol</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.CodeAnalysis.ITypeSymbol</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;Microsoft.CodeAnalysis.ISymbol&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
            Represents a type other than an array, a pointer, a type parameter.
            </summary>
    <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
  </Docs>
  <Members>
    <Member MemberName="Arity">
      <MemberSignature Language="C#" Value="public int Arity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Arity" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.Arity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Arity As Integer" />
      <MemberSignature Language="F#" Value="member this.Arity : int" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.Arity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Arity { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns the arity of this type, or the number of type parameters it takes.
            A non-generic type has zero arity.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssociatedSymbol">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.ISymbol AssociatedSymbol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.ISymbol AssociatedSymbol" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.AssociatedSymbol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AssociatedSymbol As ISymbol" />
      <MemberSignature Language="F#" Value="member this.AssociatedSymbol : Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.AssociatedSymbol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::ISymbol ^ AssociatedSymbol { Microsoft::CodeAnalysis::ISymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            For implicitly declared delegate types returns the EventSymbol that caused this
            delegate type to be generated.
            For all other types returns null.
            Note, the set of possible associated symbols might be expanded in the future to 
            reflect changes in the languages.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Construct">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol Construct (params Microsoft.CodeAnalysis.ITypeSymbol[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol Construct(class Microsoft.CodeAnalysis.ITypeSymbol[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.INamedTypeSymbol.Construct(Microsoft.CodeAnalysis.ITypeSymbol[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Construct (ParamArray typeArguments As ITypeSymbol()) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="abstract member Construct : Microsoft.CodeAnalysis.ITypeSymbol[] -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="iNamedTypeSymbol.Construct typeArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::INamedTypeSymbol ^ Construct(... cli::array &lt;Microsoft::CodeAnalysis::ITypeSymbol ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="Microsoft.CodeAnalysis.ITypeSymbol[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the type.</param>
        <summary>
            Returns a constructed type given its type arguments.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructedFrom">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol ConstructedFrom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamedTypeSymbol ConstructedFrom" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.ConstructedFrom" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConstructedFrom As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.ConstructedFrom : Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.ConstructedFrom" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::INamedTypeSymbol ^ ConstructedFrom { Microsoft::CodeAnalysis::INamedTypeSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns the type symbol that this type was constructed from. This type symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Constructors">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IMethodSymbol&gt; Constructors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.IMethodSymbol&gt; Constructors" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.Constructors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constructors As ImmutableArray(Of IMethodSymbol)" />
      <MemberSignature Language="F#" Value="member this.Constructors : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IMethodSymbol&gt;" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.Constructors" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::IMethodSymbol ^&gt; Constructors { System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::IMethodSymbol ^&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IMethodSymbol&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Get the both instance and static constructors for this type.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructUnboundGenericType">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol ConstructUnboundGenericType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol ConstructUnboundGenericType() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.INamedTypeSymbol.ConstructUnboundGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Function ConstructUnboundGenericType () As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="abstract member ConstructUnboundGenericType : unit -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="iNamedTypeSymbol.ConstructUnboundGenericType " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::INamedTypeSymbol ^ ConstructUnboundGenericType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns an unbound generic type of this named type.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DelegateInvokeMethod">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.IMethodSymbol DelegateInvokeMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.IMethodSymbol DelegateInvokeMethod" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.DelegateInvokeMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DelegateInvokeMethod As IMethodSymbol" />
      <MemberSignature Language="F#" Value="member this.DelegateInvokeMethod : Microsoft.CodeAnalysis.IMethodSymbol" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.DelegateInvokeMethod" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::IMethodSymbol ^ DelegateInvokeMethod { Microsoft::CodeAnalysis::IMethodSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            For delegate types, gets the delegate's invoke method.  Returns null on
            all other kinds of types.  Note that it is possible to have an ill-formed
            delegate type imported from metadata which does not have an Invoke method.
            Such a type will be classified as a delegate but its DelegateInvokeMethod
            would be null.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumUnderlyingType">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol EnumUnderlyingType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamedTypeSymbol EnumUnderlyingType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.EnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EnumUnderlyingType As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.EnumUnderlyingType : Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.EnumUnderlyingType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::INamedTypeSymbol ^ EnumUnderlyingType { Microsoft::CodeAnalysis::INamedTypeSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            For enum types, gets the underlying type. Returns null on all other
            kinds of types.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArgumentCustomModifiers">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CustomModifier&gt; GetTypeArgumentCustomModifiers (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.CustomModifier&gt; GetTypeArgumentCustomModifiers(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.INamedTypeSymbol.GetTypeArgumentCustomModifiers(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeArgumentCustomModifiers (ordinal As Integer) As ImmutableArray(Of CustomModifier)" />
      <MemberSignature Language="F#" Value="abstract member GetTypeArgumentCustomModifiers : int -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CustomModifier&gt;" Usage="iNamedTypeSymbol.GetTypeArgumentCustomModifiers ordinal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::CustomModifier ^&gt; GetTypeArgumentCustomModifiers(int ordinal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CustomModifier&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">To be added.</param>
        <summary>
            Returns custom modifiers for the type argument that has been substituted for the type parameter. 
            The modifiers correspond to the type argument at the same ordinal within the <see cref="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TypeArguments" />
            array. Returns an empty array if there are no modifiers.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceConstructors">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IMethodSymbol&gt; InstanceConstructors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.IMethodSymbol&gt; InstanceConstructors" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.InstanceConstructors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceConstructors As ImmutableArray(Of IMethodSymbol)" />
      <MemberSignature Language="F#" Value="member this.InstanceConstructors : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IMethodSymbol&gt;" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.InstanceConstructors" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::IMethodSymbol ^&gt; InstanceConstructors { System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::IMethodSymbol ^&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IMethodSymbol&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Get the instance constructors for this type.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsComImport">
      <MemberSignature Language="C#" Value="public bool IsComImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsComImport" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsComImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsComImport As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsComImport : bool" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.IsComImport" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsComImport { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Specifies that the class or interface is imported from another module.  See
            <see cref="F:System.Reflection.TypeAttributes.Import" /> and <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /></summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.IsGenericType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            True if this type or some containing type has type parameters.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImplicitClass">
      <MemberSignature Language="C#" Value="public bool IsImplicitClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImplicitClass" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsImplicitClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImplicitClass As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsImplicitClass : bool" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.IsImplicitClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImplicitClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns true if the type is the implicit class that holds onto invalid global members (like methods or
            statements in a non script file).
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsScriptClass">
      <MemberSignature Language="C#" Value="public bool IsScriptClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsScriptClass" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsScriptClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsScriptClass As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsScriptClass : bool" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.IsScriptClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsScriptClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns true if the type is a Script class. 
            It might be an interactive submission class or a Script class in a csx file.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.IsSerializable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            True if the type is serializable (has Serializable metadata flag).
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnboundGenericType">
      <MemberSignature Language="C#" Value="public bool IsUnboundGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnboundGenericType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.IsUnboundGenericType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnboundGenericType As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsUnboundGenericType : bool" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.IsUnboundGenericType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnboundGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            True if this is a reference to an <em>unbound</em> generic type. A generic type is
            considered <em>unbound</em> if all of the type argument lists in its fully qualified
            name are empty. Note that the type arguments of an unbound generic type will be
            returned as error types because they do not really have type arguments.  An unbound
            generic type yields null for its BaseType and an empty result for its Interfaces.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MemberNames">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;string&gt; MemberNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; MemberNames" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.MemberNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MemberNames As IEnumerable(Of String)" />
      <MemberSignature Language="F#" Value="member this.MemberNames : seq&lt;string&gt;" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.MemberNames" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ MemberNames { System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns collection of names of members declared within this type.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MightContainExtensionMethods">
      <MemberSignature Language="C#" Value="public bool MightContainExtensionMethods { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MightContainExtensionMethods" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.MightContainExtensionMethods" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MightContainExtensionMethods As Boolean" />
      <MemberSignature Language="F#" Value="member this.MightContainExtensionMethods : bool" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.MightContainExtensionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MightContainExtensionMethods { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines if the symbol might contain extension methods. 
            If false, the symbol does not contain extension methods. 
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalDefinition">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol OriginalDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamedTypeSymbol OriginalDefinition" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.OriginalDefinition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalDefinition As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.OriginalDefinition : Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.OriginalDefinition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::INamedTypeSymbol ^ OriginalDefinition { Microsoft::CodeAnalysis::INamedTypeSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Get the original definition of this type symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StaticConstructors">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IMethodSymbol&gt; StaticConstructors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.IMethodSymbol&gt; StaticConstructors" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.StaticConstructors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConstructors As ImmutableArray(Of IMethodSymbol)" />
      <MemberSignature Language="F#" Value="member this.StaticConstructors : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IMethodSymbol&gt;" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.StaticConstructors" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::IMethodSymbol ^&gt; StaticConstructors { System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::IMethodSymbol ^&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IMethodSymbol&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Get the static constructors for this type.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TupleElements">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IFieldSymbol&gt; TupleElements { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.IFieldSymbol&gt; TupleElements" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TupleElements" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TupleElements As ImmutableArray(Of IFieldSymbol)" />
      <MemberSignature Language="F#" Value="member this.TupleElements : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IFieldSymbol&gt;" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.TupleElements" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::IFieldSymbol ^&gt; TupleElements { System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::IFieldSymbol ^&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IFieldSymbol&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Returns fields that represent tuple elements for types that are tuples.
            
             If this type is not a tuple, then returns default.
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TupleUnderlyingType">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol TupleUnderlyingType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamedTypeSymbol TupleUnderlyingType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TupleUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TupleUnderlyingType As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.TupleUnderlyingType : Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.TupleUnderlyingType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::INamedTypeSymbol ^ TupleUnderlyingType { Microsoft::CodeAnalysis::INamedTypeSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            If this is a tuple type symbol, returns the symbol for its underlying type.
            Otherwise, returns null.
            The type argument corresponding to the type of the extension field (VT[8].Rest),
            which is at the 8th (one based) position is always a symbol for another tuple, 
            rather than its underlying type.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeArguments">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; TypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ITypeSymbol&gt; TypeArguments" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeArguments As ImmutableArray(Of ITypeSymbol)" />
      <MemberSignature Language="F#" Value="member this.TypeArguments : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt;" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.TypeArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ITypeSymbol ^&gt; TypeArguments { System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ITypeSymbol ^&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a given type parameter,
            then the type parameter itself is considered the type argument.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeArgumentsNullableAnnotations">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.NullableAnnotation&gt; TypeArgumentsNullableAnnotations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;valuetype Microsoft.CodeAnalysis.NullableAnnotation&gt; TypeArgumentsNullableAnnotations" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TypeArgumentsNullableAnnotations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeArgumentsNullableAnnotations As ImmutableArray(Of NullableAnnotation)" />
      <MemberSignature Language="F#" Value="member this.TypeArgumentsNullableAnnotations : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.NullableAnnotation&gt;" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.TypeArgumentsNullableAnnotations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.NullableAnnotation&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns the top-level nullability of the type arguments that have been substituted
            for the type parameters. If nothing has been substituted for a given type parameter,
            then <see cref="F:Microsoft.CodeAnalysis.NullableAnnotation.NotApplicable" /> is returned for that type argument.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeParameterSymbol&gt; TypeParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ITypeParameterSymbol&gt; TypeParameters" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TypeParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeParameters As ImmutableArray(Of ITypeParameterSymbol)" />
      <MemberSignature Language="F#" Value="member this.TypeParameters : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeParameterSymbol&gt;" Usage="Microsoft.CodeAnalysis.INamedTypeSymbol.TypeParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ITypeParameterSymbol ^&gt; TypeParameters { System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ITypeParameterSymbol ^&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeParameterSymbol&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns the type parameters that this type has. If this is a non-generic type,
            returns an empty ImmutableArray.  
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>