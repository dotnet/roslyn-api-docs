<Type Name="Compilation" FullName="Microsoft.CodeAnalysis.Compilation">
  <TypeSignature Language="C#" Value="public abstract class Compilation" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Compilation extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.Compilation" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Compilation" />
  <TypeSignature Language="F#" Value="type Compilation = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class Compilation abstract" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
    <AssemblyVersion>2.9.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            The compilation object is an immutable representation of a single invocation of the
            compiler. Although immutable, a compilation is also on-demand, and will realize and cache
            data as necessary. A compilation can produce a new compilation from existing compilation
            with the application of small deltas. In many cases, it is more efficient than creating a
            new compilation from scratch, as the new compilation can reuse information from the old
            compilation.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="_features">
      <MemberSignature Language="C#" Value="protected readonly System.Collections.Generic.IReadOnlyDictionary&lt;string,string&gt; _features;" />
      <MemberSignature Language="ILAsm" Value=".field family initonly class System.Collections.Generic.IReadOnlyDictionary`2&lt;string, string&gt; _features" />
      <MemberSignature Language="DocId" Value="F:Microsoft.CodeAnalysis.Compilation._features" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly _features As IReadOnlyDictionary(Of String, String) " />
      <MemberSignature Language="F#" Value="val mutable _features : System.Collections.Generic.IReadOnlyDictionary&lt;string, string&gt;" Usage="Microsoft.CodeAnalysis.Compilation._features" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddReferences">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation AddReferences (params Microsoft.CodeAnalysis.MetadataReference[] references);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation AddReferences(class Microsoft.CodeAnalysis.MetadataReference[] references) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.AddReferences(Microsoft.CodeAnalysis.MetadataReference[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AddReferences (ParamArray references As MetadataReference()) As Compilation" />
      <MemberSignature Language="F#" Value="member this.AddReferences : Microsoft.CodeAnalysis.MetadataReference[] -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.AddReferences references" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ AddReferences(... cli::array &lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ references);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="references" Type="Microsoft.CodeAnalysis.MetadataReference[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="references">The new references.</param>
        <summary>
            Creates a new compilation with additional metadata references.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddReferences">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation AddReferences (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; references);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation AddReferences(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.MetadataReference&gt; references) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.AddReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddReferences (references As IEnumerable(Of MetadataReference)) As Compilation" />
      <MemberSignature Language="F#" Value="member this.AddReferences : seq&lt;Microsoft.CodeAnalysis.MetadataReference&gt; -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.AddReferences references" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ AddReferences(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ references);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="references" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt;" />
      </Parameters>
      <Docs>
        <param name="references">The new references.</param>
        <summary>
            Creates a new compilation with additional metadata references.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSyntaxTrees">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation AddSyntaxTrees (params Microsoft.CodeAnalysis.SyntaxTree[] trees);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation AddSyntaxTrees(class Microsoft.CodeAnalysis.SyntaxTree[] trees) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.AddSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AddSyntaxTrees (ParamArray trees As SyntaxTree()) As Compilation" />
      <MemberSignature Language="F#" Value="member this.AddSyntaxTrees : Microsoft.CodeAnalysis.SyntaxTree[] -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.AddSyntaxTrees trees" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ AddSyntaxTrees(... cli::array &lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ trees);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trees" Type="Microsoft.CodeAnalysis.SyntaxTree[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trees">The new syntax trees.</param>
        <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSyntaxTrees">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation AddSyntaxTrees (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; trees);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation AddSyntaxTrees(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxTree&gt; trees) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.AddSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddSyntaxTrees (trees As IEnumerable(Of SyntaxTree)) As Compilation" />
      <MemberSignature Language="F#" Value="member this.AddSyntaxTrees : seq&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.AddSyntaxTrees trees" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ AddSyntaxTrees(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ trees);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trees" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;" />
      </Parameters>
      <Docs>
        <param name="trees">The new syntax trees.</param>
        <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendDefaultVersionResource">
      <MemberSignature Language="C#" Value="protected abstract void AppendDefaultVersionResource (System.IO.Stream resourceStream);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AppendDefaultVersionResource(class System.IO.Stream resourceStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.AppendDefaultVersionResource(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub AppendDefaultVersionResource (resourceStream As Stream)" />
      <MemberSignature Language="F#" Value="abstract member AppendDefaultVersionResource : System.IO.Stream -&gt; unit" Usage="compilation.AppendDefaultVersionResource resourceStream" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void AppendDefaultVersionResource(System::IO::Stream ^ resourceStream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="resourceStream">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.IAssemblySymbol Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.IAssemblySymbol Assembly" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Assembly As IAssemblySymbol" />
      <MemberSignature Language="F#" Value="member this.Assembly : Microsoft.CodeAnalysis.IAssemblySymbol" Usage="Microsoft.CodeAnalysis.Compilation.Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::IAssemblySymbol ^ Assembly { Microsoft::CodeAnalysis::IAssemblySymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IAssemblySymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol" /> that represents the assembly being created.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyName">
      <MemberSignature Language="C#" Value="public string AssemblyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.AssemblyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AssemblyName As String" />
      <MemberSignature Language="F#" Value="member this.AssemblyName : string" Usage="Microsoft.CodeAnalysis.Compilation.AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AssemblyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Simple assembly name, or null if not specified.
             </summary>
        <value>To be added.</value>
        <remarks>
             The name is used for determining internals-visible-to relationship with referenced assemblies.
            
             If the compilation represents an assembly the value of <see cref="P:Microsoft.CodeAnalysis.Compilation.AssemblyName" /> is its simple name.
            
             Unless <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.ModuleName" /> specifies otherwise the module name
             written to metadata is <see cref="P:Microsoft.CodeAnalysis.Compilation.AssemblyName" /> with an extension based upon <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.OutputKind" />.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckTupleElementLocations">
      <MemberSignature Language="C#" Value="protected static void CheckTupleElementLocations (int cardinality, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; elementLocations);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void CheckTupleElementLocations(int32 cardinality, valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Location&gt; elementLocations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CheckTupleElementLocations(System.Int32,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub CheckTupleElementLocations (cardinality As Integer, elementLocations As ImmutableArray(Of Location))" />
      <MemberSignature Language="F#" Value="static member CheckTupleElementLocations : int * System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; -&gt; unit" Usage="Microsoft.CodeAnalysis.Compilation.CheckTupleElementLocations (cardinality, elementLocations)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void CheckTupleElementLocations(int cardinality, System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::Location ^&gt; elementLocations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardinality" Type="System.Int32" />
        <Parameter Name="elementLocations" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt;" />
      </Parameters>
      <Docs>
        <param name="cardinality">To be added.</param>
        <param name="elementLocations">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckTupleElementNames">
      <MemberSignature Language="C#" Value="protected static System.Collections.Immutable.ImmutableArray&lt;string&gt; CheckTupleElementNames (int cardinality, System.Collections.Immutable.ImmutableArray&lt;string&gt; elementNames);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;string&gt; CheckTupleElementNames(int32 cardinality, valuetype System.Collections.Immutable.ImmutableArray`1&lt;string&gt; elementNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CheckTupleElementNames(System.Int32,System.Collections.Immutable.ImmutableArray{System.String})" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function CheckTupleElementNames (cardinality As Integer, elementNames As ImmutableArray(Of String)) As ImmutableArray(Of String)" />
      <MemberSignature Language="F#" Value="static member CheckTupleElementNames : int * System.Collections.Immutable.ImmutableArray&lt;string&gt; -&gt; System.Collections.Immutable.ImmutableArray&lt;string&gt;" Usage="Microsoft.CodeAnalysis.Compilation.CheckTupleElementNames (cardinality, elementNames)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Collections::Immutable::ImmutableArray&lt;System::String ^&gt; CheckTupleElementNames(int cardinality, System::Collections::Immutable::ImmutableArray&lt;System::String ^&gt; elementNames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardinality" Type="System.Int32" />
        <Parameter Name="elementNames" Type="System.Collections.Immutable.ImmutableArray&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="cardinality">To be added.</param>
        <param name="elementNames">To be added.</param>
        <summary>
            Check that if any names are provided, and their number matches the expected cardinality.
            Returns a normalized version of the element names (empty array if all the names are null).
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassifyCommonConversion">
      <MemberSignature Language="C#" Value="public abstract Microsoft.CodeAnalysis.Operations.CommonConversion ClassifyCommonConversion (Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.CodeAnalysis.Operations.CommonConversion ClassifyCommonConversion(class Microsoft.CodeAnalysis.ITypeSymbol source, class Microsoft.CodeAnalysis.ITypeSymbol destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.ClassifyCommonConversion(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ClassifyCommonConversion (source As ITypeSymbol, destination As ITypeSymbol) As CommonConversion" />
      <MemberSignature Language="F#" Value="abstract member ClassifyCommonConversion : Microsoft.CodeAnalysis.ITypeSymbol * Microsoft.CodeAnalysis.ITypeSymbol -&gt; Microsoft.CodeAnalysis.Operations.CommonConversion" Usage="compilation.ClassifyCommonConversion (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Microsoft::CodeAnalysis::Operations::CommonConversion ClassifyCommonConversion(Microsoft::CodeAnalysis::ITypeSymbol ^ source, Microsoft::CodeAnalysis::ITypeSymbol ^ destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Operations.CommonConversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
      </Parameters>
      <Docs>
        <param name="source">Source type of value to be converted</param>
        <param name="destination">Destination type of value to be converted</param>
        <summary>
            Classifies a conversion from <paramref name="source" /> to <paramref name="destination" /> according
            to this compilation's programming language.
            </summary>
        <returns>A <see cref="T:Microsoft.CodeAnalysis.Operations.CommonConversion" /> that classifies the conversion from the
            <paramref name="source" /> type to the <paramref name="destination" /> type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Compilation" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.Clone " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Creates a new compilation equivalent to this one with different symbol instances.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonAddSyntaxTrees">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.Compilation CommonAddSyntaxTrees (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; trees);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.Compilation CommonAddSyntaxTrees(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxTree&gt; trees) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonAddSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonAddSyntaxTrees (trees As IEnumerable(Of SyntaxTree)) As Compilation" />
      <MemberSignature Language="F#" Value="abstract member CommonAddSyntaxTrees : seq&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.CommonAddSyntaxTrees trees" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::Compilation ^ CommonAddSyntaxTrees(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ trees);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trees" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;" />
      </Parameters>
      <Docs>
        <param name="trees">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonAssembly">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.IAssemblySymbol CommonAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.IAssemblySymbol CommonAssembly" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.CommonAssembly" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property CommonAssembly As IAssemblySymbol" />
      <MemberSignature Language="F#" Value="member this.CommonAssembly : Microsoft.CodeAnalysis.IAssemblySymbol" Usage="Microsoft.CodeAnalysis.Compilation.CommonAssembly" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property Microsoft::CodeAnalysis::IAssemblySymbol ^ CommonAssembly { Microsoft::CodeAnalysis::IAssemblySymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IAssemblySymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonBindScriptClass">
      <MemberSignature Language="C#" Value="protected Microsoft.CodeAnalysis.INamedTypeSymbol CommonBindScriptClass ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonBindScriptClass() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonBindScriptClass" />
      <MemberSignature Language="VB.NET" Value="Protected Function CommonBindScriptClass () As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.CommonBindScriptClass : unit -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="compilation.CommonBindScriptClass " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonBindScriptClass();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Resolves a symbol that represents script container (Script class). Uses the
            full name of the container class stored in <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.ScriptClassName" /> to find the symbol.
            </summary>
        <returns>The Script class symbol or null if it is not defined.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonClone">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.Compilation CommonClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.Compilation CommonClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonClone" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonClone () As Compilation" />
      <MemberSignature Language="F#" Value="abstract member CommonClone : unit -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.CommonClone " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::Compilation ^ CommonClone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonContainsSyntaxTree">
      <MemberSignature Language="C#" Value="protected abstract bool CommonContainsSyntaxTree (Microsoft.CodeAnalysis.SyntaxTree syntaxTree);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CommonContainsSyntaxTree(class Microsoft.CodeAnalysis.SyntaxTree syntaxTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree)" />
      <MemberSignature Language="F#" Value="abstract member CommonContainsSyntaxTree : Microsoft.CodeAnalysis.SyntaxTree -&gt; bool" Usage="compilation.CommonContainsSyntaxTree syntaxTree" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool CommonContainsSyntaxTree(Microsoft::CodeAnalysis::SyntaxTree ^ syntaxTree);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="syntaxTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
      </Parameters>
      <Docs>
        <param name="syntaxTree">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonCreateAnonymousTypeSymbol">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateAnonymousTypeSymbol (System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; memberTypes, System.Collections.Immutable.ImmutableArray&lt;string&gt; memberNames, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; memberLocations, System.Collections.Immutable.ImmutableArray&lt;bool&gt; memberIsReadOnly);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateAnonymousTypeSymbol(valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ITypeSymbol&gt; memberTypes, valuetype System.Collections.Immutable.ImmutableArray`1&lt;string&gt; memberNames, valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Location&gt; memberLocations, valuetype System.Collections.Immutable.ImmutableArray`1&lt;bool&gt; memberIsReadOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonCreateAnonymousTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableArray{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonCreateAnonymousTypeSymbol (memberTypes As ImmutableArray(Of ITypeSymbol), memberNames As ImmutableArray(Of String), memberLocations As ImmutableArray(Of Location), memberIsReadOnly As ImmutableArray(Of Boolean)) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="abstract member CommonCreateAnonymousTypeSymbol : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; * System.Collections.Immutable.ImmutableArray&lt;string&gt; * System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; * System.Collections.Immutable.ImmutableArray&lt;bool&gt; -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="compilation.CommonCreateAnonymousTypeSymbol (memberTypes, memberNames, memberLocations, memberIsReadOnly)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonCreateAnonymousTypeSymbol(System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ITypeSymbol ^&gt; memberTypes, System::Collections::Immutable::ImmutableArray&lt;System::String ^&gt; memberNames, System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::Location ^&gt; memberLocations, System::Collections::Immutable::ImmutableArray&lt;bool&gt; memberIsReadOnly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberTypes" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt;" />
        <Parameter Name="memberNames" Type="System.Collections.Immutable.ImmutableArray&lt;System.String&gt;" />
        <Parameter Name="memberLocations" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt;" />
        <Parameter Name="memberIsReadOnly" Type="System.Collections.Immutable.ImmutableArray&lt;System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="memberTypes">To be added.</param>
        <param name="memberNames">To be added.</param>
        <param name="memberLocations">To be added.</param>
        <param name="memberIsReadOnly">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonCreateArrayTypeSymbol">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.IArrayTypeSymbol CommonCreateArrayTypeSymbol (Microsoft.CodeAnalysis.ITypeSymbol elementType, int rank);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.IArrayTypeSymbol CommonCreateArrayTypeSymbol(class Microsoft.CodeAnalysis.ITypeSymbol elementType, int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonCreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonCreateArrayTypeSymbol (elementType As ITypeSymbol, rank As Integer) As IArrayTypeSymbol" />
      <MemberSignature Language="F#" Value="abstract member CommonCreateArrayTypeSymbol : Microsoft.CodeAnalysis.ITypeSymbol * int -&gt; Microsoft.CodeAnalysis.IArrayTypeSymbol" Usage="compilation.CommonCreateArrayTypeSymbol (elementType, rank)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::IArrayTypeSymbol ^ CommonCreateArrayTypeSymbol(Microsoft::CodeAnalysis::ITypeSymbol ^ elementType, int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IArrayTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">To be added.</param>
        <param name="rank">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonCreateErrorNamespaceSymbol">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.INamespaceSymbol CommonCreateErrorNamespaceSymbol (Microsoft.CodeAnalysis.INamespaceSymbol container, string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.INamespaceSymbol CommonCreateErrorNamespaceSymbol(class Microsoft.CodeAnalysis.INamespaceSymbol container, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonCreateErrorNamespaceSymbol(Microsoft.CodeAnalysis.INamespaceSymbol,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonCreateErrorNamespaceSymbol (container As INamespaceSymbol, name As String) As INamespaceSymbol" />
      <MemberSignature Language="F#" Value="abstract member CommonCreateErrorNamespaceSymbol : Microsoft.CodeAnalysis.INamespaceSymbol * string -&gt; Microsoft.CodeAnalysis.INamespaceSymbol" Usage="compilation.CommonCreateErrorNamespaceSymbol (container, name)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::INamespaceSymbol ^ CommonCreateErrorNamespaceSymbol(Microsoft::CodeAnalysis::INamespaceSymbol ^ container, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="Microsoft.CodeAnalysis.INamespaceSymbol" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="container">To be added.</param>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonCreateErrorTypeSymbol">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateErrorTypeSymbol (Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name, int arity);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateErrorTypeSymbol(class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name, int32 arity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonCreateErrorTypeSymbol(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonCreateErrorTypeSymbol (container As INamespaceOrTypeSymbol, name As String, arity As Integer) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="abstract member CommonCreateErrorTypeSymbol : Microsoft.CodeAnalysis.INamespaceOrTypeSymbol * string * int -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="compilation.CommonCreateErrorTypeSymbol (container, name, arity)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonCreateErrorTypeSymbol(Microsoft::CodeAnalysis::INamespaceOrTypeSymbol ^ container, System::String ^ name, int arity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="Microsoft.CodeAnalysis.INamespaceOrTypeSymbol" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="arity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="container">To be added.</param>
        <param name="name">To be added.</param>
        <param name="arity">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonCreatePointerTypeSymbol">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.IPointerTypeSymbol CommonCreatePointerTypeSymbol (Microsoft.CodeAnalysis.ITypeSymbol elementType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.IPointerTypeSymbol CommonCreatePointerTypeSymbol(class Microsoft.CodeAnalysis.ITypeSymbol elementType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonCreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonCreatePointerTypeSymbol (elementType As ITypeSymbol) As IPointerTypeSymbol" />
      <MemberSignature Language="F#" Value="abstract member CommonCreatePointerTypeSymbol : Microsoft.CodeAnalysis.ITypeSymbol -&gt; Microsoft.CodeAnalysis.IPointerTypeSymbol" Usage="compilation.CommonCreatePointerTypeSymbol elementType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::IPointerTypeSymbol ^ CommonCreatePointerTypeSymbol(Microsoft::CodeAnalysis::ITypeSymbol ^ elementType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IPointerTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
      </Parameters>
      <Docs>
        <param name="elementType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonCreateTupleTypeSymbol">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateTupleTypeSymbol (Microsoft.CodeAnalysis.INamedTypeSymbol underlyingType, System.Collections.Immutable.ImmutableArray&lt;string&gt; elementNames, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; elementLocations);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateTupleTypeSymbol(class Microsoft.CodeAnalysis.INamedTypeSymbol underlyingType, valuetype System.Collections.Immutable.ImmutableArray`1&lt;string&gt; elementNames, valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Location&gt; elementLocations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonCreateTupleTypeSymbol(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonCreateTupleTypeSymbol (underlyingType As INamedTypeSymbol, elementNames As ImmutableArray(Of String), elementLocations As ImmutableArray(Of Location)) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="abstract member CommonCreateTupleTypeSymbol : Microsoft.CodeAnalysis.INamedTypeSymbol * System.Collections.Immutable.ImmutableArray&lt;string&gt; * System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="compilation.CommonCreateTupleTypeSymbol (underlyingType, elementNames, elementLocations)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonCreateTupleTypeSymbol(Microsoft::CodeAnalysis::INamedTypeSymbol ^ underlyingType, System::Collections::Immutable::ImmutableArray&lt;System::String ^&gt; elementNames, System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::Location ^&gt; elementLocations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="underlyingType" Type="Microsoft.CodeAnalysis.INamedTypeSymbol" />
        <Parameter Name="elementNames" Type="System.Collections.Immutable.ImmutableArray&lt;System.String&gt;" />
        <Parameter Name="elementLocations" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt;" />
      </Parameters>
      <Docs>
        <param name="underlyingType">To be added.</param>
        <param name="elementNames">To be added.</param>
        <param name="elementLocations">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonCreateTupleTypeSymbol">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateTupleTypeSymbol (System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; elementTypes, System.Collections.Immutable.ImmutableArray&lt;string&gt; elementNames, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; elementLocations);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateTupleTypeSymbol(valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ITypeSymbol&gt; elementTypes, valuetype System.Collections.Immutable.ImmutableArray`1&lt;string&gt; elementNames, valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Location&gt; elementLocations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonCreateTupleTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonCreateTupleTypeSymbol (elementTypes As ImmutableArray(Of ITypeSymbol), elementNames As ImmutableArray(Of String), elementLocations As ImmutableArray(Of Location)) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="abstract member CommonCreateTupleTypeSymbol : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; * System.Collections.Immutable.ImmutableArray&lt;string&gt; * System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="compilation.CommonCreateTupleTypeSymbol (elementTypes, elementNames, elementLocations)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonCreateTupleTypeSymbol(System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ITypeSymbol ^&gt; elementTypes, System::Collections::Immutable::ImmutableArray&lt;System::String ^&gt; elementNames, System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::Location ^&gt; elementLocations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementTypes" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt;" />
        <Parameter Name="elementNames" Type="System.Collections.Immutable.ImmutableArray&lt;System.String&gt;" />
        <Parameter Name="elementLocations" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt;" />
      </Parameters>
      <Docs>
        <param name="elementTypes">To be added.</param>
        <param name="elementNames">To be added.</param>
        <param name="elementLocations">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonDynamicType">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.ITypeSymbol CommonDynamicType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.ITypeSymbol CommonDynamicType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.CommonDynamicType" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property CommonDynamicType As ITypeSymbol" />
      <MemberSignature Language="F#" Value="member this.CommonDynamicType : Microsoft.CodeAnalysis.ITypeSymbol" Usage="Microsoft.CodeAnalysis.Compilation.CommonDynamicType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property Microsoft::CodeAnalysis::ITypeSymbol ^ CommonDynamicType { Microsoft::CodeAnalysis::ITypeSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ITypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonGetAssemblyOrModuleSymbol">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.ISymbol CommonGetAssemblyOrModuleSymbol (Microsoft.CodeAnalysis.MetadataReference reference);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.ISymbol CommonGetAssemblyOrModuleSymbol(class Microsoft.CodeAnalysis.MetadataReference reference) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonGetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonGetAssemblyOrModuleSymbol (reference As MetadataReference) As ISymbol" />
      <MemberSignature Language="F#" Value="abstract member CommonGetAssemblyOrModuleSymbol : Microsoft.CodeAnalysis.MetadataReference -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="compilation.CommonGetAssemblyOrModuleSymbol reference" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::ISymbol ^ CommonGetAssemblyOrModuleSymbol(Microsoft::CodeAnalysis::MetadataReference ^ reference);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reference" Type="Microsoft.CodeAnalysis.MetadataReference" />
      </Parameters>
      <Docs>
        <param name="reference">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonGetCompilationNamespace">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.INamespaceSymbol CommonGetCompilationNamespace (Microsoft.CodeAnalysis.INamespaceSymbol namespaceSymbol);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.INamespaceSymbol CommonGetCompilationNamespace(class Microsoft.CodeAnalysis.INamespaceSymbol namespaceSymbol) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonGetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonGetCompilationNamespace (namespaceSymbol As INamespaceSymbol) As INamespaceSymbol" />
      <MemberSignature Language="F#" Value="abstract member CommonGetCompilationNamespace : Microsoft.CodeAnalysis.INamespaceSymbol -&gt; Microsoft.CodeAnalysis.INamespaceSymbol" Usage="compilation.CommonGetCompilationNamespace namespaceSymbol" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::INamespaceSymbol ^ CommonGetCompilationNamespace(Microsoft::CodeAnalysis::INamespaceSymbol ^ namespaceSymbol);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceSymbol" Type="Microsoft.CodeAnalysis.INamespaceSymbol" />
      </Parameters>
      <Docs>
        <param name="namespaceSymbol">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonGetEntryPoint">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.IMethodSymbol CommonGetEntryPoint (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.IMethodSymbol CommonGetEntryPoint(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonGetEntryPoint(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member CommonGetEntryPoint : System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IMethodSymbol" Usage="compilation.CommonGetEntryPoint cancellationToken" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::IMethodSymbol ^ CommonGetEntryPoint(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonGetSemanticModel">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.SemanticModel CommonGetSemanticModel (Microsoft.CodeAnalysis.SyntaxTree syntaxTree, bool ignoreAccessibility);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.SemanticModel CommonGetSemanticModel(class Microsoft.CodeAnalysis.SyntaxTree syntaxTree, bool ignoreAccessibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonGetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member CommonGetSemanticModel : Microsoft.CodeAnalysis.SyntaxTree * bool -&gt; Microsoft.CodeAnalysis.SemanticModel" Usage="compilation.CommonGetSemanticModel (syntaxTree, ignoreAccessibility)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::SemanticModel ^ CommonGetSemanticModel(Microsoft::CodeAnalysis::SyntaxTree ^ syntaxTree, bool ignoreAccessibility);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SemanticModel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="syntaxTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
        <Parameter Name="ignoreAccessibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="syntaxTree">To be added.</param>
        <param name="ignoreAccessibility">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonGetSpecialType">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.INamedTypeSymbol CommonGetSpecialType (Microsoft.CodeAnalysis.SpecialType specialType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonGetSpecialType(valuetype Microsoft.CodeAnalysis.SpecialType specialType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonGetSpecialType(Microsoft.CodeAnalysis.SpecialType)" />
      <MemberSignature Language="F#" Value="abstract member CommonGetSpecialType : Microsoft.CodeAnalysis.SpecialType -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="compilation.CommonGetSpecialType specialType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonGetSpecialType(Microsoft::CodeAnalysis::SpecialType specialType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="specialType" Type="Microsoft.CodeAnalysis.SpecialType" />
      </Parameters>
      <Docs>
        <param name="specialType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonGetTypeByMetadataName">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.INamedTypeSymbol CommonGetTypeByMetadataName (string metadataName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonGetTypeByMetadataName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonGetTypeByMetadataName (metadataName As String) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="abstract member CommonGetTypeByMetadataName : string -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="compilation.CommonGetTypeByMetadataName metadataName" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonGetTypeByMetadataName(System::String ^ metadataName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="metadataName">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonGlobalNamespace">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.INamespaceSymbol CommonGlobalNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamespaceSymbol CommonGlobalNamespace" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.CommonGlobalNamespace" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property CommonGlobalNamespace As INamespaceSymbol" />
      <MemberSignature Language="F#" Value="member this.CommonGlobalNamespace : Microsoft.CodeAnalysis.INamespaceSymbol" Usage="Microsoft.CodeAnalysis.Compilation.CommonGlobalNamespace" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property Microsoft::CodeAnalysis::INamespaceSymbol ^ CommonGlobalNamespace { Microsoft::CodeAnalysis::INamespaceSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonObjectType">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.INamedTypeSymbol CommonObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonObjectType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.CommonObjectType" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property CommonObjectType As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.CommonObjectType : Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.Compilation.CommonObjectType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonObjectType { Microsoft::CodeAnalysis::INamedTypeSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonOptions">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.CompilationOptions CommonOptions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.CommonOptions" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property CommonOptions As CompilationOptions" />
      <MemberSignature Language="F#" Value="member this.CommonOptions : Microsoft.CodeAnalysis.CompilationOptions" Usage="Microsoft.CodeAnalysis.Compilation.CommonOptions" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property Microsoft::CodeAnalysis::CompilationOptions ^ CommonOptions { Microsoft::CodeAnalysis::CompilationOptions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CompilationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonRemoveAllSyntaxTrees">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.Compilation CommonRemoveAllSyntaxTrees ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.Compilation CommonRemoveAllSyntaxTrees() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonRemoveAllSyntaxTrees" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonRemoveAllSyntaxTrees () As Compilation" />
      <MemberSignature Language="F#" Value="abstract member CommonRemoveAllSyntaxTrees : unit -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.CommonRemoveAllSyntaxTrees " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::Compilation ^ CommonRemoveAllSyntaxTrees();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonRemoveSyntaxTrees">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.Compilation CommonRemoveSyntaxTrees (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; trees);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.Compilation CommonRemoveSyntaxTrees(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxTree&gt; trees) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonRemoveSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonRemoveSyntaxTrees (trees As IEnumerable(Of SyntaxTree)) As Compilation" />
      <MemberSignature Language="F#" Value="abstract member CommonRemoveSyntaxTrees : seq&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.CommonRemoveSyntaxTrees trees" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::Compilation ^ CommonRemoveSyntaxTrees(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ trees);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trees" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;" />
      </Parameters>
      <Docs>
        <param name="trees">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonReplaceSyntaxTree">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.Compilation CommonReplaceSyntaxTree (Microsoft.CodeAnalysis.SyntaxTree oldTree, Microsoft.CodeAnalysis.SyntaxTree newTree);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.Compilation CommonReplaceSyntaxTree(class Microsoft.CodeAnalysis.SyntaxTree oldTree, class Microsoft.CodeAnalysis.SyntaxTree newTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonReplaceSyntaxTree (oldTree As SyntaxTree, newTree As SyntaxTree) As Compilation" />
      <MemberSignature Language="F#" Value="abstract member CommonReplaceSyntaxTree : Microsoft.CodeAnalysis.SyntaxTree * Microsoft.CodeAnalysis.SyntaxTree -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.CommonReplaceSyntaxTree (oldTree, newTree)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::Compilation ^ CommonReplaceSyntaxTree(Microsoft::CodeAnalysis::SyntaxTree ^ oldTree, Microsoft::CodeAnalysis::SyntaxTree ^ newTree);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
        <Parameter Name="newTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
      </Parameters>
      <Docs>
        <param name="oldTree">To be added.</param>
        <param name="newTree">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonScriptClass">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.INamedTypeSymbol CommonScriptClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonScriptClass" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.CommonScriptClass" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property CommonScriptClass As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.CommonScriptClass : Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.Compilation.CommonScriptClass" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonScriptClass { Microsoft::CodeAnalysis::INamedTypeSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonSourceModule">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.IModuleSymbol CommonSourceModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.IModuleSymbol CommonSourceModule" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.CommonSourceModule" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property CommonSourceModule As IModuleSymbol" />
      <MemberSignature Language="F#" Value="member this.CommonSourceModule : Microsoft.CodeAnalysis.IModuleSymbol" Usage="Microsoft.CodeAnalysis.Compilation.CommonSourceModule" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property Microsoft::CodeAnalysis::IModuleSymbol ^ CommonSourceModule { Microsoft::CodeAnalysis::IModuleSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IModuleSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonSyntaxTrees">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; CommonSyntaxTrees { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxTree&gt; CommonSyntaxTrees" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.CommonSyntaxTrees" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property CommonSyntaxTrees As IEnumerable(Of SyntaxTree)" />
      <MemberSignature Language="F#" Value="member this.CommonSyntaxTrees : seq&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;" Usage="Microsoft.CodeAnalysis.Compilation.CommonSyntaxTrees" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ CommonSyntaxTrees { System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonWithAssemblyName">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.Compilation CommonWithAssemblyName (string outputName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.Compilation CommonWithAssemblyName(string outputName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonWithAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonWithAssemblyName (outputName As String) As Compilation" />
      <MemberSignature Language="F#" Value="abstract member CommonWithAssemblyName : string -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.CommonWithAssemblyName outputName" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::Compilation ^ CommonWithAssemblyName(System::String ^ outputName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outputName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="outputName">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonWithOptions">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.Compilation CommonWithOptions (Microsoft.CodeAnalysis.CompilationOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.Compilation CommonWithOptions(class Microsoft.CodeAnalysis.CompilationOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonWithOptions(Microsoft.CodeAnalysis.CompilationOptions)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonWithOptions (options As CompilationOptions) As Compilation" />
      <MemberSignature Language="F#" Value="abstract member CommonWithOptions : Microsoft.CodeAnalysis.CompilationOptions -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.CommonWithOptions options" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::Compilation ^ CommonWithOptions(Microsoft::CodeAnalysis::CompilationOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="Microsoft.CodeAnalysis.CompilationOptions" />
      </Parameters>
      <Docs>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonWithReferences">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.Compilation CommonWithReferences (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; newReferences);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.Compilation CommonWithReferences(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.MetadataReference&gt; newReferences) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonWithReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonWithReferences (newReferences As IEnumerable(Of MetadataReference)) As Compilation" />
      <MemberSignature Language="F#" Value="abstract member CommonWithReferences : seq&lt;Microsoft.CodeAnalysis.MetadataReference&gt; -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.CommonWithReferences newReferences" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::Compilation ^ CommonWithReferences(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ newReferences);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newReferences" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt;" />
      </Parameters>
      <Docs>
        <param name="newReferences">To be added.</param>
        <summary>
            Creates a new compilation with the specified references.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonWithScriptCompilationInfo">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.Compilation CommonWithScriptCompilationInfo (Microsoft.CodeAnalysis.ScriptCompilationInfo info);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.Compilation CommonWithScriptCompilationInfo(class Microsoft.CodeAnalysis.ScriptCompilationInfo info) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CommonWithScriptCompilationInfo(Microsoft.CodeAnalysis.ScriptCompilationInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CommonWithScriptCompilationInfo (info As ScriptCompilationInfo) As Compilation" />
      <MemberSignature Language="F#" Value="abstract member CommonWithScriptCompilationInfo : Microsoft.CodeAnalysis.ScriptCompilationInfo -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.CommonWithScriptCompilationInfo info" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::Compilation ^ CommonWithScriptCompilationInfo(Microsoft::CodeAnalysis::ScriptCompilationInfo ^ info);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="Microsoft.CodeAnalysis.ScriptCompilationInfo" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsSymbolsWithName">
      <MemberSignature Language="C#" Value="public abstract bool ContainsSymbolsWithName (Func&lt;string,bool&gt; predicate, Microsoft.CodeAnalysis.SymbolFilter filter = Microsoft.CodeAnalysis.SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsSymbolsWithName(class System.Func`2&lt;string, bool&gt; predicate, valuetype Microsoft.CodeAnalysis.SymbolFilter filter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.ContainsSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member ContainsSymbolsWithName : Func&lt;string, bool&gt; * Microsoft.CodeAnalysis.SymbolFilter * System.Threading.CancellationToken -&gt; bool" Usage="compilation.ContainsSymbolsWithName (predicate, filter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="predicate" Type="System.Func&lt;System.String,System.Boolean&gt;" />
        <Parameter Name="filter" Type="Microsoft.CodeAnalysis.SymbolFilter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="predicate">To be added.</param>
        <param name="filter">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Return true if there is a source declaration symbol name that meets given predicate.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsSymbolsWithName">
      <MemberSignature Language="C#" Value="public abstract bool ContainsSymbolsWithName (string name, Microsoft.CodeAnalysis.SymbolFilter filter = Microsoft.CodeAnalysis.SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsSymbolsWithName(string name, valuetype Microsoft.CodeAnalysis.SymbolFilter filter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.ContainsSymbolsWithName(System.String,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member ContainsSymbolsWithName : string * Microsoft.CodeAnalysis.SymbolFilter * System.Threading.CancellationToken -&gt; bool" Usage="compilation.ContainsSymbolsWithName (name, filter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="filter" Type="Microsoft.CodeAnalysis.SymbolFilter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="filter">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Return true if there is a source declaration symbol name that matches the provided name.
            This may be faster than <see cref="M:Microsoft.CodeAnalysis.Compilation.ContainsSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)" /> when predicate is just a simple string check.
            <paramref name="name" /> is case sensitive or not depending on the target language.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsSyntaxTree">
      <MemberSignature Language="C#" Value="public bool ContainsSyntaxTree (Microsoft.CodeAnalysis.SyntaxTree syntaxTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsSyntaxTree(class Microsoft.CodeAnalysis.SyntaxTree syntaxTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.ContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree)" />
      <MemberSignature Language="F#" Value="member this.ContainsSyntaxTree : Microsoft.CodeAnalysis.SyntaxTree -&gt; bool" Usage="compilation.ContainsSyntaxTree syntaxTree" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsSyntaxTree(Microsoft::CodeAnalysis::SyntaxTree ^ syntaxTree);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="syntaxTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
      </Parameters>
      <Docs>
        <param name="syntaxTree">A syntax tree.</param>
        <summary>
            Returns true if this compilation contains the specified tree. False otherwise.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAnonymousTypeSymbol">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol CreateAnonymousTypeSymbol (System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; memberTypes, System.Collections.Immutable.ImmutableArray&lt;string&gt; memberNames, System.Collections.Immutable.ImmutableArray&lt;bool&gt; memberIsReadOnly = null, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; memberLocations = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.INamedTypeSymbol CreateAnonymousTypeSymbol(valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ITypeSymbol&gt; memberTypes, valuetype System.Collections.Immutable.ImmutableArray`1&lt;string&gt; memberNames, valuetype System.Collections.Immutable.ImmutableArray`1&lt;bool&gt; memberIsReadOnly, valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Location&gt; memberLocations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CreateAnonymousTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.Boolean},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAnonymousTypeSymbol (memberTypes As ImmutableArray(Of ITypeSymbol), memberNames As ImmutableArray(Of String), Optional memberIsReadOnly As ImmutableArray(Of Boolean) = null, Optional memberLocations As ImmutableArray(Of Location) = null) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.CreateAnonymousTypeSymbol : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; * System.Collections.Immutable.ImmutableArray&lt;string&gt; * System.Collections.Immutable.ImmutableArray&lt;bool&gt; * System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="compilation.CreateAnonymousTypeSymbol (memberTypes, memberNames, memberIsReadOnly, memberLocations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberTypes" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt;" />
        <Parameter Name="memberNames" Type="System.Collections.Immutable.ImmutableArray&lt;System.String&gt;" />
        <Parameter Name="memberIsReadOnly" Type="System.Collections.Immutable.ImmutableArray&lt;System.Boolean&gt;" />
        <Parameter Name="memberLocations" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt;" />
      </Parameters>
      <Docs>
        <param name="memberTypes">To be added.</param>
        <param name="memberNames">To be added.</param>
        <param name="memberIsReadOnly">To be added.</param>
        <param name="memberLocations">To be added.</param>
        <summary>
             Returns a new anonymous type symbol with the given member types member names.
             Anonymous type members will be readonly by default.  Writable properties are
             supported in VB and can be created by passing in <see langword="false" /> in the
             appropriate locations in <paramref name="memberIsReadOnly" />.
            
             Source locations can also be provided through <paramref name="memberLocations" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateArrayTypeSymbol">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.IArrayTypeSymbol CreateArrayTypeSymbol (Microsoft.CodeAnalysis.ITypeSymbol elementType, int rank = 1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.IArrayTypeSymbol CreateArrayTypeSymbol(class Microsoft.CodeAnalysis.ITypeSymbol elementType, int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateArrayTypeSymbol (elementType As ITypeSymbol, Optional rank As Integer = 1) As IArrayTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.CreateArrayTypeSymbol : Microsoft.CodeAnalysis.ITypeSymbol * int -&gt; Microsoft.CodeAnalysis.IArrayTypeSymbol" Usage="compilation.CreateArrayTypeSymbol (elementType, rank)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IArrayTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">To be added.</param>
        <param name="rank">To be added.</param>
        <summary>
            Returns a new ArrayTypeSymbol representing an array type tied to the base types of the
            COR Library in this Compilation.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultWin32Resources">
      <MemberSignature Language="C#" Value="public System.IO.Stream CreateDefaultWin32Resources (bool versionResource, bool noManifest, System.IO.Stream manifestContents, System.IO.Stream iconInIcoFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream CreateDefaultWin32Resources(bool versionResource, bool noManifest, class System.IO.Stream manifestContents, class System.IO.Stream iconInIcoFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CreateDefaultWin32Resources(System.Boolean,System.Boolean,System.IO.Stream,System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDefaultWin32Resources (versionResource As Boolean, noManifest As Boolean, manifestContents As Stream, iconInIcoFormat As Stream) As Stream" />
      <MemberSignature Language="F#" Value="member this.CreateDefaultWin32Resources : bool * bool * System.IO.Stream * System.IO.Stream -&gt; System.IO.Stream" Usage="compilation.CreateDefaultWin32Resources (versionResource, noManifest, manifestContents, iconInIcoFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ CreateDefaultWin32Resources(bool versionResource, bool noManifest, System::IO::Stream ^ manifestContents, System::IO::Stream ^ iconInIcoFormat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="versionResource" Type="System.Boolean" />
        <Parameter Name="noManifest" Type="System.Boolean" />
        <Parameter Name="manifestContents" Type="System.IO.Stream" />
        <Parameter Name="iconInIcoFormat" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="versionResource">To be added.</param>
        <param name="noManifest">To be added.</param>
        <param name="manifestContents">To be added.</param>
        <param name="iconInIcoFormat">To be added.</param>
        <summary>
            Create a stream filled with default win32 resources.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorNamespaceSymbol">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamespaceSymbol CreateErrorNamespaceSymbol (Microsoft.CodeAnalysis.INamespaceSymbol container, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.INamespaceSymbol CreateErrorNamespaceSymbol(class Microsoft.CodeAnalysis.INamespaceSymbol container, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CreateErrorNamespaceSymbol(Microsoft.CodeAnalysis.INamespaceSymbol,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateErrorNamespaceSymbol (container As INamespaceSymbol, name As String) As INamespaceSymbol" />
      <MemberSignature Language="F#" Value="member this.CreateErrorNamespaceSymbol : Microsoft.CodeAnalysis.INamespaceSymbol * string -&gt; Microsoft.CodeAnalysis.INamespaceSymbol" Usage="compilation.CreateErrorNamespaceSymbol (container, name)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::INamespaceSymbol ^ CreateErrorNamespaceSymbol(Microsoft::CodeAnalysis::INamespaceSymbol ^ container, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="Microsoft.CodeAnalysis.INamespaceSymbol" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="container">To be added.</param>
        <param name="name">To be added.</param>
        <summary>
            Returns a new INamespaceSymbol representing an error (missing) namespace with the given name.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorTypeSymbol">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol CreateErrorTypeSymbol (Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name, int arity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.INamedTypeSymbol CreateErrorTypeSymbol(class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name, int32 arity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CreateErrorTypeSymbol(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateErrorTypeSymbol (container As INamespaceOrTypeSymbol, name As String, arity As Integer) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.CreateErrorTypeSymbol : Microsoft.CodeAnalysis.INamespaceOrTypeSymbol * string * int -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="compilation.CreateErrorTypeSymbol (container, name, arity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::INamedTypeSymbol ^ CreateErrorTypeSymbol(Microsoft::CodeAnalysis::INamespaceOrTypeSymbol ^ container, System::String ^ name, int arity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="Microsoft.CodeAnalysis.INamespaceOrTypeSymbol" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="arity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="container">To be added.</param>
        <param name="name">To be added.</param>
        <param name="arity">To be added.</param>
        <summary>
            Returns a new INamedTypeSymbol representing an error type with the given name and arity
            in the given optional container.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreatePointerTypeSymbol">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.IPointerTypeSymbol CreatePointerTypeSymbol (Microsoft.CodeAnalysis.ITypeSymbol pointedAtType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.IPointerTypeSymbol CreatePointerTypeSymbol(class Microsoft.CodeAnalysis.ITypeSymbol pointedAtType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePointerTypeSymbol (pointedAtType As ITypeSymbol) As IPointerTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.CreatePointerTypeSymbol : Microsoft.CodeAnalysis.ITypeSymbol -&gt; Microsoft.CodeAnalysis.IPointerTypeSymbol" Usage="compilation.CreatePointerTypeSymbol pointedAtType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::IPointerTypeSymbol ^ CreatePointerTypeSymbol(Microsoft::CodeAnalysis::ITypeSymbol ^ pointedAtType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IPointerTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointedAtType" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
      </Parameters>
      <Docs>
        <param name="pointedAtType">To be added.</param>
        <summary>
            Returns a new PointerTypeSymbol representing a pointer type tied to a type in this
            Compilation.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTupleTypeSymbol">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol CreateTupleTypeSymbol (Microsoft.CodeAnalysis.INamedTypeSymbol underlyingType, System.Collections.Immutable.ImmutableArray&lt;string&gt; elementNames = null, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; elementLocations = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.INamedTypeSymbol CreateTupleTypeSymbol(class Microsoft.CodeAnalysis.INamedTypeSymbol underlyingType, valuetype System.Collections.Immutable.ImmutableArray`1&lt;string&gt; elementNames, valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Location&gt; elementLocations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CreateTupleTypeSymbol(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTupleTypeSymbol (underlyingType As INamedTypeSymbol, Optional elementNames As ImmutableArray(Of String) = null, Optional elementLocations As ImmutableArray(Of Location) = null) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.CreateTupleTypeSymbol : Microsoft.CodeAnalysis.INamedTypeSymbol * System.Collections.Immutable.ImmutableArray&lt;string&gt; * System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="compilation.CreateTupleTypeSymbol (underlyingType, elementNames, elementLocations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="underlyingType" Type="Microsoft.CodeAnalysis.INamedTypeSymbol" />
        <Parameter Name="elementNames" Type="System.Collections.Immutable.ImmutableArray&lt;System.String&gt;" />
        <Parameter Name="elementLocations" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt;" />
      </Parameters>
      <Docs>
        <param name="underlyingType">To be added.</param>
        <param name="elementNames">To be added.</param>
        <param name="elementLocations">To be added.</param>
        <summary>
            Returns a new INamedTypeSymbol with the given underlying type and (optional) element names.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            Since VB doesn't support tuples yet, this call will fail in a VB compilation.
            Also, the underlying type needs to be tuple-compatible.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTupleTypeSymbol">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol CreateTupleTypeSymbol (System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; elementTypes, System.Collections.Immutable.ImmutableArray&lt;string&gt; elementNames = null, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; elementLocations = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.INamedTypeSymbol CreateTupleTypeSymbol(valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ITypeSymbol&gt; elementTypes, valuetype System.Collections.Immutable.ImmutableArray`1&lt;string&gt; elementNames, valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Location&gt; elementLocations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.CreateTupleTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTupleTypeSymbol (elementTypes As ImmutableArray(Of ITypeSymbol), Optional elementNames As ImmutableArray(Of String) = null, Optional elementLocations As ImmutableArray(Of Location) = null) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.CreateTupleTypeSymbol : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; * System.Collections.Immutable.ImmutableArray&lt;string&gt; * System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="compilation.CreateTupleTypeSymbol (elementTypes, elementNames, elementLocations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementTypes" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt;" />
        <Parameter Name="elementNames" Type="System.Collections.Immutable.ImmutableArray&lt;System.String&gt;" />
        <Parameter Name="elementLocations" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt;" />
      </Parameters>
      <Docs>
        <param name="elementTypes">To be added.</param>
        <param name="elementNames">To be added.</param>
        <param name="elementLocations">To be added.</param>
        <summary>
            Returns a new INamedTypeSymbol with the given element types and (optional) element names.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectiveReferences">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.MetadataReference&gt; DirectiveReferences { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.MetadataReference&gt; DirectiveReferences" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.DirectiveReferences" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DirectiveReferences As ImmutableArray(Of MetadataReference)" />
      <MemberSignature Language="F#" Value="member this.DirectiveReferences : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.MetadataReference&gt;" Usage="Microsoft.CodeAnalysis.Compilation.DirectiveReferences" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; DirectiveReferences { System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.MetadataReference&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Unique metadata references specified via #r directive in the source code of this compilation.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicType">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.ITypeSymbol DynamicType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.ITypeSymbol DynamicType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.DynamicType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicType As ITypeSymbol" />
      <MemberSignature Language="F#" Value="member this.DynamicType : Microsoft.CodeAnalysis.ITypeSymbol" Usage="Microsoft.CodeAnalysis.Compilation.DynamicType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::ITypeSymbol ^ DynamicType { Microsoft::CodeAnalysis::ITypeSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ITypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The TypeSymbol for the type 'dynamic' in this Compilation.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Emit.EmitResult Emit (System.IO.Stream peStream, System.IO.Stream pdbStream, System.IO.Stream xmlDocumentationStream, System.IO.Stream win32Resources, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ResourceDescription&gt; manifestResources, Microsoft.CodeAnalysis.Emit.EmitOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Emit.EmitResult Emit(class System.IO.Stream peStream, class System.IO.Stream pdbStream, class System.IO.Stream xmlDocumentationStream, class System.IO.Stream win32Resources, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.ResourceDescription&gt; manifestResources, class Microsoft.CodeAnalysis.Emit.EmitOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.Emit(System.IO.Stream,System.IO.Stream,System.IO.Stream,System.IO.Stream,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},Microsoft.CodeAnalysis.Emit.EmitOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="member this.Emit : System.IO.Stream * System.IO.Stream * System.IO.Stream * System.IO.Stream * seq&lt;Microsoft.CodeAnalysis.ResourceDescription&gt; * Microsoft.CodeAnalysis.Emit.EmitOptions * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.Emit.EmitResult" Usage="compilation.Emit (peStream, pdbStream, xmlDocumentationStream, win32Resources, manifestResources, options, cancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Emit::EmitResult ^ Emit(System::IO::Stream ^ peStream, System::IO::Stream ^ pdbStream, System::IO::Stream ^ xmlDocumentationStream, System::IO::Stream ^ win32Resources, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::ResourceDescription ^&gt; ^ manifestResources, Microsoft::CodeAnalysis::Emit::EmitOptions ^ options, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Emit.EmitResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peStream" Type="System.IO.Stream" />
        <Parameter Name="pdbStream" Type="System.IO.Stream" />
        <Parameter Name="xmlDocumentationStream" Type="System.IO.Stream" />
        <Parameter Name="win32Resources" Type="System.IO.Stream" />
        <Parameter Name="manifestResources" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ResourceDescription&gt;" />
        <Parameter Name="options" Type="Microsoft.CodeAnalysis.Emit.EmitOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="peStream">To be added.</param>
        <param name="pdbStream">To be added.</param>
        <param name="xmlDocumentationStream">To be added.</param>
        <param name="win32Resources">To be added.</param>
        <param name="manifestResources">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Emit.EmitResult Emit (System.IO.Stream peStream, System.IO.Stream pdbStream, System.IO.Stream xmlDocumentationStream, System.IO.Stream win32Resources, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ResourceDescription&gt; manifestResources, Microsoft.CodeAnalysis.Emit.EmitOptions options, Microsoft.CodeAnalysis.IMethodSymbol debugEntryPoint, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Emit.EmitResult Emit(class System.IO.Stream peStream, class System.IO.Stream pdbStream, class System.IO.Stream xmlDocumentationStream, class System.IO.Stream win32Resources, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.ResourceDescription&gt; manifestResources, class Microsoft.CodeAnalysis.Emit.EmitOptions options, class Microsoft.CodeAnalysis.IMethodSymbol debugEntryPoint, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.Emit(System.IO.Stream,System.IO.Stream,System.IO.Stream,System.IO.Stream,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},Microsoft.CodeAnalysis.Emit.EmitOptions,Microsoft.CodeAnalysis.IMethodSymbol,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="member this.Emit : System.IO.Stream * System.IO.Stream * System.IO.Stream * System.IO.Stream * seq&lt;Microsoft.CodeAnalysis.ResourceDescription&gt; * Microsoft.CodeAnalysis.Emit.EmitOptions * Microsoft.CodeAnalysis.IMethodSymbol * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.Emit.EmitResult" Usage="compilation.Emit (peStream, pdbStream, xmlDocumentationStream, win32Resources, manifestResources, options, debugEntryPoint, cancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Emit::EmitResult ^ Emit(System::IO::Stream ^ peStream, System::IO::Stream ^ pdbStream, System::IO::Stream ^ xmlDocumentationStream, System::IO::Stream ^ win32Resources, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::ResourceDescription ^&gt; ^ manifestResources, Microsoft::CodeAnalysis::Emit::EmitOptions ^ options, Microsoft::CodeAnalysis::IMethodSymbol ^ debugEntryPoint, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Emit.EmitResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peStream" Type="System.IO.Stream" />
        <Parameter Name="pdbStream" Type="System.IO.Stream" />
        <Parameter Name="xmlDocumentationStream" Type="System.IO.Stream" />
        <Parameter Name="win32Resources" Type="System.IO.Stream" />
        <Parameter Name="manifestResources" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ResourceDescription&gt;" />
        <Parameter Name="options" Type="Microsoft.CodeAnalysis.Emit.EmitOptions" />
        <Parameter Name="debugEntryPoint" Type="Microsoft.CodeAnalysis.IMethodSymbol" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="peStream">To be added.</param>
        <param name="pdbStream">To be added.</param>
        <param name="xmlDocumentationStream">To be added.</param>
        <param name="win32Resources">To be added.</param>
        <param name="manifestResources">To be added.</param>
        <param name="options">To be added.</param>
        <param name="debugEntryPoint">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Emit.EmitResult Emit (System.IO.Stream peStream, System.IO.Stream pdbStream, System.IO.Stream xmlDocumentationStream, System.IO.Stream win32Resources, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ResourceDescription&gt; manifestResources, Microsoft.CodeAnalysis.Emit.EmitOptions options, Microsoft.CodeAnalysis.IMethodSymbol debugEntryPoint, System.IO.Stream sourceLinkStream, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.EmbeddedText&gt; embeddedTexts, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Emit.EmitResult Emit(class System.IO.Stream peStream, class System.IO.Stream pdbStream, class System.IO.Stream xmlDocumentationStream, class System.IO.Stream win32Resources, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.ResourceDescription&gt; manifestResources, class Microsoft.CodeAnalysis.Emit.EmitOptions options, class Microsoft.CodeAnalysis.IMethodSymbol debugEntryPoint, class System.IO.Stream sourceLinkStream, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.EmbeddedText&gt; embeddedTexts, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.Emit(System.IO.Stream,System.IO.Stream,System.IO.Stream,System.IO.Stream,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},Microsoft.CodeAnalysis.Emit.EmitOptions,Microsoft.CodeAnalysis.IMethodSymbol,System.IO.Stream,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.EmbeddedText},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="member this.Emit : System.IO.Stream * System.IO.Stream * System.IO.Stream * System.IO.Stream * seq&lt;Microsoft.CodeAnalysis.ResourceDescription&gt; * Microsoft.CodeAnalysis.Emit.EmitOptions * Microsoft.CodeAnalysis.IMethodSymbol * System.IO.Stream * seq&lt;Microsoft.CodeAnalysis.EmbeddedText&gt; * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.Emit.EmitResult" Usage="compilation.Emit (peStream, pdbStream, xmlDocumentationStream, win32Resources, manifestResources, options, debugEntryPoint, sourceLinkStream, embeddedTexts, cancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Emit::EmitResult ^ Emit(System::IO::Stream ^ peStream, System::IO::Stream ^ pdbStream, System::IO::Stream ^ xmlDocumentationStream, System::IO::Stream ^ win32Resources, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::ResourceDescription ^&gt; ^ manifestResources, Microsoft::CodeAnalysis::Emit::EmitOptions ^ options, Microsoft::CodeAnalysis::IMethodSymbol ^ debugEntryPoint, System::IO::Stream ^ sourceLinkStream, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::EmbeddedText ^&gt; ^ embeddedTexts, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Emit.EmitResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peStream" Type="System.IO.Stream" />
        <Parameter Name="pdbStream" Type="System.IO.Stream" />
        <Parameter Name="xmlDocumentationStream" Type="System.IO.Stream" />
        <Parameter Name="win32Resources" Type="System.IO.Stream" />
        <Parameter Name="manifestResources" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ResourceDescription&gt;" />
        <Parameter Name="options" Type="Microsoft.CodeAnalysis.Emit.EmitOptions" />
        <Parameter Name="debugEntryPoint" Type="Microsoft.CodeAnalysis.IMethodSymbol" />
        <Parameter Name="sourceLinkStream" Type="System.IO.Stream" />
        <Parameter Name="embeddedTexts" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.EmbeddedText&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="peStream">To be added.</param>
        <param name="pdbStream">To be added.</param>
        <param name="xmlDocumentationStream">To be added.</param>
        <param name="win32Resources">To be added.</param>
        <param name="manifestResources">To be added.</param>
        <param name="options">To be added.</param>
        <param name="debugEntryPoint">To be added.</param>
        <param name="sourceLinkStream">To be added.</param>
        <param name="embeddedTexts">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Emit.EmitResult Emit (System.IO.Stream peStream, System.IO.Stream pdbStream = null, System.IO.Stream xmlDocumentationStream = null, System.IO.Stream win32Resources = null, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ResourceDescription&gt; manifestResources = null, Microsoft.CodeAnalysis.Emit.EmitOptions options = null, Microsoft.CodeAnalysis.IMethodSymbol debugEntryPoint = null, System.IO.Stream sourceLinkStream = null, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.EmbeddedText&gt; embeddedTexts = null, System.IO.Stream metadataPEStream = null, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Emit.EmitResult Emit(class System.IO.Stream peStream, class System.IO.Stream pdbStream, class System.IO.Stream xmlDocumentationStream, class System.IO.Stream win32Resources, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.ResourceDescription&gt; manifestResources, class Microsoft.CodeAnalysis.Emit.EmitOptions options, class Microsoft.CodeAnalysis.IMethodSymbol debugEntryPoint, class System.IO.Stream sourceLinkStream, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.EmbeddedText&gt; embeddedTexts, class System.IO.Stream metadataPEStream, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.Emit(System.IO.Stream,System.IO.Stream,System.IO.Stream,System.IO.Stream,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},Microsoft.CodeAnalysis.Emit.EmitOptions,Microsoft.CodeAnalysis.IMethodSymbol,System.IO.Stream,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.EmbeddedText},System.IO.Stream,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="member this.Emit : System.IO.Stream * System.IO.Stream * System.IO.Stream * System.IO.Stream * seq&lt;Microsoft.CodeAnalysis.ResourceDescription&gt; * Microsoft.CodeAnalysis.Emit.EmitOptions * Microsoft.CodeAnalysis.IMethodSymbol * System.IO.Stream * seq&lt;Microsoft.CodeAnalysis.EmbeddedText&gt; * System.IO.Stream * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.Emit.EmitResult" Usage="compilation.Emit (peStream, pdbStream, xmlDocumentationStream, win32Resources, manifestResources, options, debugEntryPoint, sourceLinkStream, embeddedTexts, metadataPEStream, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Emit.EmitResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peStream" Type="System.IO.Stream" />
        <Parameter Name="pdbStream" Type="System.IO.Stream" />
        <Parameter Name="xmlDocumentationStream" Type="System.IO.Stream" />
        <Parameter Name="win32Resources" Type="System.IO.Stream" />
        <Parameter Name="manifestResources" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ResourceDescription&gt;" />
        <Parameter Name="options" Type="Microsoft.CodeAnalysis.Emit.EmitOptions" />
        <Parameter Name="debugEntryPoint" Type="Microsoft.CodeAnalysis.IMethodSymbol" />
        <Parameter Name="sourceLinkStream" Type="System.IO.Stream" />
        <Parameter Name="embeddedTexts" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.EmbeddedText&gt;" />
        <Parameter Name="metadataPEStream" Type="System.IO.Stream" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="peStream">Stream to which the compilation will be written.</param>
        <param name="pdbStream">Stream to which the compilation's debug info will be written.  Null to forego PDB generation.</param>
        <param name="xmlDocumentationStream">Stream to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
        <param name="win32Resources">Stream from which the compilation's Win32 resources will be read (in RES format).
             Null to indicate that there are none. The RES format begins with a null resource entry.</param>
        <param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
        <param name="options">Emit options.</param>
        <param name="debugEntryPoint">
             Debug entry-point of the assembly. The method token is stored in the generated PDB stream.
            
             When a program launches with a debugger attached the debugger places the first breakpoint to the start of the debug entry-point method.
             The CLR starts executing the static Main method of <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.MainTypeName" /> type. When the first breakpoint is hit
             the debugger steps thru the code statement by statement until user code is reached, skipping methods marked by <see cref="T:System.Diagnostics.DebuggerHiddenAttribute" />,
             and taking other debugging attributes into consideration.
            
             By default both entry points in an executable program (<see cref="F:Microsoft.CodeAnalysis.OutputKind.ConsoleApplication" />, <see cref="F:Microsoft.CodeAnalysis.OutputKind.WindowsApplication" />, <see cref="F:Microsoft.CodeAnalysis.OutputKind.WindowsRuntimeApplication" />)
             are the same method (Main). A non-executable program has no entry point. Runtimes that implement a custom loader may specify debug entry-point
             to force the debugger to skip over complex custom loader logic executing at the beginning of the .exe and thus improve debugging experience.
            
             Unlike ordinary entry-point which is limited to a non-generic static method of specific signature, there are no restrictions on the <paramref name="debugEntryPoint" />
             method other than having a method body (extern, interface, or abstract methods are not allowed).
             </param>
        <param name="sourceLinkStream">
             Stream containing information linking the compilation to a source control.
             </param>
        <param name="embeddedTexts">
             Texts to embed in the PDB.
             Only supported when emitting Portable PDBs.
             </param>
        <param name="metadataPEStream">Stream to which the metadata-only output will be written.</param>
        <param name="cancellationToken">To cancel the emit process.</param>
        <summary>
             Emit the IL for the compiled source code into the specified stream.
             </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmitDifference">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Emit.EmitDifferenceResult EmitDifference (Microsoft.CodeAnalysis.Emit.EmitBaseline baseline, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Emit.SemanticEdit&gt; edits, System.IO.Stream metadataStream, System.IO.Stream ilStream, System.IO.Stream pdbStream, System.Collections.Generic.ICollection&lt;System.Reflection.Metadata.MethodDefinitionHandle&gt; updatedMethods, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Emit.EmitDifferenceResult EmitDifference(class Microsoft.CodeAnalysis.Emit.EmitBaseline baseline, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.Emit.SemanticEdit&gt; edits, class System.IO.Stream metadataStream, class System.IO.Stream ilStream, class System.IO.Stream pdbStream, class System.Collections.Generic.ICollection`1&lt;valuetype System.Reflection.Metadata.MethodDefinitionHandle&gt; updatedMethods, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.EmitDifference(Microsoft.CodeAnalysis.Emit.EmitBaseline,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Emit.SemanticEdit},System.IO.Stream,System.IO.Stream,System.IO.Stream,System.Collections.Generic.ICollection{System.Reflection.Metadata.MethodDefinitionHandle},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="member this.EmitDifference : Microsoft.CodeAnalysis.Emit.EmitBaseline * seq&lt;Microsoft.CodeAnalysis.Emit.SemanticEdit&gt; * System.IO.Stream * System.IO.Stream * System.IO.Stream * System.Collections.Generic.ICollection&lt;System.Reflection.Metadata.MethodDefinitionHandle&gt; * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.Emit.EmitDifferenceResult" Usage="compilation.EmitDifference (baseline, edits, metadataStream, ilStream, pdbStream, updatedMethods, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Emit.EmitDifferenceResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseline" Type="Microsoft.CodeAnalysis.Emit.EmitBaseline" />
        <Parameter Name="edits" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Emit.SemanticEdit&gt;" />
        <Parameter Name="metadataStream" Type="System.IO.Stream" />
        <Parameter Name="ilStream" Type="System.IO.Stream" />
        <Parameter Name="pdbStream" Type="System.IO.Stream" />
        <Parameter Name="updatedMethods" Type="System.Collections.Generic.ICollection&lt;System.Reflection.Metadata.MethodDefinitionHandle&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="baseline">To be added.</param>
        <param name="edits">To be added.</param>
        <param name="metadataStream">To be added.</param>
        <param name="ilStream">To be added.</param>
        <param name="pdbStream">To be added.</param>
        <param name="updatedMethods">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Emit the differences between the compilation and the previous generation
            for Edit and Continue. The differences are expressed as added and changed
            symbols, and are emitted as metadata, IL, and PDB deltas. A representation
            of the current compilation is returned as an EmitBaseline for use in a
            subsequent Edit and Continue.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmitDifference">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Emit.EmitDifferenceResult EmitDifference (Microsoft.CodeAnalysis.Emit.EmitBaseline baseline, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Emit.SemanticEdit&gt; edits, Func&lt;Microsoft.CodeAnalysis.ISymbol,bool&gt; isAddedSymbol, System.IO.Stream metadataStream, System.IO.Stream ilStream, System.IO.Stream pdbStream, System.Collections.Generic.ICollection&lt;System.Reflection.Metadata.MethodDefinitionHandle&gt; updatedMethods, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Emit.EmitDifferenceResult EmitDifference(class Microsoft.CodeAnalysis.Emit.EmitBaseline baseline, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.Emit.SemanticEdit&gt; edits, class System.Func`2&lt;class Microsoft.CodeAnalysis.ISymbol, bool&gt; isAddedSymbol, class System.IO.Stream metadataStream, class System.IO.Stream ilStream, class System.IO.Stream pdbStream, class System.Collections.Generic.ICollection`1&lt;valuetype System.Reflection.Metadata.MethodDefinitionHandle&gt; updatedMethods, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.EmitDifference(Microsoft.CodeAnalysis.Emit.EmitBaseline,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Emit.SemanticEdit},System.Func{Microsoft.CodeAnalysis.ISymbol,System.Boolean},System.IO.Stream,System.IO.Stream,System.IO.Stream,System.Collections.Generic.ICollection{System.Reflection.Metadata.MethodDefinitionHandle},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="member this.EmitDifference : Microsoft.CodeAnalysis.Emit.EmitBaseline * seq&lt;Microsoft.CodeAnalysis.Emit.SemanticEdit&gt; * Func&lt;Microsoft.CodeAnalysis.ISymbol, bool&gt; * System.IO.Stream * System.IO.Stream * System.IO.Stream * System.Collections.Generic.ICollection&lt;System.Reflection.Metadata.MethodDefinitionHandle&gt; * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.Emit.EmitDifferenceResult" Usage="compilation.EmitDifference (baseline, edits, isAddedSymbol, metadataStream, ilStream, pdbStream, updatedMethods, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Emit.EmitDifferenceResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseline" Type="Microsoft.CodeAnalysis.Emit.EmitBaseline" />
        <Parameter Name="edits" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Emit.SemanticEdit&gt;" />
        <Parameter Name="isAddedSymbol" Type="System.Func&lt;Microsoft.CodeAnalysis.ISymbol,System.Boolean&gt;" />
        <Parameter Name="metadataStream" Type="System.IO.Stream" />
        <Parameter Name="ilStream" Type="System.IO.Stream" />
        <Parameter Name="pdbStream" Type="System.IO.Stream" />
        <Parameter Name="updatedMethods" Type="System.Collections.Generic.ICollection&lt;System.Reflection.Metadata.MethodDefinitionHandle&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="baseline">To be added.</param>
        <param name="edits">To be added.</param>
        <param name="isAddedSymbol">To be added.</param>
        <param name="metadataStream">To be added.</param>
        <param name="ilStream">To be added.</param>
        <param name="pdbStream">To be added.</param>
        <param name="updatedMethods">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Emit the differences between the compilation and the previous generation
            for Edit and Continue. The differences are expressed as added and changed
            symbols, and are emitted as metadata, IL, and PDB deltas. A representation
            of the current compilation is returned as an EmitBaseline for use in a
            subsequent Edit and Continue.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExternalReferences">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.MetadataReference&gt; ExternalReferences { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.MetadataReference&gt; ExternalReferences" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.ExternalReferences" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExternalReferences As ImmutableArray(Of MetadataReference)" />
      <MemberSignature Language="F#" Value="member this.ExternalReferences : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.MetadataReference&gt;" Usage="Microsoft.CodeAnalysis.Compilation.ExternalReferences" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ExternalReferences { System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.MetadataReference&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Metadata references passed to the compilation constructor.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyOrModuleSymbol">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.ISymbol GetAssemblyOrModuleSymbol (Microsoft.CodeAnalysis.MetadataReference reference);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.ISymbol GetAssemblyOrModuleSymbol(class Microsoft.CodeAnalysis.MetadataReference reference) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblyOrModuleSymbol (reference As MetadataReference) As ISymbol" />
      <MemberSignature Language="F#" Value="member this.GetAssemblyOrModuleSymbol : Microsoft.CodeAnalysis.MetadataReference -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="compilation.GetAssemblyOrModuleSymbol reference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::ISymbol ^ GetAssemblyOrModuleSymbol(Microsoft::CodeAnalysis::MetadataReference ^ reference);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reference" Type="Microsoft.CodeAnalysis.MetadataReference" />
      </Parameters>
      <Docs>
        <param name="reference">The target reference.</param>
        <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol" /> or <see cref="T:Microsoft.CodeAnalysis.IModuleSymbol" /> for a metadata reference used to create this
            compilation.
            </summary>
        <returns>
            Assembly or module symbol corresponding to the given reference or null if there is none.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompilationNamespace">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamespaceSymbol GetCompilationNamespace (Microsoft.CodeAnalysis.INamespaceSymbol namespaceSymbol);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.INamespaceSymbol GetCompilationNamespace(class Microsoft.CodeAnalysis.INamespaceSymbol namespaceSymbol) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompilationNamespace (namespaceSymbol As INamespaceSymbol) As INamespaceSymbol" />
      <MemberSignature Language="F#" Value="member this.GetCompilationNamespace : Microsoft.CodeAnalysis.INamespaceSymbol -&gt; Microsoft.CodeAnalysis.INamespaceSymbol" Usage="compilation.GetCompilationNamespace namespaceSymbol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::INamespaceSymbol ^ GetCompilationNamespace(Microsoft::CodeAnalysis::INamespaceSymbol ^ namespaceSymbol);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceSymbol" Type="Microsoft.CodeAnalysis.INamespaceSymbol" />
      </Parameters>
      <Docs>
        <param name="namespaceSymbol">To be added.</param>
        <summary>
            Gets the corresponding compilation namespace for the specified module or assembly namespace.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclarationDiagnostics">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetDeclarationDiagnostics (System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetDeclarationDiagnostics(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetDeclarationDiagnostics(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclarationDiagnostics : System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="compilation.GetDeclarationDiagnostics cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the diagnostics produced during symbol declaration.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDiagnostics">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics (System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetDiagnostics(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetDiagnostics : System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="compilation.GetDiagnostics cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets all the diagnostics for the compilation, including syntax, declaration, and
            binding. Does not include any diagnostics that might be produced during emit, see
            <see cref="T:Microsoft.CodeAnalysis.Emit.EmitResult" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryPoint">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.IMethodSymbol GetEntryPoint (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.IMethodSymbol GetEntryPoint(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetEntryPoint(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="member this.GetEntryPoint : System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IMethodSymbol" Usage="compilation.GetEntryPoint cancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::IMethodSymbol ^ GetEntryPoint(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Returns the Main method that will serves as the entry point of the assembly, if it is
            executable (and not a script).
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadataReference">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.MetadataReference GetMetadataReference (Microsoft.CodeAnalysis.IAssemblySymbol assemblySymbol);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.MetadataReference GetMetadataReference(class Microsoft.CodeAnalysis.IAssemblySymbol assemblySymbol) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetMetadataReference(Microsoft.CodeAnalysis.IAssemblySymbol)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadataReference (assemblySymbol As IAssemblySymbol) As MetadataReference" />
      <MemberSignature Language="F#" Value="member this.GetMetadataReference : Microsoft.CodeAnalysis.IAssemblySymbol -&gt; Microsoft.CodeAnalysis.MetadataReference" Usage="compilation.GetMetadataReference assemblySymbol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::MetadataReference ^ GetMetadataReference(Microsoft::CodeAnalysis::IAssemblySymbol ^ assemblySymbol);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.MetadataReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblySymbol" Type="Microsoft.CodeAnalysis.IAssemblySymbol" />
      </Parameters>
      <Docs>
        <param name="assemblySymbol">The target symbol.</param>
        <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.MetadataReference" /> that corresponds to the assembly symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBodyDiagnostics">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetMethodBodyDiagnostics (System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetMethodBodyDiagnostics(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetMethodBodyDiagnostics(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetMethodBodyDiagnostics : System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="compilation.GetMethodBodyDiagnostics cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the diagnostics produced during the analysis of method bodies and field initializers.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParseDiagnostics">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetParseDiagnostics (System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetParseDiagnostics(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetParseDiagnostics(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetParseDiagnostics : System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="compilation.GetParseDiagnostics cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the diagnostics produced during the parsing stage.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRequiredLanguageVersion">
      <MemberSignature Language="C#" Value="public static string GetRequiredLanguageVersion (Microsoft.CodeAnalysis.Diagnostic diagnostic);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRequiredLanguageVersion(class Microsoft.CodeAnalysis.Diagnostic diagnostic) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetRequiredLanguageVersion(Microsoft.CodeAnalysis.Diagnostic)" />
      <MemberSignature Language="F#" Value="static member GetRequiredLanguageVersion : Microsoft.CodeAnalysis.Diagnostic -&gt; string" Usage="Microsoft.CodeAnalysis.Compilation.GetRequiredLanguageVersion diagnostic" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRequiredLanguageVersion(Microsoft::CodeAnalysis::Diagnostic ^ diagnostic);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="diagnostic" Type="Microsoft.CodeAnalysis.Diagnostic" />
      </Parameters>
      <Docs>
        <param name="diagnostic">To be added.</param>
        <summary>
            Returns the required language version found in a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" />, if any is found.
            Returns null if none is found.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSemanticModel">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SemanticModel GetSemanticModel (Microsoft.CodeAnalysis.SyntaxTree syntaxTree, bool ignoreAccessibility = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.SemanticModel GetSemanticModel(class Microsoft.CodeAnalysis.SyntaxTree syntaxTree, bool ignoreAccessibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)" />
      <MemberSignature Language="F#" Value="member this.GetSemanticModel : Microsoft.CodeAnalysis.SyntaxTree * bool -&gt; Microsoft.CodeAnalysis.SemanticModel" Usage="compilation.GetSemanticModel (syntaxTree, ignoreAccessibility)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SemanticModel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="syntaxTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
        <Parameter Name="ignoreAccessibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="syntaxTree">The specified syntax tree.</param>
        <param name="ignoreAccessibility">
            True if the SemanticModel should ignore accessibility rules when answering semantic questions.
            </param>
        <summary>
            Gets a new <see cref="T:Microsoft.CodeAnalysis.SemanticModel" /> for the specified syntax tree.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpecialType">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol GetSpecialType (Microsoft.CodeAnalysis.SpecialType specialType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.INamedTypeSymbol GetSpecialType(valuetype Microsoft.CodeAnalysis.SpecialType specialType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)" />
      <MemberSignature Language="F#" Value="member this.GetSpecialType : Microsoft.CodeAnalysis.SpecialType -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="compilation.GetSpecialType specialType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::INamedTypeSymbol ^ GetSpecialType(Microsoft::CodeAnalysis::SpecialType specialType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="specialType" Type="Microsoft.CodeAnalysis.SpecialType" />
      </Parameters>
      <Docs>
        <param name="specialType">To be added.</param>
        <summary>
            Get the symbol for the predefined type from the Cor Library referenced by this
            compilation.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolsWithName">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetSymbolsWithName (Func&lt;string,bool&gt; predicate, Microsoft.CodeAnalysis.SymbolFilter filter = Microsoft.CodeAnalysis.SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetSymbolsWithName(class System.Func`2&lt;string, bool&gt; predicate, valuetype Microsoft.CodeAnalysis.SymbolFilter filter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetSymbolsWithName : Func&lt;string, bool&gt; * Microsoft.CodeAnalysis.SymbolFilter * System.Threading.CancellationToken -&gt; seq&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="compilation.GetSymbolsWithName (predicate, filter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="predicate" Type="System.Func&lt;System.String,System.Boolean&gt;" />
        <Parameter Name="filter" Type="Microsoft.CodeAnalysis.SymbolFilter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="predicate">To be added.</param>
        <param name="filter">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Return source declaration symbols whose name meets given predicate.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolsWithName">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetSymbolsWithName (string name, Microsoft.CodeAnalysis.SymbolFilter filter = Microsoft.CodeAnalysis.SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetSymbolsWithName(string name, valuetype Microsoft.CodeAnalysis.SymbolFilter filter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetSymbolsWithName(System.String,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetSymbolsWithName : string * Microsoft.CodeAnalysis.SymbolFilter * System.Threading.CancellationToken -&gt; seq&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="compilation.GetSymbolsWithName (name, filter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="filter" Type="Microsoft.CodeAnalysis.SymbolFilter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="filter">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Return source declaration symbols whose name matches the provided name.  This may be
            faster than <see cref="M:Microsoft.CodeAnalysis.Compilation.GetSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)" /> when predicate is just a simple string check.  <paramref name="name" /> is case sensitive or not depending on the target language.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeByMetadataName">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol GetTypeByMetadataName (string fullyQualifiedMetadataName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetTypeByMetadataName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeByMetadataName (fullyQualifiedMetadataName As String) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.GetTypeByMetadataName : string -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="compilation.GetTypeByMetadataName fullyQualifiedMetadataName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::INamedTypeSymbol ^ GetTypeByMetadataName(System::String ^ fullyQualifiedMetadataName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fullyQualifiedMetadataName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fullyQualifiedMetadataName">To be added.</param>
        <summary>
            Gets the type within the compilation's assembly and all referenced assemblies (other than
            those that can only be referenced via an extern alias) using its canonical CLR metadata name.
            </summary>
        <returns>Null if the type can't be found.</returns>
        <remarks>
            Since VB does not have the concept of extern aliases, it considers all referenced assemblies.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUnreferencedAssemblyIdentities">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.AssemblyIdentity&gt; GetUnreferencedAssemblyIdentities (Microsoft.CodeAnalysis.Diagnostic diagnostic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.AssemblyIdentity&gt; GetUnreferencedAssemblyIdentities(class Microsoft.CodeAnalysis.Diagnostic diagnostic) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.GetUnreferencedAssemblyIdentities(Microsoft.CodeAnalysis.Diagnostic)" />
      <MemberSignature Language="F#" Value="member this.GetUnreferencedAssemblyIdentities : Microsoft.CodeAnalysis.Diagnostic -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.AssemblyIdentity&gt;" Usage="compilation.GetUnreferencedAssemblyIdentities diagnostic" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::AssemblyIdentity ^&gt; GetUnreferencedAssemblyIdentities(Microsoft::CodeAnalysis::Diagnostic ^ diagnostic);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.AssemblyIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="diagnostic" Type="Microsoft.CodeAnalysis.Diagnostic" />
      </Parameters>
      <Docs>
        <param name="diagnostic">To be added.</param>
        <summary>
            Given a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> reporting unreferenced <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity" />s, returns
            the actual <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity" /> instances that were not referenced.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalNamespace">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamespaceSymbol GlobalNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamespaceSymbol GlobalNamespace" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.GlobalNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalNamespace As INamespaceSymbol" />
      <MemberSignature Language="F#" Value="member this.GlobalNamespace : Microsoft.CodeAnalysis.INamespaceSymbol" Usage="Microsoft.CodeAnalysis.Compilation.GlobalNamespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::INamespaceSymbol ^ GlobalNamespace { Microsoft::CodeAnalysis::INamespaceSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The root namespace that contains all namespaces and types defined in source code or in
            referenced metadata, merged into a single namespace hierarchy.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasImplicitConversion">
      <MemberSignature Language="C#" Value="public bool HasImplicitConversion (Microsoft.CodeAnalysis.ITypeSymbol fromType, Microsoft.CodeAnalysis.ITypeSymbol toType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasImplicitConversion(class Microsoft.CodeAnalysis.ITypeSymbol fromType, class Microsoft.CodeAnalysis.ITypeSymbol toType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.HasImplicitConversion(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasImplicitConversion (fromType As ITypeSymbol, toType As ITypeSymbol) As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasImplicitConversion : Microsoft.CodeAnalysis.ITypeSymbol * Microsoft.CodeAnalysis.ITypeSymbol -&gt; bool" Usage="compilation.HasImplicitConversion (fromType, toType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasImplicitConversion(Microsoft::CodeAnalysis::ITypeSymbol ^ fromType, Microsoft::CodeAnalysis::ITypeSymbol ^ toType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromType" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        <Parameter Name="toType" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
      </Parameters>
      <Docs>
        <param name="fromType">To be added.</param>
        <param name="toType">To be added.</param>
        <summary>
            Returns true if there is an implicit (C#) or widening (VB) conversion from
            <paramref name="fromType" /> to <paramref name="toType" />. Returns false if
            either <paramref name="fromType" /> or <paramref name="toType" /> is null, or
            if no such conversion exists.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCaseSensitive">
      <MemberSignature Language="C#" Value="public abstract bool IsCaseSensitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCaseSensitive" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.IsCaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsCaseSensitive As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsCaseSensitive : bool" Usage="Microsoft.CodeAnalysis.Compilation.IsCaseSensitive" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsCaseSensitive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns true if this is a case sensitive compilation, false otherwise.  Case sensitivity
            affects compilation features such as name lookup as well as choosing what names to emit
            when there are multiple different choices (for example between a virtual method and an
            override).
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSymbolAccessibleWithin">
      <MemberSignature Language="C#" Value="public bool IsSymbolAccessibleWithin (Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.ISymbol within, Microsoft.CodeAnalysis.ITypeSymbol throughType = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsSymbolAccessibleWithin(class Microsoft.CodeAnalysis.ISymbol symbol, class Microsoft.CodeAnalysis.ISymbol within, class Microsoft.CodeAnalysis.ITypeSymbol throughType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.IsSymbolAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSymbolAccessibleWithin (symbol As ISymbol, within As ISymbol, Optional throughType As ITypeSymbol = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsSymbolAccessibleWithin : Microsoft.CodeAnalysis.ISymbol * Microsoft.CodeAnalysis.ISymbol * Microsoft.CodeAnalysis.ITypeSymbol -&gt; bool" Usage="compilation.IsSymbolAccessibleWithin (symbol, within, throughType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" />
        <Parameter Name="within" Type="Microsoft.CodeAnalysis.ISymbol" />
        <Parameter Name="throughType" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
      </Parameters>
      <Docs>
        <param name="symbol">To be added.</param>
        <param name="within">To be added.</param>
        <param name="throughType">To be added.</param>
        <summary>
            Checks if <paramref name="symbol" /> is accessible from within <paramref name="within" />. An optional qualifier of type
            <paramref name="throughType" /> is used to resolve protected access for instance members. All symbols are
            required to be from this compilation or some assembly referenced (<see cref="P:Microsoft.CodeAnalysis.Compilation.References" />) by this
            compilation. <paramref name="within" /> is required to be an <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol" /> or <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Submissions can reference symbols from previous submissions and their referenced assemblies, even
            though those references are missing from <see cref="P:Microsoft.CodeAnalysis.Compilation.References" />.
            See https://github.com/dotnet/roslyn/issues/27356.
            This implementation works around that by permitting symbols from previous submissions as well.</para>
          <para>It is advised to avoid the use of this API within the compilers, as the compilers have additional
            requirements for access checking that are not satisfied by this implementation, including the
            avoidance of infinite recursion that could result from the use of the ISymbol APIs here, the detection
            of use-site diagnostics, and additional returned details (from the compiler's internal APIs) that are
            helpful for more precisely diagnosing reasons for accessibility failure.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public abstract string Language { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Language" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.Language" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Language As String" />
      <MemberSignature Language="F#" Value="member this.Language : string" Usage="Microsoft.CodeAnalysis.Compilation.Language" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Language { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the source language ("C#" or "Visual Basic").
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectType">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol ObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamedTypeSymbol ObjectType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.ObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ObjectType As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.ObjectType : Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.Compilation.ObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::INamedTypeSymbol ^ ObjectType { Microsoft::CodeAnalysis::INamedTypeSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The INamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of
            Error if there was no COR Library in this Compilation.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CompilationOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.CompilationOptions Options" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As CompilationOptions" />
      <MemberSignature Language="F#" Value="member this.Options : Microsoft.CodeAnalysis.CompilationOptions" Usage="Microsoft.CodeAnalysis.Compilation.Options" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::CompilationOptions ^ Options { Microsoft::CodeAnalysis::CompilationOptions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CompilationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the options the compilation was created with.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferencedAssemblyNames">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.AssemblyIdentity&gt; ReferencedAssemblyNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.AssemblyIdentity&gt; ReferencedAssemblyNames" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.ReferencedAssemblyNames" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReferencedAssemblyNames As IEnumerable(Of AssemblyIdentity)" />
      <MemberSignature Language="F#" Value="member this.ReferencedAssemblyNames : seq&lt;Microsoft.CodeAnalysis.AssemblyIdentity&gt;" Usage="Microsoft.CodeAnalysis.Compilation.ReferencedAssemblyNames" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::AssemblyIdentity ^&gt; ^ ReferencedAssemblyNames { System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::AssemblyIdentity ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.AssemblyIdentity&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Assembly identities of all assemblies directly referenced by this compilation.
            </summary>
        <value>To be added.</value>
        <remarks>
            Includes identities of references passed in the compilation constructor
            as well as those specified via directives in source code.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="References">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; References { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.MetadataReference&gt; References" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.References" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property References As IEnumerable(Of MetadataReference)" />
      <MemberSignature Language="F#" Value="member this.References : seq&lt;Microsoft.CodeAnalysis.MetadataReference&gt;" Usage="Microsoft.CodeAnalysis.Compilation.References" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ References { System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.CodeAnalysis.Compilation/&lt;get_References&gt;d__91))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            All metadata references -- references passed to the compilation
            constructor as well as references specified via #r directives.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAllReferences">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation RemoveAllReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation RemoveAllReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.RemoveAllReferences" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAllReferences () As Compilation" />
      <MemberSignature Language="F#" Value="member this.RemoveAllReferences : unit -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.RemoveAllReferences " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ RemoveAllReferences();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Creates a new compilation without any metadata references.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAllSyntaxTrees">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation RemoveAllSyntaxTrees ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation RemoveAllSyntaxTrees() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.RemoveAllSyntaxTrees" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAllSyntaxTrees () As Compilation" />
      <MemberSignature Language="F#" Value="member this.RemoveAllSyntaxTrees : unit -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.RemoveAllSyntaxTrees " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ RemoveAllSyntaxTrees();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Creates a new compilation without any syntax trees. Preserves metadata info for use with
            trees added later.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveReferences">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation RemoveReferences (params Microsoft.CodeAnalysis.MetadataReference[] references);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation RemoveReferences(class Microsoft.CodeAnalysis.MetadataReference[] references) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.RemoveReferences(Microsoft.CodeAnalysis.MetadataReference[])" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveReferences (ParamArray references As MetadataReference()) As Compilation" />
      <MemberSignature Language="F#" Value="member this.RemoveReferences : Microsoft.CodeAnalysis.MetadataReference[] -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.RemoveReferences references" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ RemoveReferences(... cli::array &lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ references);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="references" Type="Microsoft.CodeAnalysis.MetadataReference[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="references">The new references.</param>
        <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveReferences">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation RemoveReferences (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; references);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation RemoveReferences(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.MetadataReference&gt; references) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.RemoveReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveReferences (references As IEnumerable(Of MetadataReference)) As Compilation" />
      <MemberSignature Language="F#" Value="member this.RemoveReferences : seq&lt;Microsoft.CodeAnalysis.MetadataReference&gt; -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.RemoveReferences references" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ RemoveReferences(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ references);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="references" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt;" />
      </Parameters>
      <Docs>
        <param name="references">The new references.</param>
        <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveSyntaxTrees">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation RemoveSyntaxTrees (params Microsoft.CodeAnalysis.SyntaxTree[] trees);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation RemoveSyntaxTrees(class Microsoft.CodeAnalysis.SyntaxTree[] trees) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.RemoveSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveSyntaxTrees (ParamArray trees As SyntaxTree()) As Compilation" />
      <MemberSignature Language="F#" Value="member this.RemoveSyntaxTrees : Microsoft.CodeAnalysis.SyntaxTree[] -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.RemoveSyntaxTrees trees" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ RemoveSyntaxTrees(... cli::array &lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ trees);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trees" Type="Microsoft.CodeAnalysis.SyntaxTree[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trees">The new syntax trees.</param>
        <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveSyntaxTrees">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation RemoveSyntaxTrees (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; trees);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation RemoveSyntaxTrees(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxTree&gt; trees) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.RemoveSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveSyntaxTrees (trees As IEnumerable(Of SyntaxTree)) As Compilation" />
      <MemberSignature Language="F#" Value="member this.RemoveSyntaxTrees : seq&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.RemoveSyntaxTrees trees" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ RemoveSyntaxTrees(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ trees);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trees" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;" />
      </Parameters>
      <Docs>
        <param name="trees">The new syntax trees.</param>
        <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceReference">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation ReplaceReference (Microsoft.CodeAnalysis.MetadataReference oldReference, Microsoft.CodeAnalysis.MetadataReference newReference);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation ReplaceReference(class Microsoft.CodeAnalysis.MetadataReference oldReference, class Microsoft.CodeAnalysis.MetadataReference newReference) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.ReplaceReference(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReplaceReference (oldReference As MetadataReference, newReference As MetadataReference) As Compilation" />
      <MemberSignature Language="F#" Value="member this.ReplaceReference : Microsoft.CodeAnalysis.MetadataReference * Microsoft.CodeAnalysis.MetadataReference -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.ReplaceReference (oldReference, newReference)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ ReplaceReference(Microsoft::CodeAnalysis::MetadataReference ^ oldReference, Microsoft::CodeAnalysis::MetadataReference ^ newReference);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldReference" Type="Microsoft.CodeAnalysis.MetadataReference" />
        <Parameter Name="newReference" Type="Microsoft.CodeAnalysis.MetadataReference" />
      </Parameters>
      <Docs>
        <param name="oldReference">The old reference.</param>
        <param name="newReference">The new reference.</param>
        <summary>
            Creates a new compilation with an old metadata reference replaced with a new metadata
            reference.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceSyntaxTree">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation ReplaceSyntaxTree (Microsoft.CodeAnalysis.SyntaxTree oldTree, Microsoft.CodeAnalysis.SyntaxTree newTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation ReplaceSyntaxTree(class Microsoft.CodeAnalysis.SyntaxTree oldTree, class Microsoft.CodeAnalysis.SyntaxTree newTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.ReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReplaceSyntaxTree (oldTree As SyntaxTree, newTree As SyntaxTree) As Compilation" />
      <MemberSignature Language="F#" Value="member this.ReplaceSyntaxTree : Microsoft.CodeAnalysis.SyntaxTree * Microsoft.CodeAnalysis.SyntaxTree -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.ReplaceSyntaxTree (oldTree, newTree)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ ReplaceSyntaxTree(Microsoft::CodeAnalysis::SyntaxTree ^ oldTree, Microsoft::CodeAnalysis::SyntaxTree ^ newTree);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
        <Parameter Name="newTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
      </Parameters>
      <Docs>
        <param name="oldTree">The old tree.</param>
        <param name="newTree">The new tree.</param>
        <summary>
            Creates a new compilation with an old syntax tree replaced with a new syntax tree.
            Reuses metadata from old compilation object.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptClass">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol ScriptClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamedTypeSymbol ScriptClass" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.ScriptClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScriptClass As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.ScriptClass : Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.Compilation.ScriptClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::INamedTypeSymbol ^ ScriptClass { Microsoft::CodeAnalysis::INamedTypeSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            A symbol representing the implicit Script class. This is null if the class is not
            defined in the compilation.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptCompilationInfo">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.ScriptCompilationInfo ScriptCompilationInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.ScriptCompilationInfo ScriptCompilationInfo" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.ScriptCompilationInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScriptCompilationInfo As ScriptCompilationInfo" />
      <MemberSignature Language="F#" Value="member this.ScriptCompilationInfo : Microsoft.CodeAnalysis.ScriptCompilationInfo" Usage="Microsoft.CodeAnalysis.Compilation.ScriptCompilationInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::ScriptCompilationInfo ^ ScriptCompilationInfo { Microsoft::CodeAnalysis::ScriptCompilationInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ScriptCompilationInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceModule">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.IModuleSymbol SourceModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.IModuleSymbol SourceModule" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.SourceModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceModule As IModuleSymbol" />
      <MemberSignature Language="F#" Value="member this.SourceModule : Microsoft.CodeAnalysis.IModuleSymbol" Usage="Microsoft.CodeAnalysis.Compilation.SourceModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::IModuleSymbol ^ SourceModule { Microsoft::CodeAnalysis::IModuleSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IModuleSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.IModuleSymbol" /> for the module being created by compiling all of
            the source code.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SyntaxTreeCommonFeatures">
      <MemberSignature Language="C#" Value="protected static System.Collections.Generic.IReadOnlyDictionary&lt;string,string&gt; SyntaxTreeCommonFeatures (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; trees);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Collections.Generic.IReadOnlyDictionary`2&lt;string, string&gt; SyntaxTreeCommonFeatures(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxTree&gt; trees) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.SyntaxTreeCommonFeatures(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function SyntaxTreeCommonFeatures (trees As IEnumerable(Of SyntaxTree)) As IReadOnlyDictionary(Of String, String)" />
      <MemberSignature Language="F#" Value="static member SyntaxTreeCommonFeatures : seq&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;string, string&gt;" Usage="Microsoft.CodeAnalysis.Compilation.SyntaxTreeCommonFeatures trees" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Collections::Generic::IReadOnlyDictionary&lt;System::String ^, System::String ^&gt; ^ SyntaxTreeCommonFeatures(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ trees);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trees" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;" />
      </Parameters>
      <Docs>
        <param name="trees">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SyntaxTrees">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; SyntaxTrees { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxTree&gt; SyntaxTrees" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.Compilation.SyntaxTrees" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyntaxTrees As IEnumerable(Of SyntaxTree)" />
      <MemberSignature Language="F#" Value="member this.SyntaxTrees : seq&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;" Usage="Microsoft.CodeAnalysis.Compilation.SyntaxTrees" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ SyntaxTrees { System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the syntax trees (parsed from source code) that this compilation was created with.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToMetadataReference">
      <MemberSignature Language="C#" Value="public abstract Microsoft.CodeAnalysis.CompilationReference ToMetadataReference (System.Collections.Immutable.ImmutableArray&lt;string&gt; aliases = null, bool embedInteropTypes = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.CodeAnalysis.CompilationReference ToMetadataReference(valuetype System.Collections.Immutable.ImmutableArray`1&lt;string&gt; aliases, bool embedInteropTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.ToMetadataReference(System.Collections.Immutable.ImmutableArray{System.String},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ToMetadataReference (Optional aliases As ImmutableArray(Of String) = null, Optional embedInteropTypes As Boolean = false) As CompilationReference" />
      <MemberSignature Language="F#" Value="abstract member ToMetadataReference : System.Collections.Immutable.ImmutableArray&lt;string&gt; * bool -&gt; Microsoft.CodeAnalysis.CompilationReference" Usage="compilation.ToMetadataReference (aliases, embedInteropTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CompilationReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aliases" Type="System.Collections.Immutable.ImmutableArray&lt;System.String&gt;" />
        <Parameter Name="embedInteropTypes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="aliases">
            Optional aliases that can be used to refer to the compilation root namespace via extern alias directive.
            </param>
        <param name="embedInteropTypes">
            Embed the COM types from the reference so that the compiled
            application no longer requires a primary interop assembly (PIA).
            </param>
        <summary>
            Creates a metadata reference for this compilation.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithAssemblyName">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation WithAssemblyName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation WithAssemblyName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.WithAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WithAssemblyName (assemblyName As String) As Compilation" />
      <MemberSignature Language="F#" Value="member this.WithAssemblyName : string -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.WithAssemblyName assemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ WithAssemblyName(System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The new assembly name.</param>
        <summary>
            Creates a compilation with the specified assembly name.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithOptions">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation WithOptions (Microsoft.CodeAnalysis.CompilationOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation WithOptions(class Microsoft.CodeAnalysis.CompilationOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.WithOptions(Microsoft.CodeAnalysis.CompilationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function WithOptions (options As CompilationOptions) As Compilation" />
      <MemberSignature Language="F#" Value="member this.WithOptions : Microsoft.CodeAnalysis.CompilationOptions -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.WithOptions options" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ WithOptions(Microsoft::CodeAnalysis::CompilationOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="Microsoft.CodeAnalysis.CompilationOptions" />
      </Parameters>
      <Docs>
        <param name="options">The new options.</param>
        <summary>
            Creates a new compilation with the specified compilation options.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithReferences">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation WithReferences (params Microsoft.CodeAnalysis.MetadataReference[] newReferences);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation WithReferences(class Microsoft.CodeAnalysis.MetadataReference[] newReferences) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.WithReferences(Microsoft.CodeAnalysis.MetadataReference[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WithReferences (ParamArray newReferences As MetadataReference()) As Compilation" />
      <MemberSignature Language="F#" Value="member this.WithReferences : Microsoft.CodeAnalysis.MetadataReference[] -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.WithReferences newReferences" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ WithReferences(... cli::array &lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ newReferences);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newReferences" Type="Microsoft.CodeAnalysis.MetadataReference[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newReferences">The new references.</param>
        <summary>
            Creates a new compilation with the specified references.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithReferences">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation WithReferences (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; newReferences);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation WithReferences(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.MetadataReference&gt; newReferences) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.WithReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})" />
      <MemberSignature Language="VB.NET" Value="Public Function WithReferences (newReferences As IEnumerable(Of MetadataReference)) As Compilation" />
      <MemberSignature Language="F#" Value="member this.WithReferences : seq&lt;Microsoft.CodeAnalysis.MetadataReference&gt; -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.WithReferences newReferences" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ WithReferences(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ newReferences);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newReferences" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt;" />
      </Parameters>
      <Docs>
        <param name="newReferences">
            The new references.
            </param>
        <summary>
            Creates a new compilation with the specified references.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithScriptCompilationInfo">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation WithScriptCompilationInfo (Microsoft.CodeAnalysis.ScriptCompilationInfo info);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Compilation WithScriptCompilationInfo(class Microsoft.CodeAnalysis.ScriptCompilationInfo info) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Compilation.WithScriptCompilationInfo(Microsoft.CodeAnalysis.ScriptCompilationInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function WithScriptCompilationInfo (info As ScriptCompilationInfo) As Compilation" />
      <MemberSignature Language="F#" Value="member this.WithScriptCompilationInfo : Microsoft.CodeAnalysis.ScriptCompilationInfo -&gt; Microsoft.CodeAnalysis.Compilation" Usage="compilation.WithScriptCompilationInfo info" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Compilation ^ WithScriptCompilationInfo(Microsoft::CodeAnalysis::ScriptCompilationInfo ^ info);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="Microsoft.CodeAnalysis.ScriptCompilationInfo" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>