<Type Name="SyntaxNode" FullName="Microsoft.CodeAnalysis.SyntaxNode">
  <TypeSignature Language="C#" Value="public abstract class SyntaxNode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SyntaxNode extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.SyntaxNode" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SyntaxNode" />
  <TypeSignature Language="F#" Value="type SyntaxNode = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class SyntaxNode abstract" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
    <AssemblyVersion>2.9.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{GetDebuggerDisplay(), nq}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            Represents a non-terminal node in the syntax tree. This is the language agnostic equivalent of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxNode" /> and <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxNode" />.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Ancestors">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; Ancestors (bool ascendOutOfTrivia = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; Ancestors(bool ascendOutOfTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.Ancestors(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ancestors (Optional ascendOutOfTrivia As Boolean = true) As IEnumerable(Of SyntaxNode)" />
      <MemberSignature Language="F#" Value="member this.Ancestors : bool -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" Usage="syntaxNode.Ancestors ascendOutOfTrivia" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ascendOutOfTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ascendOutOfTrivia">To be added.</param>
        <summary>
            Gets a list of ancestor nodes
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AncestorsAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; AncestorsAndSelf (bool ascendOutOfTrivia = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; AncestorsAndSelf(bool ascendOutOfTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Iterator Function AncestorsAndSelf (Optional ascendOutOfTrivia As Boolean = true) As IEnumerable(Of SyntaxNode)" />
      <MemberSignature Language="F#" Value="member this.AncestorsAndSelf : bool -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" Usage="syntaxNode.AncestorsAndSelf ascendOutOfTrivia" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.CodeAnalysis.SyntaxNode/&lt;AncestorsAndSelf&gt;d__85))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ascendOutOfTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ascendOutOfTrivia">To be added.</param>
        <summary>
            Gets a list of ancestor nodes (including this node) 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildNodes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; ChildNodes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; ChildNodes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes" />
      <MemberSignature Language="VB.NET" Value="Public Iterator Function ChildNodes () As IEnumerable(Of SyntaxNode)" />
      <MemberSignature Language="F#" Value="member this.ChildNodes : unit -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" Usage="syntaxNode.ChildNodes " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ ChildNodes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.CodeAnalysis.SyntaxNode/&lt;ChildNodes&gt;d__83))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets a list of the child nodes in prefix document order.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildNodesAndTokens">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.ChildSyntaxList ChildNodesAndTokens ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.ChildSyntaxList ChildNodesAndTokens() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodesAndTokens" />
      <MemberSignature Language="VB.NET" Value="Public Function ChildNodesAndTokens () As ChildSyntaxList" />
      <MemberSignature Language="F#" Value="member this.ChildNodesAndTokens : unit -&gt; Microsoft.CodeAnalysis.ChildSyntaxList" Usage="syntaxNode.ChildNodesAndTokens " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::ChildSyntaxList ChildNodesAndTokens();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ChildSyntaxList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            The list of child nodes and tokens of this node, where each element is a SyntaxNodeOrToken instance.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildThatContainsPosition">
      <MemberSignature Language="C#" Value="public virtual Microsoft.CodeAnalysis.SyntaxNodeOrToken ChildThatContainsPosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken ChildThatContainsPosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.ChildThatContainsPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ChildThatContainsPosition (position As Integer) As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="abstract member ChildThatContainsPosition : int -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken&#xA;override this.ChildThatContainsPosition : int -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNode.ChildThatContainsPosition position" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Microsoft::CodeAnalysis::SyntaxNodeOrToken ChildThatContainsPosition(int position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildTokens">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; ChildTokens ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; ChildTokens() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.ChildTokens" />
      <MemberSignature Language="VB.NET" Value="Public Iterator Function ChildTokens () As IEnumerable(Of SyntaxToken)" />
      <MemberSignature Language="F#" Value="member this.ChildTokens : unit -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;" Usage="syntaxNode.ChildTokens " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxToken&gt; ^ ChildTokens();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.CodeAnalysis.SyntaxNode/&lt;ChildTokens&gt;d__100))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets a list of the direct child tokens of this node.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (Microsoft.CodeAnalysis.SyntaxNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class Microsoft.CodeAnalysis.SyntaxNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.Contains(Microsoft.CodeAnalysis.SyntaxNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (node As SyntaxNode) As Boolean" />
      <MemberSignature Language="F#" Value="member this.Contains : Microsoft.CodeAnalysis.SyntaxNode -&gt; bool" Usage="syntaxNode.Contains node" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(Microsoft::CodeAnalysis::SyntaxNode ^ node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <summary>
            Determines if the specified node is a descendant of this node.
            Returns true for current node.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsAnnotations">
      <MemberSignature Language="C#" Value="public bool ContainsAnnotations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsAnnotations" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.ContainsAnnotations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsAnnotations As Boolean" />
      <MemberSignature Language="F#" Value="member this.ContainsAnnotations : bool" Usage="Microsoft.CodeAnalysis.SyntaxNode.ContainsAnnotations" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsAnnotations { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether this node or any sub node, token or trivia has annotations.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsDiagnostics">
      <MemberSignature Language="C#" Value="public bool ContainsDiagnostics { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsDiagnostics" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.ContainsDiagnostics" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsDiagnostics As Boolean" />
      <MemberSignature Language="F#" Value="member this.ContainsDiagnostics : bool" Usage="Microsoft.CodeAnalysis.SyntaxNode.ContainsDiagnostics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsDiagnostics { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether this node or any of its descendant nodes, tokens or trivia have any diagnostics on them. 
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsDirectives">
      <MemberSignature Language="C#" Value="public bool ContainsDirectives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsDirectives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.ContainsDirectives" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsDirectives As Boolean" />
      <MemberSignature Language="F#" Value="member this.ContainsDirectives : bool" Usage="Microsoft.CodeAnalysis.SyntaxNode.ContainsDirectives" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsDirectives { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether this node has any descendant preprocessor directives.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsSkippedText">
      <MemberSignature Language="C#" Value="public bool ContainsSkippedText { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsSkippedText" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.ContainsSkippedText" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsSkippedText As Boolean" />
      <MemberSignature Language="F#" Value="member this.ContainsSkippedText : bool" Usage="Microsoft.CodeAnalysis.SyntaxNode.ContainsSkippedText" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsSkippedText { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether this node has any descendant skipped text.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyAnnotationsTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T CopyAnnotationsTo&lt;T&gt; (T node) where T : Microsoft.CodeAnalysis.SyntaxNode;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T CopyAnnotationsTo&lt;(class Microsoft.CodeAnalysis.SyntaxNode) T&gt;(!!T node) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.CopyAnnotationsTo``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyAnnotationsTo(Of T As SyntaxNode) (node As T) As T" />
      <MemberSignature Language="F#" Value="member this.CopyAnnotationsTo : 'T -&gt; 'T (requires 'T :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="syntaxNode.CopyAnnotationsTo node" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : Microsoft::CodeAnalysis::SyntaxNode T CopyAnnotationsTo(T node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="node" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="node">To be added.</param>
        <summary>
            Copies all SyntaxAnnotations, if any, from this SyntaxNode instance and attaches them to a new instance based on <paramref name="node" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>
            If no annotations are copied, just returns <paramref name="node" />.
            </para>
          <para>
            It can also be used manually to preserve annotations in a more complex tree
            modification, even if the type of a node changes.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; DescendantNodes (Func&lt;Microsoft.CodeAnalysis.SyntaxNode,bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; DescendantNodes(class System.Func`2&lt;class Microsoft.CodeAnalysis.SyntaxNode, bool&gt; descendIntoChildren, bool descendIntoTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantNodes (Optional descendIntoChildren As Func(Of SyntaxNode, Boolean) = null, Optional descendIntoTrivia As Boolean = false) As IEnumerable(Of SyntaxNode)" />
      <MemberSignature Language="F#" Value="member this.DescendantNodes : Func&lt;Microsoft.CodeAnalysis.SyntaxNode, bool&gt; * bool -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" Usage="syntaxNode.DescendantNodes (descendIntoChildren, descendIntoTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendIntoChildren" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Boolean&gt;" />
        <Parameter Name="descendIntoTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
        <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        <summary>
            Gets a list of descendant nodes in prefix document order.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; DescendantNodes (Microsoft.CodeAnalysis.Text.TextSpan span, Func&lt;Microsoft.CodeAnalysis.SyntaxNode,bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; DescendantNodes(valuetype Microsoft.CodeAnalysis.Text.TextSpan span, class System.Func`2&lt;class Microsoft.CodeAnalysis.SyntaxNode, bool&gt; descendIntoChildren, bool descendIntoTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantNodes (span As TextSpan, Optional descendIntoChildren As Func(Of SyntaxNode, Boolean) = null, Optional descendIntoTrivia As Boolean = false) As IEnumerable(Of SyntaxNode)" />
      <MemberSignature Language="F#" Value="member this.DescendantNodes : Microsoft.CodeAnalysis.Text.TextSpan * Func&lt;Microsoft.CodeAnalysis.SyntaxNode, bool&gt; * bool -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" Usage="syntaxNode.DescendantNodes (span, descendIntoChildren, descendIntoTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="Microsoft.CodeAnalysis.Text.TextSpan" />
        <Parameter Name="descendIntoChildren" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Boolean&gt;" />
        <Parameter Name="descendIntoTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="span">The span the node's full span must intersect.</param>
        <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
        <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        <summary>
            Gets a list of descendant nodes in prefix document order.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodesAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; DescendantNodesAndSelf (Func&lt;Microsoft.CodeAnalysis.SyntaxNode,bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; DescendantNodesAndSelf(class System.Func`2&lt;class Microsoft.CodeAnalysis.SyntaxNode, bool&gt; descendIntoChildren, bool descendIntoTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndSelf(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantNodesAndSelf (Optional descendIntoChildren As Func(Of SyntaxNode, Boolean) = null, Optional descendIntoTrivia As Boolean = false) As IEnumerable(Of SyntaxNode)" />
      <MemberSignature Language="F#" Value="member this.DescendantNodesAndSelf : Func&lt;Microsoft.CodeAnalysis.SyntaxNode, bool&gt; * bool -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" Usage="syntaxNode.DescendantNodesAndSelf (descendIntoChildren, descendIntoTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendIntoChildren" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Boolean&gt;" />
        <Parameter Name="descendIntoTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
        <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        <summary>
            Gets a list of descendant nodes (including this node) in prefix document order.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodesAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; DescendantNodesAndSelf (Microsoft.CodeAnalysis.Text.TextSpan span, Func&lt;Microsoft.CodeAnalysis.SyntaxNode,bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; DescendantNodesAndSelf(valuetype Microsoft.CodeAnalysis.Text.TextSpan span, class System.Func`2&lt;class Microsoft.CodeAnalysis.SyntaxNode, bool&gt; descendIntoChildren, bool descendIntoTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndSelf(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantNodesAndSelf (span As TextSpan, Optional descendIntoChildren As Func(Of SyntaxNode, Boolean) = null, Optional descendIntoTrivia As Boolean = false) As IEnumerable(Of SyntaxNode)" />
      <MemberSignature Language="F#" Value="member this.DescendantNodesAndSelf : Microsoft.CodeAnalysis.Text.TextSpan * Func&lt;Microsoft.CodeAnalysis.SyntaxNode, bool&gt; * bool -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" Usage="syntaxNode.DescendantNodesAndSelf (span, descendIntoChildren, descendIntoTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="Microsoft.CodeAnalysis.Text.TextSpan" />
        <Parameter Name="descendIntoChildren" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Boolean&gt;" />
        <Parameter Name="descendIntoTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="span">The span the node's full span must intersect.</param>
        <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
        <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        <summary>
            Gets a list of descendant nodes (including this node) in prefix document order.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodesAndTokens">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; DescendantNodesAndTokens (Func&lt;Microsoft.CodeAnalysis.SyntaxNode,bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; DescendantNodesAndTokens(class System.Func`2&lt;class Microsoft.CodeAnalysis.SyntaxNode, bool&gt; descendIntoChildren, bool descendIntoTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokens(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantNodesAndTokens (Optional descendIntoChildren As Func(Of SyntaxNode, Boolean) = null, Optional descendIntoTrivia As Boolean = false) As IEnumerable(Of SyntaxNodeOrToken)" />
      <MemberSignature Language="F#" Value="member this.DescendantNodesAndTokens : Func&lt;Microsoft.CodeAnalysis.SyntaxNode, bool&gt; * bool -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;" Usage="syntaxNode.DescendantNodesAndTokens (descendIntoChildren, descendIntoTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendIntoChildren" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Boolean&gt;" />
        <Parameter Name="descendIntoTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
        <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        <summary>
            Gets a list of descendant nodes and tokens in prefix document order.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodesAndTokens">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; DescendantNodesAndTokens (Microsoft.CodeAnalysis.Text.TextSpan span, Func&lt;Microsoft.CodeAnalysis.SyntaxNode,bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; DescendantNodesAndTokens(valuetype Microsoft.CodeAnalysis.Text.TextSpan span, class System.Func`2&lt;class Microsoft.CodeAnalysis.SyntaxNode, bool&gt; descendIntoChildren, bool descendIntoTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokens(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantNodesAndTokens (span As TextSpan, Optional descendIntoChildren As Func(Of SyntaxNode, Boolean) = null, Optional descendIntoTrivia As Boolean = false) As IEnumerable(Of SyntaxNodeOrToken)" />
      <MemberSignature Language="F#" Value="member this.DescendantNodesAndTokens : Microsoft.CodeAnalysis.Text.TextSpan * Func&lt;Microsoft.CodeAnalysis.SyntaxNode, bool&gt; * bool -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;" Usage="syntaxNode.DescendantNodesAndTokens (span, descendIntoChildren, descendIntoTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="Microsoft.CodeAnalysis.Text.TextSpan" />
        <Parameter Name="descendIntoChildren" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Boolean&gt;" />
        <Parameter Name="descendIntoTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="span">The span the node's full span must intersect.</param>
        <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
        <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        <summary>
            Gets a list of the descendant nodes and tokens in prefix document order.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodesAndTokensAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; DescendantNodesAndTokensAndSelf (Func&lt;Microsoft.CodeAnalysis.SyntaxNode,bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; DescendantNodesAndTokensAndSelf(class System.Func`2&lt;class Microsoft.CodeAnalysis.SyntaxNode, bool&gt; descendIntoChildren, bool descendIntoTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokensAndSelf(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantNodesAndTokensAndSelf (Optional descendIntoChildren As Func(Of SyntaxNode, Boolean) = null, Optional descendIntoTrivia As Boolean = false) As IEnumerable(Of SyntaxNodeOrToken)" />
      <MemberSignature Language="F#" Value="member this.DescendantNodesAndTokensAndSelf : Func&lt;Microsoft.CodeAnalysis.SyntaxNode, bool&gt; * bool -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;" Usage="syntaxNode.DescendantNodesAndTokensAndSelf (descendIntoChildren, descendIntoTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendIntoChildren" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Boolean&gt;" />
        <Parameter Name="descendIntoTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
        <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        <summary>
            Gets a list of descendant nodes and tokens (including this node) in prefix document order.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodesAndTokensAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; DescendantNodesAndTokensAndSelf (Microsoft.CodeAnalysis.Text.TextSpan span, Func&lt;Microsoft.CodeAnalysis.SyntaxNode,bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; DescendantNodesAndTokensAndSelf(valuetype Microsoft.CodeAnalysis.Text.TextSpan span, class System.Func`2&lt;class Microsoft.CodeAnalysis.SyntaxNode, bool&gt; descendIntoChildren, bool descendIntoTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokensAndSelf(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantNodesAndTokensAndSelf (span As TextSpan, Optional descendIntoChildren As Func(Of SyntaxNode, Boolean) = null, Optional descendIntoTrivia As Boolean = false) As IEnumerable(Of SyntaxNodeOrToken)" />
      <MemberSignature Language="F#" Value="member this.DescendantNodesAndTokensAndSelf : Microsoft.CodeAnalysis.Text.TextSpan * Func&lt;Microsoft.CodeAnalysis.SyntaxNode, bool&gt; * bool -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;" Usage="syntaxNode.DescendantNodesAndTokensAndSelf (span, descendIntoChildren, descendIntoTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="Microsoft.CodeAnalysis.Text.TextSpan" />
        <Parameter Name="descendIntoChildren" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Boolean&gt;" />
        <Parameter Name="descendIntoTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="span">The span the node's full span must intersect.</param>
        <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
        <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        <summary>
            Gets a list of the descendant nodes and tokens (including this node) in prefix document order.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantTokens">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; DescendantTokens (Func&lt;Microsoft.CodeAnalysis.SyntaxNode,bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; DescendantTokens(class System.Func`2&lt;class Microsoft.CodeAnalysis.SyntaxNode, bool&gt; descendIntoChildren, bool descendIntoTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantTokens (Optional descendIntoChildren As Func(Of SyntaxNode, Boolean) = null, Optional descendIntoTrivia As Boolean = false) As IEnumerable(Of SyntaxToken)" />
      <MemberSignature Language="F#" Value="member this.DescendantTokens : Func&lt;Microsoft.CodeAnalysis.SyntaxNode, bool&gt; * bool -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;" Usage="syntaxNode.DescendantTokens (descendIntoChildren, descendIntoTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendIntoChildren" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Boolean&gt;" />
        <Parameter Name="descendIntoTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="descendIntoChildren">To be added.</param>
        <param name="descendIntoTrivia">To be added.</param>
        <summary>
            Gets a list of all the tokens in the span of this node.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantTokens">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; DescendantTokens (Microsoft.CodeAnalysis.Text.TextSpan span, Func&lt;Microsoft.CodeAnalysis.SyntaxNode,bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; DescendantTokens(valuetype Microsoft.CodeAnalysis.Text.TextSpan span, class System.Func`2&lt;class Microsoft.CodeAnalysis.SyntaxNode, bool&gt; descendIntoChildren, bool descendIntoTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantTokens (span As TextSpan, Optional descendIntoChildren As Func(Of SyntaxNode, Boolean) = null, Optional descendIntoTrivia As Boolean = false) As IEnumerable(Of SyntaxToken)" />
      <MemberSignature Language="F#" Value="member this.DescendantTokens : Microsoft.CodeAnalysis.Text.TextSpan * Func&lt;Microsoft.CodeAnalysis.SyntaxNode, bool&gt; * bool -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;" Usage="syntaxNode.DescendantTokens (span, descendIntoChildren, descendIntoTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="Microsoft.CodeAnalysis.Text.TextSpan" />
        <Parameter Name="descendIntoChildren" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Boolean&gt;" />
        <Parameter Name="descendIntoTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <param name="descendIntoChildren">To be added.</param>
        <param name="descendIntoTrivia">To be added.</param>
        <summary>
            Gets a list of all the tokens in the full span of this node.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantTrivia">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; DescendantTrivia (Func&lt;Microsoft.CodeAnalysis.SyntaxNode,bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; DescendantTrivia(class System.Func`2&lt;class Microsoft.CodeAnalysis.SyntaxNode, bool&gt; descendIntoChildren, bool descendIntoTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantTrivia (Optional descendIntoChildren As Func(Of SyntaxNode, Boolean) = null, Optional descendIntoTrivia As Boolean = false) As IEnumerable(Of SyntaxTrivia)" />
      <MemberSignature Language="F#" Value="member this.DescendantTrivia : Func&lt;Microsoft.CodeAnalysis.SyntaxNode, bool&gt; * bool -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" Usage="syntaxNode.DescendantTrivia (descendIntoChildren, descendIntoTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendIntoChildren" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Boolean&gt;" />
        <Parameter Name="descendIntoTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="descendIntoChildren">To be added.</param>
        <param name="descendIntoTrivia">To be added.</param>
        <summary>
            Get a list of all the trivia associated with the descendant nodes and tokens.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantTrivia">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; DescendantTrivia (Microsoft.CodeAnalysis.Text.TextSpan span, Func&lt;Microsoft.CodeAnalysis.SyntaxNode,bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; DescendantTrivia(valuetype Microsoft.CodeAnalysis.Text.TextSpan span, class System.Func`2&lt;class Microsoft.CodeAnalysis.SyntaxNode, bool&gt; descendIntoChildren, bool descendIntoTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia(Microsoft.CodeAnalysis.Text.TextSpan,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantTrivia (span As TextSpan, Optional descendIntoChildren As Func(Of SyntaxNode, Boolean) = null, Optional descendIntoTrivia As Boolean = false) As IEnumerable(Of SyntaxTrivia)" />
      <MemberSignature Language="F#" Value="member this.DescendantTrivia : Microsoft.CodeAnalysis.Text.TextSpan * Func&lt;Microsoft.CodeAnalysis.SyntaxNode, bool&gt; * bool -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" Usage="syntaxNode.DescendantTrivia (span, descendIntoChildren, descendIntoTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="Microsoft.CodeAnalysis.Text.TextSpan" />
        <Parameter Name="descendIntoChildren" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Boolean&gt;" />
        <Parameter Name="descendIntoTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <param name="descendIntoChildren">To be added.</param>
        <param name="descendIntoTrivia">To be added.</param>
        <summary>
            Get a list of all the trivia associated with the descendant nodes and tokens.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EquivalentToCore">
      <MemberSignature Language="C#" Value="protected virtual bool EquivalentToCore (Microsoft.CodeAnalysis.SyntaxNode other);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool EquivalentToCore(class Microsoft.CodeAnalysis.SyntaxNode other) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.EquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EquivalentToCore (other As SyntaxNode) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member EquivalentToCore : Microsoft.CodeAnalysis.SyntaxNode -&gt; bool&#xA;override this.EquivalentToCore : Microsoft.CodeAnalysis.SyntaxNode -&gt; bool" Usage="syntaxNode.EquivalentToCore other" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool EquivalentToCore(Microsoft::CodeAnalysis::SyntaxNode ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="Microsoft.CodeAnalysis.SyntaxNode" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>
            Determine if this node is structurally equivalent to another.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNode">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNode FindNode (Microsoft.CodeAnalysis.Text.TextSpan span, bool findInsideTrivia = false, bool getInnermostNodeForTie = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.SyntaxNode FindNode(valuetype Microsoft.CodeAnalysis.Text.TextSpan span, bool findInsideTrivia, bool getInnermostNodeForTie) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.FindNode(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNode (span As TextSpan, Optional findInsideTrivia As Boolean = false, Optional getInnermostNodeForTie As Boolean = false) As SyntaxNode" />
      <MemberSignature Language="F#" Value="member this.FindNode : Microsoft.CodeAnalysis.Text.TextSpan * bool * bool -&gt; Microsoft.CodeAnalysis.SyntaxNode" Usage="syntaxNode.FindNode (span, findInsideTrivia, getInnermostNodeForTie)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="Microsoft.CodeAnalysis.Text.TextSpan" />
        <Parameter Name="findInsideTrivia" Type="System.Boolean" />
        <Parameter Name="getInnermostNodeForTie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <param name="findInsideTrivia">To be added.</param>
        <param name="getInnermostNodeForTie">To be added.</param>
        <summary>
            Finds the node with the smallest <see cref="P:Microsoft.CodeAnalysis.SyntaxNode.FullSpan" /> that contains <paramref name="span" />.
            <paramref name="getInnermostNodeForTie" /> is used to determine the behavior in case of a tie (i.e. a node having the same span as its parent).
            If <paramref name="getInnermostNodeForTie" /> is true, then it returns lowest descending node encompassing the given <paramref name="span" />.
            Otherwise, it returns the outermost node encompassing the given <paramref name="span" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            TODO: This should probably be reimplemented with <see cref="M:Microsoft.CodeAnalysis.SyntaxNode.ChildThatContainsPosition(System.Int32)" /></remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if <see cref="P:Microsoft.CodeAnalysis.SyntaxNode.FullSpan" /> doesn't contain the given span.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindToken">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxToken FindToken (int position, bool findInsideTrivia = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxToken FindToken(int32 position, bool findInsideTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.FindToken(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindToken (position As Integer, Optional findInsideTrivia As Boolean = false) As SyntaxToken" />
      <MemberSignature Language="F#" Value="member this.FindToken : int * bool -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="syntaxNode.FindToken (position, findInsideTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="findInsideTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">The character position of the token relative to the beginning of the file.</param>
        <param name="findInsideTrivia">
            True to return tokens that are part of trivia. If false finds the token whose full span (including trivia)
            includes the position.
            </param>
        <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindTokenCore">
      <MemberSignature Language="C#" Value="protected virtual Microsoft.CodeAnalysis.SyntaxToken FindTokenCore (int position, bool findInsideTrivia);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype Microsoft.CodeAnalysis.SyntaxToken FindTokenCore(int32 position, bool findInsideTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.FindTokenCore(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FindTokenCore (position As Integer, findInsideTrivia As Boolean) As SyntaxToken" />
      <MemberSignature Language="F#" Value="abstract member FindTokenCore : int * bool -&gt; Microsoft.CodeAnalysis.SyntaxToken&#xA;override this.FindTokenCore : int * bool -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="syntaxNode.FindTokenCore (position, findInsideTrivia)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Microsoft::CodeAnalysis::SyntaxToken FindTokenCore(int position, bool findInsideTrivia);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="findInsideTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">The character position of the token relative to the beginning of the file.</param>
        <param name="findInsideTrivia">
            True to return tokens that are part of trivia.
            If false finds the token whose full span (including trivia) includes the position.
            </param>
        <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindTokenCore">
      <MemberSignature Language="C#" Value="protected virtual Microsoft.CodeAnalysis.SyntaxToken FindTokenCore (int position, Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,bool&gt; stepInto);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype Microsoft.CodeAnalysis.SyntaxToken FindTokenCore(int32 position, class System.Func`2&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia, bool&gt; stepInto) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.FindTokenCore(System.Int32,System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FindTokenCore (position As Integer, stepInto As Func(Of SyntaxTrivia, Boolean)) As SyntaxToken" />
      <MemberSignature Language="F#" Value="abstract member FindTokenCore : int * Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia, bool&gt; -&gt; Microsoft.CodeAnalysis.SyntaxToken&#xA;override this.FindTokenCore : int * Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia, bool&gt; -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="syntaxNode.FindTokenCore (position, stepInto)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Microsoft::CodeAnalysis::SyntaxToken FindTokenCore(int position, Func&lt;Microsoft::CodeAnalysis::SyntaxTrivia, bool&gt; ^ stepInto);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="stepInto" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="position">The character position of the token relative to the beginning of the file.</param>
        <param name="stepInto">
            Applied on every structured trivia. Return false if the tokens included in the trivia should be skipped. 
            Pass null to skip all structured trivia.
            </param>
        <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindTrivia">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxTrivia FindTrivia (int position, bool findInsideTrivia = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxTrivia FindTrivia(int32 position, bool findInsideTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.FindTrivia(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindTrivia (position As Integer, Optional findInsideTrivia As Boolean = false) As SyntaxTrivia" />
      <MemberSignature Language="F#" Value="member this.FindTrivia : int * bool -&gt; Microsoft.CodeAnalysis.SyntaxTrivia" Usage="syntaxNode.FindTrivia (position, findInsideTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTrivia</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="findInsideTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">The character position of the trivia relative to the beginning of the file.</param>
        <param name="findInsideTrivia">
            True to return tokens that are part of trivia. If false finds the token whose full span (including trivia)
            includes the position.
            </param>
        <summary>
            Finds a descendant trivia of this node whose span includes the supplied position.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindTrivia">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxTrivia FindTrivia (int position, Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,bool&gt; stepInto);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxTrivia FindTrivia(int32 position, class System.Func`2&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia, bool&gt; stepInto) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.FindTrivia(System.Int32,System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindTrivia (position As Integer, stepInto As Func(Of SyntaxTrivia, Boolean)) As SyntaxTrivia" />
      <MemberSignature Language="F#" Value="member this.FindTrivia : int * Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia, bool&gt; -&gt; Microsoft.CodeAnalysis.SyntaxTrivia" Usage="syntaxNode.FindTrivia (position, stepInto)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxTrivia FindTrivia(int position, Func&lt;Microsoft::CodeAnalysis::SyntaxTrivia, bool&gt; ^ stepInto);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTrivia</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="stepInto" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="position">The character position of the trivia relative to the beginning of
            the file.</param>
        <param name="stepInto">Specifies a function that determines per trivia node, whether to
            descend into structured trivia of that node.</param>
        <summary>
            Finds a descendant trivia of this node at the specified position, where the position is
            within the span of the node.
            </summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindTriviaCore">
      <MemberSignature Language="C#" Value="protected virtual Microsoft.CodeAnalysis.SyntaxTrivia FindTriviaCore (int position, bool findInsideTrivia);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype Microsoft.CodeAnalysis.SyntaxTrivia FindTriviaCore(int32 position, bool findInsideTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.FindTriviaCore(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FindTriviaCore (position As Integer, findInsideTrivia As Boolean) As SyntaxTrivia" />
      <MemberSignature Language="F#" Value="abstract member FindTriviaCore : int * bool -&gt; Microsoft.CodeAnalysis.SyntaxTrivia&#xA;override this.FindTriviaCore : int * bool -&gt; Microsoft.CodeAnalysis.SyntaxTrivia" Usage="syntaxNode.FindTriviaCore (position, findInsideTrivia)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Microsoft::CodeAnalysis::SyntaxTrivia FindTriviaCore(int position, bool findInsideTrivia);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTrivia</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="findInsideTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">The character position of the trivia relative to the beginning of the file.</param>
        <param name="findInsideTrivia">Whether to search inside structured trivia.</param>
        <summary>
            Finds a descendant trivia of this node whose span includes the supplied position.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FirstAncestorOrSelf&lt;TNode&gt;">
      <MemberSignature Language="C#" Value="public TNode FirstAncestorOrSelf&lt;TNode&gt; (Func&lt;TNode,bool&gt; predicate = null, bool ascendOutOfTrivia = true) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TNode FirstAncestorOrSelf&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(class System.Func`2&lt;!!TNode, bool&gt; predicate, bool ascendOutOfTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.FirstAncestorOrSelf``1(System.Func{``0,System.Boolean},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FirstAncestorOrSelf(Of TNode As SyntaxNode) (Optional predicate As Func(Of TNode, Boolean) = null, Optional ascendOutOfTrivia As Boolean = true) As TNode" />
      <MemberSignature Language="F#" Value="member this.FirstAncestorOrSelf : Func&lt;'Node, bool (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; * bool -&gt; 'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="syntaxNode.FirstAncestorOrSelf (predicate, ascendOutOfTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TNode</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNode">
          <Constraints>
            <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="System.Func&lt;TNode,System.Boolean&gt;" />
        <Parameter Name="ascendOutOfTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TNode">To be added.</typeparam>
        <param name="predicate">To be added.</param>
        <param name="ascendOutOfTrivia">To be added.</param>
        <summary>
            Gets the first node of type TNode that matches the predicate.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullSpan">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Text.TextSpan FullSpan { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.Text.TextSpan FullSpan" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.FullSpan" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FullSpan As TextSpan" />
      <MemberSignature Language="F#" Value="member this.FullSpan : Microsoft.CodeAnalysis.Text.TextSpan" Usage="Microsoft.CodeAnalysis.SyntaxNode.FullSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::Text::TextSpan FullSpan { Microsoft::CodeAnalysis::Text::TextSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Text.TextSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The absolute span of this node in characters, including its leading and trailing trivia.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnnotatedNodes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; GetAnnotatedNodes (Microsoft.CodeAnalysis.SyntaxAnnotation syntaxAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; GetAnnotatedNodes(class Microsoft.CodeAnalysis.SyntaxAnnotation syntaxAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodes(Microsoft.CodeAnalysis.SyntaxAnnotation)" />
      <MemberSignature Language="F#" Value="member this.GetAnnotatedNodes : Microsoft.CodeAnalysis.SyntaxAnnotation -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" Usage="syntaxNode.GetAnnotatedNodes syntaxAnnotation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ GetAnnotatedNodes(Microsoft::CodeAnalysis::SyntaxAnnotation ^ syntaxAnnotation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="syntaxAnnotation" Type="Microsoft.CodeAnalysis.SyntaxAnnotation" />
      </Parameters>
      <Docs>
        <param name="syntaxAnnotation">To be added.</param>
        <summary>
            Gets all nodes with the specified annotation.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnnotatedNodes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; GetAnnotatedNodes (string annotationKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; GetAnnotatedNodes(string annotationKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnnotatedNodes (annotationKind As String) As IEnumerable(Of SyntaxNode)" />
      <MemberSignature Language="F#" Value="member this.GetAnnotatedNodes : string -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" Usage="syntaxNode.GetAnnotatedNodes annotationKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ GetAnnotatedNodes(System::String ^ annotationKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKind" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="annotationKind"></param>
        <summary>
            Gets all nodes with the specified annotation kind.
            </summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnnotatedNodesAndTokens">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; GetAnnotatedNodesAndTokens (Microsoft.CodeAnalysis.SyntaxAnnotation annotation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; GetAnnotatedNodesAndTokens(class Microsoft.CodeAnalysis.SyntaxAnnotation annotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(Microsoft.CodeAnalysis.SyntaxAnnotation)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnnotatedNodesAndTokens (annotation As SyntaxAnnotation) As IEnumerable(Of SyntaxNodeOrToken)" />
      <MemberSignature Language="F#" Value="member this.GetAnnotatedNodesAndTokens : Microsoft.CodeAnalysis.SyntaxAnnotation -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;" Usage="syntaxNode.GetAnnotatedNodesAndTokens annotation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNodeOrToken&gt; ^ GetAnnotatedNodesAndTokens(Microsoft::CodeAnalysis::SyntaxAnnotation ^ annotation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotation" Type="Microsoft.CodeAnalysis.SyntaxAnnotation" />
      </Parameters>
      <Docs>
        <param name="annotation">To be added.</param>
        <summary>
            Gets all nodes and tokens with the specified annotation.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnnotatedNodesAndTokens">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; GetAnnotatedNodesAndTokens (string annotationKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; GetAnnotatedNodesAndTokens(string annotationKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnnotatedNodesAndTokens (annotationKind As String) As IEnumerable(Of SyntaxNodeOrToken)" />
      <MemberSignature Language="F#" Value="member this.GetAnnotatedNodesAndTokens : string -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;" Usage="syntaxNode.GetAnnotatedNodesAndTokens annotationKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNodeOrToken&gt; ^ GetAnnotatedNodesAndTokens(System::String ^ annotationKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKind" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="annotationKind">To be added.</param>
        <summary>
            Gets all nodes and tokens with an annotation of the specified annotation kind.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnnotatedNodesAndTokens">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; GetAnnotatedNodesAndTokens (params string[] annotationKinds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; GetAnnotatedNodesAndTokens(string[] annotationKinds) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnnotatedNodesAndTokens (ParamArray annotationKinds As String()) As IEnumerable(Of SyntaxNodeOrToken)" />
      <MemberSignature Language="F#" Value="member this.GetAnnotatedNodesAndTokens : string[] -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;" Usage="syntaxNode.GetAnnotatedNodesAndTokens annotationKinds" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNodeOrToken&gt; ^ GetAnnotatedNodesAndTokens(... cli::array &lt;System::String ^&gt; ^ annotationKinds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKinds" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="annotationKinds">To be added.</param>
        <summary>
            Gets all nodes and tokens with an annotation of the specified annotation kinds.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnnotatedTokens">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; GetAnnotatedTokens (Microsoft.CodeAnalysis.SyntaxAnnotation syntaxAnnotation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; GetAnnotatedTokens(class Microsoft.CodeAnalysis.SyntaxAnnotation syntaxAnnotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTokens(Microsoft.CodeAnalysis.SyntaxAnnotation)" />
      <MemberSignature Language="F#" Value="member this.GetAnnotatedTokens : Microsoft.CodeAnalysis.SyntaxAnnotation -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;" Usage="syntaxNode.GetAnnotatedTokens syntaxAnnotation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxToken&gt; ^ GetAnnotatedTokens(Microsoft::CodeAnalysis::SyntaxAnnotation ^ syntaxAnnotation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="syntaxAnnotation" Type="Microsoft.CodeAnalysis.SyntaxAnnotation" />
      </Parameters>
      <Docs>
        <param name="syntaxAnnotation">To be added.</param>
        <summary>
            Gets all tokens with the specified annotation.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnnotatedTokens">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; GetAnnotatedTokens (string annotationKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; GetAnnotatedTokens(string annotationKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTokens(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnnotatedTokens (annotationKind As String) As IEnumerable(Of SyntaxToken)" />
      <MemberSignature Language="F#" Value="member this.GetAnnotatedTokens : string -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;" Usage="syntaxNode.GetAnnotatedTokens annotationKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxToken&gt; ^ GetAnnotatedTokens(System::String ^ annotationKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKind" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="annotationKind">To be added.</param>
        <summary>
            Gets all tokens with the specified annotation kind.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnnotatedTrivia">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; GetAnnotatedTrivia (Microsoft.CodeAnalysis.SyntaxAnnotation annotation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; GetAnnotatedTrivia(class Microsoft.CodeAnalysis.SyntaxAnnotation annotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(Microsoft.CodeAnalysis.SyntaxAnnotation)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnnotatedTrivia (annotation As SyntaxAnnotation) As IEnumerable(Of SyntaxTrivia)" />
      <MemberSignature Language="F#" Value="member this.GetAnnotatedTrivia : Microsoft.CodeAnalysis.SyntaxAnnotation -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" Usage="syntaxNode.GetAnnotatedTrivia annotation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ GetAnnotatedTrivia(Microsoft::CodeAnalysis::SyntaxAnnotation ^ annotation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotation" Type="Microsoft.CodeAnalysis.SyntaxAnnotation" />
      </Parameters>
      <Docs>
        <param name="annotation">To be added.</param>
        <summary>
            Gets all trivia with the specified annotation.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnnotatedTrivia">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; GetAnnotatedTrivia (string annotationKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; GetAnnotatedTrivia(string annotationKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnnotatedTrivia (annotationKind As String) As IEnumerable(Of SyntaxTrivia)" />
      <MemberSignature Language="F#" Value="member this.GetAnnotatedTrivia : string -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" Usage="syntaxNode.GetAnnotatedTrivia annotationKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ GetAnnotatedTrivia(System::String ^ annotationKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKind" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="annotationKind">To be added.</param>
        <summary>
            Gets all trivia with an annotation of the specified annotation kind.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnnotatedTrivia">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; GetAnnotatedTrivia (params string[] annotationKinds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; GetAnnotatedTrivia(string[] annotationKinds) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnnotatedTrivia (ParamArray annotationKinds As String()) As IEnumerable(Of SyntaxTrivia)" />
      <MemberSignature Language="F#" Value="member this.GetAnnotatedTrivia : string[] -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" Usage="syntaxNode.GetAnnotatedTrivia annotationKinds" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ GetAnnotatedTrivia(... cli::array &lt;System::String ^&gt; ^ annotationKinds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKinds" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="annotationKinds">To be added.</param>
        <summary>
            Gets all trivia with an annotation of the specified annotation kinds.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnnotations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt; GetAnnotations (System.Collections.Generic.IEnumerable&lt;string&gt; annotationKinds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxAnnotation&gt; GetAnnotations(class System.Collections.Generic.IEnumerable`1&lt;string&gt; annotationKinds) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotations(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnnotations (annotationKinds As IEnumerable(Of String)) As IEnumerable(Of SyntaxAnnotation)" />
      <MemberSignature Language="F#" Value="member this.GetAnnotations : seq&lt;string&gt; -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt;" Usage="syntaxNode.GetAnnotations annotationKinds" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxAnnotation ^&gt; ^ GetAnnotations(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ annotationKinds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKinds" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="annotationKinds">To be added.</param>
        <summary>
            Gets all the annotations with the specified annotation kinds. 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnnotations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt; GetAnnotations (string annotationKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxAnnotation&gt; GetAnnotations(string annotationKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotations(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnnotations (annotationKind As String) As IEnumerable(Of SyntaxAnnotation)" />
      <MemberSignature Language="F#" Value="member this.GetAnnotations : string -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt;" Usage="syntaxNode.GetAnnotations annotationKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxAnnotation ^&gt; ^ GetAnnotations(System::String ^ annotationKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKind" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="annotationKind">To be added.</param>
        <summary>
            Gets all the annotations with the specified annotation kind. 
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDiagnostics">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetDiagnostics" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDiagnostics () As IEnumerable(Of Diagnostic)" />
      <MemberSignature Language="F#" Value="member this.GetDiagnostics : unit -&gt; seq&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="syntaxNode.GetDiagnostics " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::Diagnostic ^&gt; ^ GetDiagnostics();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets a list of all the diagnostics in the sub tree that has this node as its root.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFirstToken">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxToken GetFirstToken (bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxToken GetFirstToken(bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetFirstToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirstToken (Optional includeZeroWidth As Boolean = false, Optional includeSkipped As Boolean = false, Optional includeDirectives As Boolean = false, Optional includeDocumentationComments As Boolean = false) As SyntaxToken" />
      <MemberSignature Language="F#" Value="member this.GetFirstToken : bool * bool * bool * bool -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="syntaxNode.GetFirstToken (includeZeroWidth, includeSkipped, includeDirectives, includeDocumentationComments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeZeroWidth" Type="System.Boolean" />
        <Parameter Name="includeSkipped" Type="System.Boolean" />
        <Parameter Name="includeDirectives" Type="System.Boolean" />
        <Parameter Name="includeDocumentationComments" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includeZeroWidth">To be added.</param>
        <param name="includeSkipped">To be added.</param>
        <param name="includeDirectives">To be added.</param>
        <param name="includeDocumentationComments">To be added.</param>
        <summary>
            Gets the first token of the tree rooted by this node. Skips zero-width tokens.
            </summary>
        <returns>The first token or <c>default(SyntaxToken)</c> if it doesn't exist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastToken">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxToken GetLastToken (bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxToken GetLastToken(bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetLastToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastToken (Optional includeZeroWidth As Boolean = false, Optional includeSkipped As Boolean = false, Optional includeDirectives As Boolean = false, Optional includeDocumentationComments As Boolean = false) As SyntaxToken" />
      <MemberSignature Language="F#" Value="member this.GetLastToken : bool * bool * bool * bool -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="syntaxNode.GetLastToken (includeZeroWidth, includeSkipped, includeDirectives, includeDocumentationComments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeZeroWidth" Type="System.Boolean" />
        <Parameter Name="includeSkipped" Type="System.Boolean" />
        <Parameter Name="includeDirectives" Type="System.Boolean" />
        <Parameter Name="includeDocumentationComments" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includeZeroWidth">To be added.</param>
        <param name="includeSkipped">To be added.</param>
        <param name="includeDirectives">To be added.</param>
        <param name="includeDocumentationComments">To be added.</param>
        <summary>
            Gets the last token of the tree rooted by this node. Skips zero-width tokens.
            </summary>
        <returns>The last token or <c>default(SyntaxToken)</c> if it doesn't exist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeadingTrivia">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxTriviaList GetLeadingTrivia ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxTriviaList GetLeadingTrivia() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetLeadingTrivia" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeadingTrivia () As SyntaxTriviaList" />
      <MemberSignature Language="F#" Value="member this.GetLeadingTrivia : unit -&gt; Microsoft.CodeAnalysis.SyntaxTriviaList" Usage="syntaxNode.GetLeadingTrivia " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxTriviaList GetLeadingTrivia();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTriviaList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            The list of trivia that appears before this node in the source code and are attached to a token that is a
            descendant of this node.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLocation">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Location GetLocation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Location GetLocation() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetLocation" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocation () As Location" />
      <MemberSignature Language="F#" Value="member this.GetLocation : unit -&gt; Microsoft.CodeAnalysis.Location" Usage="syntaxNode.GetLocation " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Location ^ GetLocation();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Location</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRed&lt;T&gt;">
      <MemberSignature Language="C#" Value="protected T GetRed&lt;T&gt; (ref T field, int slot) where T : Microsoft.CodeAnalysis.SyntaxNode;" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance !!T GetRed&lt;(class Microsoft.CodeAnalysis.SyntaxNode) T&gt;(!!T&amp; field, int32 slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetRed``1(``0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetRed(Of T As SyntaxNode) (ByRef field As T, slot As Integer) As T" />
      <MemberSignature Language="F#" Value="member this.GetRed :  * int -&gt; 'T (requires 'T :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="syntaxNode.GetRed (field, slot)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename T&gt;&#xA; where T : Microsoft::CodeAnalysis::SyntaxNode T GetRed(T % field, int slot);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="field" Type="T" RefType="ref" />
        <Parameter Name="slot" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="field">To be added.</param>
        <param name="slot">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRedAtZero&lt;T&gt;">
      <MemberSignature Language="C#" Value="protected T GetRedAtZero&lt;T&gt; (ref T field) where T : Microsoft.CodeAnalysis.SyntaxNode;" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance !!T GetRedAtZero&lt;(class Microsoft.CodeAnalysis.SyntaxNode) T&gt;(!!T&amp; field) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetRedAtZero``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetRedAtZero(Of T As SyntaxNode) (ByRef field As T) As T" />
      <MemberSignature Language="F#" Value="member this.GetRedAtZero :  -&gt; 'T (requires 'T :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="syntaxNode.GetRedAtZero field" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename T&gt;&#xA; where T : Microsoft::CodeAnalysis::SyntaxNode T GetRedAtZero(T % field);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="field" Type="T" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="field">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReference">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxReference GetReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.SyntaxReference GetReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReference () As SyntaxReference" />
      <MemberSignature Language="F#" Value="member this.GetReference : unit -&gt; Microsoft.CodeAnalysis.SyntaxReference" Usage="syntaxNode.GetReference " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxReference ^ GetReference();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxReference</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.SyntaxReference" /> for this syntax node. CommonSyntaxReferences can be used to
            regain access to a syntax node without keeping the entire tree and source text in
            memory.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Text.SourceText GetText (System.Text.Encoding encoding = null, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm = Microsoft.CodeAnalysis.Text.SourceHashAlgorithm.Sha1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Text.SourceText GetText(class System.Text.Encoding encoding, valuetype Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetText(System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)" />
      <MemberSignature Language="F#" Value="member this.GetText : System.Text.Encoding * Microsoft.CodeAnalysis.Text.SourceHashAlgorithm -&gt; Microsoft.CodeAnalysis.Text.SourceText" Usage="syntaxNode.GetText (encoding, checksumAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Text.SourceText</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="checksumAlgorithm" Type="Microsoft.CodeAnalysis.Text.SourceHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="encoding">
            Encoding of the file that the text was read from or is going to be saved to.
            <c>null</c> if the encoding is unspecified.
            If the encoding is not specified the <see cref="T:Microsoft.CodeAnalysis.Text.SourceText" /> isn't debuggable.
            If an encoding-less <see cref="T:Microsoft.CodeAnalysis.Text.SourceText" /> is written to a file a <see cref="P:System.Text.Encoding.UTF8" /> shall be used as a default.
            </param>
        <param name="checksumAlgorithm">
            Hash algorithm to use to calculate checksum of the text that's saved to PDB.
            </param>
        <summary>
            Gets the full text of this node as an new <see cref="T:Microsoft.CodeAnalysis.Text.SourceText" /> instance.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="checksumAlgorithm" /> is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTrailingTrivia">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxTriviaList GetTrailingTrivia ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxTriviaList GetTrailingTrivia() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.GetTrailingTrivia" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTrailingTrivia () As SyntaxTriviaList" />
      <MemberSignature Language="F#" Value="member this.GetTrailingTrivia : unit -&gt; Microsoft.CodeAnalysis.SyntaxTriviaList" Usage="syntaxNode.GetTrailingTrivia " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxTriviaList GetTrailingTrivia();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTriviaList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            The list of trivia that appears after this node in the source code and are attached to a token that is a
            descendant of this node.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnnotation">
      <MemberSignature Language="C#" Value="public bool HasAnnotation (Microsoft.CodeAnalysis.SyntaxAnnotation annotation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasAnnotation(class Microsoft.CodeAnalysis.SyntaxAnnotation annotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasAnnotation (annotation As SyntaxAnnotation) As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasAnnotation : Microsoft.CodeAnalysis.SyntaxAnnotation -&gt; bool" Usage="syntaxNode.HasAnnotation annotation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasAnnotation(Microsoft::CodeAnalysis::SyntaxAnnotation ^ annotation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotation" Type="Microsoft.CodeAnalysis.SyntaxAnnotation" />
      </Parameters>
      <Docs>
        <param name="annotation">To be added.</param>
        <summary>
            Determines whether this node has the specific annotation.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnnotations">
      <MemberSignature Language="C#" Value="public bool HasAnnotations (System.Collections.Generic.IEnumerable&lt;string&gt; annotationKinds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasAnnotations(class System.Collections.Generic.IEnumerable`1&lt;string&gt; annotationKinds) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotations(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function HasAnnotations (annotationKinds As IEnumerable(Of String)) As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasAnnotations : seq&lt;string&gt; -&gt; bool" Usage="syntaxNode.HasAnnotations annotationKinds" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasAnnotations(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ annotationKinds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKinds" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="annotationKinds">To be added.</param>
        <summary>
            Determines whether this node has any annotations with any of the specific annotation kinds.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnnotations">
      <MemberSignature Language="C#" Value="public bool HasAnnotations (string annotationKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasAnnotations(string annotationKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotations(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasAnnotations (annotationKind As String) As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasAnnotations : string -&gt; bool" Usage="syntaxNode.HasAnnotations annotationKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasAnnotations(System::String ^ annotationKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKind" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="annotationKind">To be added.</param>
        <summary>
            Determines whether this node has any annotations with the specific annotation kind.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasLeadingTrivia">
      <MemberSignature Language="C#" Value="public bool HasLeadingTrivia { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasLeadingTrivia" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.HasLeadingTrivia" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasLeadingTrivia As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasLeadingTrivia : bool" Usage="Microsoft.CodeAnalysis.SyntaxNode.HasLeadingTrivia" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasLeadingTrivia { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether this node has any leading trivia.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasStructuredTrivia">
      <MemberSignature Language="C#" Value="public bool HasStructuredTrivia { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasStructuredTrivia" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.HasStructuredTrivia" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasStructuredTrivia As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasStructuredTrivia : bool" Usage="Microsoft.CodeAnalysis.SyntaxNode.HasStructuredTrivia" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasStructuredTrivia { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether a descendant trivia of this node is structured.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasTrailingTrivia">
      <MemberSignature Language="C#" Value="public bool HasTrailingTrivia { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasTrailingTrivia" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.HasTrailingTrivia" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasTrailingTrivia As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasTrailingTrivia : bool" Usage="Microsoft.CodeAnalysis.SyntaxNode.HasTrailingTrivia" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasTrailingTrivia { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether this node has any trailing trivia.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertNodesInListCore">
      <MemberSignature Language="C#" Value="protected internal abstract Microsoft.CodeAnalysis.SyntaxNode InsertNodesInListCore (Microsoft.CodeAnalysis.SyntaxNode nodeInList, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; nodesToInsert, bool insertBefore);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxNode InsertNodesInListCore(class Microsoft.CodeAnalysis.SyntaxNode nodeInList, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; nodesToInsert, bool insertBefore) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.InsertNodesInListCore(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function InsertNodesInListCore (nodeInList As SyntaxNode, nodesToInsert As IEnumerable(Of SyntaxNode), insertBefore As Boolean) As SyntaxNode" />
      <MemberSignature Language="F#" Value="abstract member InsertNodesInListCore : Microsoft.CodeAnalysis.SyntaxNode * seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; * bool -&gt; Microsoft.CodeAnalysis.SyntaxNode" Usage="syntaxNode.InsertNodesInListCore (nodeInList, nodesToInsert, insertBefore)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxNode ^ InsertNodesInListCore(Microsoft::CodeAnalysis::SyntaxNode ^ nodeInList, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ nodesToInsert, bool insertBefore);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeInList" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="nodesToInsert" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" />
        <Parameter Name="insertBefore" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nodeInList">To be added.</param>
        <param name="nodesToInsert">To be added.</param>
        <param name="insertBefore">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertTokensInListCore">
      <MemberSignature Language="C#" Value="protected internal abstract Microsoft.CodeAnalysis.SyntaxNode InsertTokensInListCore (Microsoft.CodeAnalysis.SyntaxToken originalToken, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; newTokens, bool insertBefore);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxNode InsertTokensInListCore(valuetype Microsoft.CodeAnalysis.SyntaxToken originalToken, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; newTokens, bool insertBefore) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.InsertTokensInListCore(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function InsertTokensInListCore (originalToken As SyntaxToken, newTokens As IEnumerable(Of SyntaxToken), insertBefore As Boolean) As SyntaxNode" />
      <MemberSignature Language="F#" Value="abstract member InsertTokensInListCore : Microsoft.CodeAnalysis.SyntaxToken * seq&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; * bool -&gt; Microsoft.CodeAnalysis.SyntaxNode" Usage="syntaxNode.InsertTokensInListCore (originalToken, newTokens, insertBefore)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxNode ^ InsertTokensInListCore(Microsoft::CodeAnalysis::SyntaxToken originalToken, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxToken&gt; ^ newTokens, bool insertBefore);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalToken" Type="Microsoft.CodeAnalysis.SyntaxToken" />
        <Parameter Name="newTokens" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;" />
        <Parameter Name="insertBefore" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="originalToken">To be added.</param>
        <param name="newTokens">To be added.</param>
        <param name="insertBefore">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertTriviaInListCore">
      <MemberSignature Language="C#" Value="protected internal abstract Microsoft.CodeAnalysis.SyntaxNode InsertTriviaInListCore (Microsoft.CodeAnalysis.SyntaxTrivia originalTrivia, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; newTrivia, bool insertBefore);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxNode InsertTriviaInListCore(valuetype Microsoft.CodeAnalysis.SyntaxTrivia originalTrivia, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; newTrivia, bool insertBefore) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.InsertTriviaInListCore(Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function InsertTriviaInListCore (originalTrivia As SyntaxTrivia, newTrivia As IEnumerable(Of SyntaxTrivia), insertBefore As Boolean) As SyntaxNode" />
      <MemberSignature Language="F#" Value="abstract member InsertTriviaInListCore : Microsoft.CodeAnalysis.SyntaxTrivia * seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; * bool -&gt; Microsoft.CodeAnalysis.SyntaxNode" Usage="syntaxNode.InsertTriviaInListCore (originalTrivia, newTrivia, insertBefore)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxNode ^ InsertTriviaInListCore(Microsoft::CodeAnalysis::SyntaxTrivia originalTrivia, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ newTrivia, bool insertBefore);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
        <Parameter Name="newTrivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        <Parameter Name="insertBefore" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="originalTrivia">To be added.</param>
        <param name="newTrivia">To be added.</param>
        <param name="insertBefore">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public bool IsEquivalentTo (Microsoft.CodeAnalysis.SyntaxNode other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEquivalentTo(class Microsoft.CodeAnalysis.SyntaxNode other) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEquivalentTo (other As SyntaxNode) As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsEquivalentTo : Microsoft.CodeAnalysis.SyntaxNode -&gt; bool" Usage="syntaxNode.IsEquivalentTo other" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEquivalentTo(Microsoft::CodeAnalysis::SyntaxNode ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="Microsoft.CodeAnalysis.SyntaxNode" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>
            Determine whether this node is structurally equivalent to another.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public bool IsEquivalentTo (Microsoft.CodeAnalysis.SyntaxNode node, bool topLevel = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEquivalentTo(class Microsoft.CodeAnalysis.SyntaxNode node, bool topLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEquivalentTo (node As SyntaxNode, Optional topLevel As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsEquivalentTo : Microsoft.CodeAnalysis.SyntaxNode * bool -&gt; bool" Usage="syntaxNode.IsEquivalentTo (node, topLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="topLevel" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="node">The node to compare against.</param>
        <param name="topLevel"> If true then the nodes are equivalent if the contained nodes and
            tokens declaring metadata visible symbolic information are equivalent, ignoring any
            differences of nodes inside method bodies or initializer expressions, otherwise all
            nodes and tokens must be equivalent. 
            </param>
        <summary>
            Determines if two nodes are the same, disregarding trivia differences.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentToCore">
      <MemberSignature Language="C#" Value="protected abstract bool IsEquivalentToCore (Microsoft.CodeAnalysis.SyntaxNode node, bool topLevel = false);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsEquivalentToCore(class Microsoft.CodeAnalysis.SyntaxNode node, bool topLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsEquivalentToCore (node As SyntaxNode, Optional topLevel As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentToCore : Microsoft.CodeAnalysis.SyntaxNode * bool -&gt; bool" Usage="syntaxNode.IsEquivalentToCore (node, topLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="topLevel" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="node">The node to compare against.</param>
        <param name="topLevel"> If true then the nodes are equivalent if the contained nodes and
            tokens declaring metadata visible symbolic information are equivalent, ignoring any
            differences of nodes inside method bodies or initializer expressions, otherwise all
            nodes and tokens must be equivalent. 
            </param>
        <summary>
            Determines if two nodes are the same, disregarding trivia differences.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMissing">
      <MemberSignature Language="C#" Value="public bool IsMissing { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMissing" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.IsMissing" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMissing As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsMissing : bool" Usage="Microsoft.CodeAnalysis.SyntaxNode.IsMissing" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMissing { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether the node represents a language construct that was actually parsed
            from the source code. Missing nodes are generated by the parser in error scenarios to
            represent constructs that should have been present in the source code in order to
            compile successfully but were actually missing.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPartOfStructuredTrivia">
      <MemberSignature Language="C#" Value="public bool IsPartOfStructuredTrivia ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsPartOfStructuredTrivia() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.IsPartOfStructuredTrivia" />
      <MemberSignature Language="VB.NET" Value="Public Function IsPartOfStructuredTrivia () As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsPartOfStructuredTrivia : unit -&gt; bool" Usage="syntaxNode.IsPartOfStructuredTrivia " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsPartOfStructuredTrivia();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Determines whether this node is a descendant of a structured trivia.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStructuredTrivia">
      <MemberSignature Language="C#" Value="public bool IsStructuredTrivia { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStructuredTrivia" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.IsStructuredTrivia" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStructuredTrivia As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsStructuredTrivia : bool" Usage="Microsoft.CodeAnalysis.SyntaxNode.IsStructuredTrivia" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStructuredTrivia { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether this node represents a structured trivia.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KindText">
      <MemberSignature Language="C#" Value="protected string KindText { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string KindText" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.KindText" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property KindText As String" />
      <MemberSignature Language="F#" Value="member this.KindText : string" Usage="Microsoft.CodeAnalysis.SyntaxNode.KindText" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::String ^ KindText { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public abstract string Language { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Language" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.Language" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Language As String" />
      <MemberSignature Language="F#" Value="member this.Language : string" Usage="Microsoft.CodeAnalysis.SyntaxNode.Language" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Language { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The language name that this node is syntax of.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NormalizeWhitespaceCore">
      <MemberSignature Language="C#" Value="protected internal abstract Microsoft.CodeAnalysis.SyntaxNode NormalizeWhitespaceCore (string indentation, string eol, bool elasticTrivia);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.NormalizeWhitespaceCore(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function NormalizeWhitespaceCore (indentation As String, eol As String, elasticTrivia As Boolean) As SyntaxNode" />
      <MemberSignature Language="F#" Value="abstract member NormalizeWhitespaceCore : string * string * bool -&gt; Microsoft.CodeAnalysis.SyntaxNode" Usage="syntaxNode.NormalizeWhitespaceCore (indentation, eol, elasticTrivia)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxNode ^ NormalizeWhitespaceCore(System::String ^ indentation, System::String ^ eol, bool elasticTrivia);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indentation" Type="System.String" />
        <Parameter Name="eol" Type="System.String" />
        <Parameter Name="elasticTrivia" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="indentation">To be added.</param>
        <param name="eol">To be added.</param>
        <param name="elasticTrivia">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNode Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.SyntaxNode Parent" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As SyntaxNode" />
      <MemberSignature Language="F#" Value="member this.Parent : Microsoft.CodeAnalysis.SyntaxNode" Usage="Microsoft.CodeAnalysis.SyntaxNode.Parent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::SyntaxNode ^ Parent { Microsoft::CodeAnalysis::SyntaxNode ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The node that contains this node in its <see cref="M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes" /> collection.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentTrivia">
      <MemberSignature Language="C#" Value="public virtual Microsoft.CodeAnalysis.SyntaxTrivia ParentTrivia { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.SyntaxTrivia ParentTrivia" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.ParentTrivia" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ParentTrivia As SyntaxTrivia" />
      <MemberSignature Language="F#" Value="member this.ParentTrivia : Microsoft.CodeAnalysis.SyntaxTrivia" Usage="Microsoft.CodeAnalysis.SyntaxNode.ParentTrivia" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::CodeAnalysis::SyntaxTrivia ParentTrivia { Microsoft::CodeAnalysis::SyntaxTrivia get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTrivia</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RawKind">
      <MemberSignature Language="C#" Value="public int RawKind { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RawKind" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.RawKind" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawKind As Integer" />
      <MemberSignature Language="F#" Value="member this.RawKind : int" Usage="Microsoft.CodeAnalysis.SyntaxNode.RawKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RawKind { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            An integer representing the language specific kind of this node.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveNodesCore">
      <MemberSignature Language="C#" Value="protected internal abstract Microsoft.CodeAnalysis.SyntaxNode RemoveNodesCore (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; nodes, Microsoft.CodeAnalysis.SyntaxRemoveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxNode RemoveNodesCore(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; nodes, valuetype Microsoft.CodeAnalysis.SyntaxRemoveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.RemoveNodesCore(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxRemoveOptions)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function RemoveNodesCore (nodes As IEnumerable(Of SyntaxNode), options As SyntaxRemoveOptions) As SyntaxNode" />
      <MemberSignature Language="F#" Value="abstract member RemoveNodesCore : seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; * Microsoft.CodeAnalysis.SyntaxRemoveOptions -&gt; Microsoft.CodeAnalysis.SyntaxNode" Usage="syntaxNode.RemoveNodesCore (nodes, options)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxNode ^ RemoveNodesCore(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ nodes, Microsoft::CodeAnalysis::SyntaxRemoveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodes" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" />
        <Parameter Name="options" Type="Microsoft.CodeAnalysis.SyntaxRemoveOptions" />
      </Parameters>
      <Docs>
        <param name="nodes">To be added.</param>
        <param name="options">To be added.</param>
        <summary>
            Creates a new tree of nodes with the specified node removed.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceCore&lt;TNode&gt;">
      <MemberSignature Language="C#" Value="protected internal abstract Microsoft.CodeAnalysis.SyntaxNode ReplaceCore&lt;TNode&gt; (System.Collections.Generic.IEnumerable&lt;TNode&gt; nodes = null, Func&lt;TNode,TNode,Microsoft.CodeAnalysis.SyntaxNode&gt; computeReplacementNode = null, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; tokens = null, Func&lt;Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken&gt; computeReplacementToken = null, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia = null, Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia = null) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxNode ReplaceCore&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TNode&gt; nodes, class System.Func`3&lt;!!TNode, !!TNode, class Microsoft.CodeAnalysis.SyntaxNode&gt; computeReplacementNode, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; tokens, class System.Func`3&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken, valuetype Microsoft.CodeAnalysis.SyntaxToken, valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; computeReplacementToken, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, class System.Func`3&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.ReplaceCore``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function ReplaceCore(Of TNode As SyntaxNode) (Optional nodes As IEnumerable(Of TNode) = null, Optional computeReplacementNode As Func(Of TNode, TNode, SyntaxNode) = null, Optional tokens As IEnumerable(Of SyntaxToken) = null, Optional computeReplacementToken As Func(Of SyntaxToken, SyntaxToken, SyntaxToken) = null, Optional trivia As IEnumerable(Of SyntaxTrivia) = null, Optional computeReplacementTrivia As Func(Of SyntaxTrivia, SyntaxTrivia, SyntaxTrivia) = null) As SyntaxNode" />
      <MemberSignature Language="F#" Value="abstract member ReplaceCore : seq&lt;'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; * Func&lt;'Node, 'Node, Microsoft.CodeAnalysis.SyntaxNode (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode and 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; * seq&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; * Func&lt;Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken&gt; * seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; * Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; Microsoft.CodeAnalysis.SyntaxNode (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="syntaxNode.ReplaceCore (nodes, computeReplacementNode, tokens, computeReplacementToken, trivia, computeReplacementTrivia)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNode">
          <Constraints>
            <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="nodes" Type="System.Collections.Generic.IEnumerable&lt;TNode&gt;" />
        <Parameter Name="computeReplacementNode" Type="System.Func&lt;TNode,TNode,Microsoft.CodeAnalysis.SyntaxNode&gt;" />
        <Parameter Name="tokens" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;" />
        <Parameter Name="computeReplacementToken" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken&gt;" />
        <Parameter Name="trivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        <Parameter Name="computeReplacementTrivia" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TNode">To be added.</typeparam>
        <param name="nodes">To be added.</param>
        <param name="computeReplacementNode">To be added.</param>
        <param name="tokens">To be added.</param>
        <param name="computeReplacementToken">To be added.</param>
        <param name="trivia">To be added.</param>
        <param name="computeReplacementTrivia">To be added.</param>
        <summary>
            Creates a new tree of nodes with the specified nodes, tokens or trivia replaced.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceNodeInListCore">
      <MemberSignature Language="C#" Value="protected internal abstract Microsoft.CodeAnalysis.SyntaxNode ReplaceNodeInListCore (Microsoft.CodeAnalysis.SyntaxNode originalNode, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; replacementNodes);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxNode ReplaceNodeInListCore(class Microsoft.CodeAnalysis.SyntaxNode originalNode, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; replacementNodes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.ReplaceNodeInListCore(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function ReplaceNodeInListCore (originalNode As SyntaxNode, replacementNodes As IEnumerable(Of SyntaxNode)) As SyntaxNode" />
      <MemberSignature Language="F#" Value="abstract member ReplaceNodeInListCore : Microsoft.CodeAnalysis.SyntaxNode * seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; -&gt; Microsoft.CodeAnalysis.SyntaxNode" Usage="syntaxNode.ReplaceNodeInListCore (originalNode, replacementNodes)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxNode ^ ReplaceNodeInListCore(Microsoft::CodeAnalysis::SyntaxNode ^ originalNode, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ replacementNodes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalNode" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="replacementNodes" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" />
      </Parameters>
      <Docs>
        <param name="originalNode">To be added.</param>
        <param name="replacementNodes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceTokenInListCore">
      <MemberSignature Language="C#" Value="protected internal abstract Microsoft.CodeAnalysis.SyntaxNode ReplaceTokenInListCore (Microsoft.CodeAnalysis.SyntaxToken originalToken, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; newTokens);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxNode ReplaceTokenInListCore(valuetype Microsoft.CodeAnalysis.SyntaxToken originalToken, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; newTokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.ReplaceTokenInListCore(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function ReplaceTokenInListCore (originalToken As SyntaxToken, newTokens As IEnumerable(Of SyntaxToken)) As SyntaxNode" />
      <MemberSignature Language="F#" Value="abstract member ReplaceTokenInListCore : Microsoft.CodeAnalysis.SyntaxToken * seq&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; -&gt; Microsoft.CodeAnalysis.SyntaxNode" Usage="syntaxNode.ReplaceTokenInListCore (originalToken, newTokens)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxNode ^ ReplaceTokenInListCore(Microsoft::CodeAnalysis::SyntaxToken originalToken, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxToken&gt; ^ newTokens);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalToken" Type="Microsoft.CodeAnalysis.SyntaxToken" />
        <Parameter Name="newTokens" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;" />
      </Parameters>
      <Docs>
        <param name="originalToken">To be added.</param>
        <param name="newTokens">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceTriviaInListCore">
      <MemberSignature Language="C#" Value="protected internal abstract Microsoft.CodeAnalysis.SyntaxNode ReplaceTriviaInListCore (Microsoft.CodeAnalysis.SyntaxTrivia originalTrivia, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; newTrivia);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxNode ReplaceTriviaInListCore(valuetype Microsoft.CodeAnalysis.SyntaxTrivia originalTrivia, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; newTrivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.ReplaceTriviaInListCore(Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function ReplaceTriviaInListCore (originalTrivia As SyntaxTrivia, newTrivia As IEnumerable(Of SyntaxTrivia)) As SyntaxNode" />
      <MemberSignature Language="F#" Value="abstract member ReplaceTriviaInListCore : Microsoft.CodeAnalysis.SyntaxTrivia * seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; Microsoft.CodeAnalysis.SyntaxNode" Usage="syntaxNode.ReplaceTriviaInListCore (originalTrivia, newTrivia)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxNode ^ ReplaceTriviaInListCore(Microsoft::CodeAnalysis::SyntaxTrivia originalTrivia, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ newTrivia);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
        <Parameter Name="newTrivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
      </Parameters>
      <Docs>
        <param name="originalTrivia">To be added.</param>
        <param name="newTrivia">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializeTo">
      <MemberSignature Language="C#" Value="public virtual void SerializeTo (System.IO.Stream stream, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SerializeTo(class System.IO.Stream stream, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.SerializeTo(System.IO.Stream,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member SerializeTo : System.IO.Stream * System.Threading.CancellationToken -&gt; unit&#xA;override this.SerializeTo : System.IO.Stream * System.Threading.CancellationToken -&gt; unit" Usage="syntaxNode.SerializeTo (stream, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="stream">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Span">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Text.TextSpan Span { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.Text.TextSpan Span" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.Span" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Span As TextSpan" />
      <MemberSignature Language="F#" Value="member this.Span : Microsoft.CodeAnalysis.Text.TextSpan" Usage="Microsoft.CodeAnalysis.SyntaxNode.Span" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::Text::TextSpan Span { Microsoft::CodeAnalysis::Text::TextSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Text.TextSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The absolute span of this node in characters, not including its leading and trailing trivia.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SpanStart">
      <MemberSignature Language="C#" Value="public int SpanStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SpanStart" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.SpanStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SpanStart As Integer" />
      <MemberSignature Language="F#" Value="member this.SpanStart : int" Usage="Microsoft.CodeAnalysis.SyntaxNode.SpanStart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SpanStart { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Same as accessing <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.Start" /> on <see cref="P:Microsoft.CodeAnalysis.SyntaxNode.Span" />.
            </summary>
        <value>To be added.</value>
        <remarks>
            Slight performance improvement.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyntaxTree">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxTree SyntaxTree { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.SyntaxTree SyntaxTree" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.SyntaxTree" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyntaxTree As SyntaxTree" />
      <MemberSignature Language="F#" Value="member this.SyntaxTree : Microsoft.CodeAnalysis.SyntaxTree" Usage="Microsoft.CodeAnalysis.SyntaxNode.SyntaxTree" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::SyntaxTree ^ SyntaxTree { Microsoft::CodeAnalysis::SyntaxTree ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTree</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns SyntaxTree that owns the node or null if node does not belong to a
            SyntaxTree
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SyntaxTreeCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.SyntaxTree SyntaxTreeCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.SyntaxTree SyntaxTreeCore" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNode.SyntaxTreeCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property SyntaxTreeCore As SyntaxTree" />
      <MemberSignature Language="F#" Value="member this.SyntaxTreeCore : Microsoft.CodeAnalysis.SyntaxTree" Usage="Microsoft.CodeAnalysis.SyntaxNode.SyntaxTreeCore" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property Microsoft::CodeAnalysis::SyntaxTree ^ SyntaxTreeCore { Microsoft::CodeAnalysis::SyntaxTree ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTree</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns SyntaxTree that owns the node or null if node does not belong to a
            SyntaxTree
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToFullString">
      <MemberSignature Language="C#" Value="public virtual string ToFullString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToFullString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.ToFullString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToFullString () As String" />
      <MemberSignature Language="F#" Value="abstract member ToFullString : unit -&gt; string&#xA;override this.ToFullString : unit -&gt; string" Usage="syntaxNode.ToFullString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToFullString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns full string representation of this node including its leading and trailing trivia.
            </summary>
        <returns>The full string representation of this node including its leading and trailing trivia.</returns>
        <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="syntaxNode.ToString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns the string representation of this node, not including its leading and trailing trivia.
            </summary>
        <returns>The string representation of this node, not including its leading and trailing trivia.</returns>
        <remarks>The length of the returned string is always the same as Span.Length</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public virtual void WriteTo (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNode.WriteTo(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteTo (writer As TextWriter)" />
      <MemberSignature Language="F#" Value="abstract member WriteTo : System.IO.TextWriter -&gt; unit&#xA;override this.WriteTo : System.IO.TextWriter -&gt; unit" Usage="syntaxNode.WriteTo writer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteTo(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <summary>
            Writes the full text of this node to the specified <see cref="T:System.IO.TextWriter" />.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>