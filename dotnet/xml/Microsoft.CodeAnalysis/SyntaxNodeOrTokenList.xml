<Type Name="SyntaxNodeOrTokenList" FullName="Microsoft.CodeAnalysis.SyntaxNodeOrTokenList">
  <TypeSignature Language="C#" Value="public struct SyntaxNodeOrTokenList : IEquatable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrTokenList&gt;, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;, System.Collections.Generic.IReadOnlyCollection&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit SyntaxNodeOrTokenList extends System.ValueType implements class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;, class System.Collections.IEnumerable, class System.IEquatable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList&gt;" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" />
  <TypeSignature Language="VB.NET" Value="Public Structure SyntaxNodeOrTokenList&#xA;Implements IEnumerable(Of SyntaxNodeOrToken), IEquatable(Of SyntaxNodeOrTokenList), IReadOnlyCollection(Of SyntaxNodeOrToken)" />
  <TypeSignature Language="F#" Value="type SyntaxNodeOrTokenList = struct&#xA;    interface IReadOnlyCollection&lt;SyntaxNodeOrToken&gt;&#xA;    interface seq&lt;SyntaxNodeOrToken&gt;&#xA;    interface IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public value class SyntaxNodeOrTokenList : IEquatable&lt;Microsoft::CodeAnalysis::SyntaxNodeOrTokenList&gt;, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNodeOrToken&gt;, System::Collections::Generic::IReadOnlyCollection&lt;Microsoft::CodeAnalysis::SyntaxNodeOrToken&gt;" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
    <AssemblyVersion>2.9.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrTokenList&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
            A list of <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> structures.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SyntaxNodeOrTokenList (params Microsoft.CodeAnalysis.SyntaxNodeOrToken[] nodesAndTokens);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken[] nodesAndTokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.#ctor(Microsoft.CodeAnalysis.SyntaxNodeOrToken[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ParamArray nodesAndTokens As SyntaxNodeOrToken())" />
      <MemberSignature Language="F#" Value="new Microsoft.CodeAnalysis.SyntaxNodeOrTokenList : Microsoft.CodeAnalysis.SyntaxNodeOrToken[] -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" Usage="new Microsoft.CodeAnalysis.SyntaxNodeOrTokenList nodesAndTokens" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SyntaxNodeOrTokenList(... cli::array &lt;Microsoft::CodeAnalysis::SyntaxNodeOrToken&gt; ^ nodesAndTokens);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nodesAndTokens" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="nodesAndTokens">The nodes and tokens</param>
        <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" /> from one or more <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SyntaxNodeOrTokenList (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; nodesAndTokens);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; nodesAndTokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.#ctor(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (nodesAndTokens As IEnumerable(Of SyntaxNodeOrToken))" />
      <MemberSignature Language="F#" Value="new Microsoft.CodeAnalysis.SyntaxNodeOrTokenList : seq&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" Usage="new Microsoft.CodeAnalysis.SyntaxNodeOrTokenList nodesAndTokens" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SyntaxNodeOrTokenList(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNodeOrToken&gt; ^ nodesAndTokens);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nodesAndTokens" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;" />
      </Parameters>
      <Docs>
        <param name="nodesAndTokens">The sequence of nodes and tokens</param>
        <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" /> from a sequence of <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList Add (Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList Add(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Add(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (nodeOrToken As SyntaxNodeOrToken) As SyntaxNodeOrTokenList" />
      <MemberSignature Language="F#" Value="member this.Add : Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" Usage="syntaxNodeOrTokenList.Add nodeOrToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrTokenList Add(Microsoft::CodeAnalysis::SyntaxNodeOrToken nodeOrToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrTokenList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Parameters>
      <Docs>
        <param name="nodeOrToken">The node or token to add.</param>
        <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" /> with the specified node or token added to the end.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList AddRange (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; nodesOrTokens);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList AddRange(class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; nodesOrTokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.AddRange(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddRange (nodesOrTokens As IEnumerable(Of SyntaxNodeOrToken)) As SyntaxNodeOrTokenList" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" Usage="syntaxNodeOrTokenList.AddRange nodesOrTokens" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrTokenList AddRange(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNodeOrToken&gt; ^ nodesOrTokens);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrTokenList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodesOrTokens" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;" />
      </Parameters>
      <Docs>
        <param name="nodesOrTokens">The nodes or tokens to add.</param>
        <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" /> with the specified nodes or tokens added to the end.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public bool Any ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Any() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Any" />
      <MemberSignature Language="VB.NET" Value="Public Function Any () As Boolean" />
      <MemberSignature Language="F#" Value="member this.Any : unit -&gt; bool" Usage="syntaxNodeOrTokenList.Any " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Any();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Indicates whether there is any element in the list.
            </summary>
        <returns>
          <c>true</c> if there are any elements in the list, else <c>false</c>.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Count" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the count of nodes in this list
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (Microsoft.CodeAnalysis.SyntaxNodeOrTokenList other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList other) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Equals(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As SyntaxNodeOrTokenList) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : Microsoft.CodeAnalysis.SyntaxNodeOrTokenList -&gt; bool" Usage="syntaxNodeOrTokenList.Equals other" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Microsoft::CodeAnalysis::SyntaxNodeOrTokenList other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" />
      </Parameters>
      <Docs>
        <param name="other">An object to compare with this object.</param>
        <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
        <returns>
          <c>true</c> if the current object is equal to the <paramref name="other" /> parameter; otherwise,
            <c>false</c>.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="syntaxNodeOrTokenList.Equals obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
        <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
        <returns>
          <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="First">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken First ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken First() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.First" />
      <MemberSignature Language="VB.NET" Value="Public Function First () As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.First : unit -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrTokenList.First " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken First();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets the first SyntaxNodeOrToken structure from this list.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken FirstOrDefault ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken FirstOrDefault() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.FirstOrDefault" />
      <MemberSignature Language="VB.NET" Value="Public Function FirstOrDefault () As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.FirstOrDefault : unit -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrTokenList.FirstOrDefault " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken FirstOrDefault();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets the first SyntaxNodeOrToken structure from this list if present, else default(SyntaxNodeOrToken).
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullSpan">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Text.TextSpan FullSpan { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.Text.TextSpan FullSpan" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.FullSpan" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FullSpan As TextSpan" />
      <MemberSignature Language="F#" Value="member this.FullSpan : Microsoft.CodeAnalysis.Text.TextSpan" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.FullSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::Text::TextSpan FullSpan { Microsoft::CodeAnalysis::Text::TextSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Text.TextSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The absolute span of the list elements in characters, including the leading and trailing trivia of the first and last elements.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList/Enumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As SyntaxNodeOrTokenList.Enumerator" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator" Usage="syntaxNodeOrTokenList.GetEnumerator " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrTokenList::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrTokenList+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets the enumerator.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="syntaxNodeOrTokenList.GetHashCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns a hash code for this instance.
            </summary>
        <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.IndexOf(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (nodeOrToken As SyntaxNodeOrToken) As Integer" />
      <MemberSignature Language="F#" Value="member this.IndexOf : Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; int" Usage="syntaxNodeOrTokenList.IndexOf nodeOrToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(Microsoft::CodeAnalysis::SyntaxNodeOrToken nodeOrToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Parameters>
      <Docs>
        <param name="nodeOrToken">The node or token to search for in the list.</param>
        <summary>
            Returns the index from the list for the given <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />.
            </summary>
        <returns>The index of the found nodeOrToken, or -1 if it wasn't found</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList Insert (int index, Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList Insert(int32 index, valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Insert(System.Int32,Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, nodeOrToken As SyntaxNodeOrToken) As SyntaxNodeOrTokenList" />
      <MemberSignature Language="F#" Value="member this.Insert : int * Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" Usage="syntaxNodeOrTokenList.Insert (index, nodeOrToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrTokenList Insert(int index, Microsoft::CodeAnalysis::SyntaxNodeOrToken nodeOrToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrTokenList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Parameters>
      <Docs>
        <param name="index">The index to insert at.</param>
        <param name="nodeOrToken">The node or token to insert.</param>
        <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" /> with the specified node or token inserted at the index.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList InsertRange (int index, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; nodesAndTokens);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; nodesAndTokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertRange (index As Integer, nodesAndTokens As IEnumerable(Of SyntaxNodeOrToken)) As SyntaxNodeOrTokenList" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" Usage="syntaxNodeOrTokenList.InsertRange (index, nodesAndTokens)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrTokenList InsertRange(int index, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNodeOrToken&gt; ^ nodesAndTokens);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrTokenList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="nodesAndTokens" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;" />
      </Parameters>
      <Docs>
        <param name="index">The index to insert at.</param>
        <param name="nodesAndTokens">The nodes or tokens to insert.</param>
        <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" /> with the specified nodes or tokens inserted at the index.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken Item(int32)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.Item(int) : Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Item" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::SyntaxNodeOrToken default[int] { Microsoft::CodeAnalysis::SyntaxNodeOrToken get(int index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> at the specified index. 
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> is out of range.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken Last ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken Last() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Last" />
      <MemberSignature Language="VB.NET" Value="Public Function Last () As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.Last : unit -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrTokenList.Last " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken Last();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets the last SyntaxNodeOrToken structure from this list.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken LastOrDefault ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken LastOrDefault() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.LastOrDefault" />
      <MemberSignature Language="VB.NET" Value="Public Function LastOrDefault () As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.LastOrDefault : unit -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrTokenList.LastOrDefault " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken LastOrDefault();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets the last SyntaxNodeOrToken structure from this list if present, else default(SyntaxNodeOrToken).
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Microsoft.CodeAnalysis.SyntaxNodeOrTokenList left, Microsoft.CodeAnalysis.SyntaxNodeOrTokenList right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList left, valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList right) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.op_Equality(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList,Microsoft.CodeAnalysis.SyntaxNodeOrTokenList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As SyntaxNodeOrTokenList, right As SyntaxNodeOrTokenList) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( = ) : Microsoft.CodeAnalysis.SyntaxNodeOrTokenList * Microsoft.CodeAnalysis.SyntaxNodeOrTokenList -&gt; bool" Usage="left = right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Microsoft::CodeAnalysis::SyntaxNodeOrTokenList left, Microsoft::CodeAnalysis::SyntaxNodeOrTokenList right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" />
        <Parameter Name="right" Type="Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" />
      </Parameters>
      <Docs>
        <param name="left">The left SyntaxNodeOrTokenList</param>
        <param name="right">The right SyntaxNodeOrTokenList</param>
        <summary>
            Implements the operator ==.
            </summary>
        <returns>
          <c>true</c> if both lists equal, else <c>false</c>.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Microsoft.CodeAnalysis.SyntaxNodeOrTokenList left, Microsoft.CodeAnalysis.SyntaxNodeOrTokenList right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList left, valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList right) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.op_Inequality(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList,Microsoft.CodeAnalysis.SyntaxNodeOrTokenList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As SyntaxNodeOrTokenList, right As SyntaxNodeOrTokenList) As Boolean" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Microsoft.CodeAnalysis.SyntaxNodeOrTokenList * Microsoft.CodeAnalysis.SyntaxNodeOrTokenList -&gt; bool" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.op_Inequality (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Microsoft::CodeAnalysis::SyntaxNodeOrTokenList left, Microsoft::CodeAnalysis::SyntaxNodeOrTokenList right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" />
        <Parameter Name="right" Type="Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" />
      </Parameters>
      <Docs>
        <param name="left">The left SyntaxNodeOrTokenList</param>
        <param name="right">The right SyntaxNodeOrTokenList</param>
        <summary>
            Implements the operator !=.
            </summary>
        <returns>
          <c>true</c> if both lists not equal, else <c>false</c>.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList Remove (Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrTokenInList);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList Remove(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrTokenInList) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Remove(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (nodeOrTokenInList As SyntaxNodeOrToken) As SyntaxNodeOrTokenList" />
      <MemberSignature Language="F#" Value="member this.Remove : Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" Usage="syntaxNodeOrTokenList.Remove nodeOrTokenInList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrTokenList Remove(Microsoft::CodeAnalysis::SyntaxNodeOrToken nodeOrTokenInList);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrTokenList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeOrTokenInList" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Parameters>
      <Docs>
        <param name="nodeOrTokenInList">The element to remove.</param>
        <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" /> with the specified element removed.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAt (index As Integer) As SyntaxNodeOrTokenList" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" Usage="syntaxNodeOrTokenList.RemoveAt index" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrTokenList RemoveAt(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrTokenList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The index of the element to remove.</param>
        <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" /> with the element at the specified index removed.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList Replace (Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrTokenInList, Microsoft.CodeAnalysis.SyntaxNodeOrToken newNodeOrToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList Replace(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrTokenInList, valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken newNodeOrToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Replace(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (nodeOrTokenInList As SyntaxNodeOrToken, newNodeOrToken As SyntaxNodeOrToken) As SyntaxNodeOrTokenList" />
      <MemberSignature Language="F#" Value="member this.Replace : Microsoft.CodeAnalysis.SyntaxNodeOrToken * Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" Usage="syntaxNodeOrTokenList.Replace (nodeOrTokenInList, newNodeOrToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrTokenList Replace(Microsoft::CodeAnalysis::SyntaxNodeOrToken nodeOrTokenInList, Microsoft::CodeAnalysis::SyntaxNodeOrToken newNodeOrToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrTokenList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeOrTokenInList" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
        <Parameter Name="newNodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Parameters>
      <Docs>
        <param name="nodeOrTokenInList">The element to replace.</param>
        <param name="newNodeOrToken">The new node or token.</param>
        <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" /> with the specified element replaced with a new node or token.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceRange">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList ReplaceRange (Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrTokenInList, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; newNodesAndTokens);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrTokenList ReplaceRange(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrTokenInList, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; newNodesAndTokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.ReplaceRange(Microsoft.CodeAnalysis.SyntaxNodeOrToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReplaceRange (nodeOrTokenInList As SyntaxNodeOrToken, newNodesAndTokens As IEnumerable(Of SyntaxNodeOrToken)) As SyntaxNodeOrTokenList" />
      <MemberSignature Language="F#" Value="member this.ReplaceRange : Microsoft.CodeAnalysis.SyntaxNodeOrToken * seq&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" Usage="syntaxNodeOrTokenList.ReplaceRange (nodeOrTokenInList, newNodesAndTokens)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrTokenList ReplaceRange(Microsoft::CodeAnalysis::SyntaxNodeOrToken nodeOrTokenInList, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNodeOrToken&gt; ^ newNodesAndTokens);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrTokenList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeOrTokenInList" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
        <Parameter Name="newNodesAndTokens" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;" />
      </Parameters>
      <Docs>
        <param name="nodeOrTokenInList">The element to replace.</param>
        <param name="newNodesAndTokens">The new nodes and tokens.</param>
        <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList" /> with the specified element replaced with a new nodes and tokens.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Span">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Text.TextSpan Span { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.Text.TextSpan Span" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Span" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Span As TextSpan" />
      <MemberSignature Language="F#" Value="member this.Span : Microsoft.CodeAnalysis.Text.TextSpan" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Span" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::Text::TextSpan Span { Microsoft::CodeAnalysis::Text::TextSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Text.TextSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The absolute span of the list elements in characters, not including the leading and trailing trivia of the first and last elements.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; IEnumerable&lt;SyntaxNodeOrToken&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt; System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.System#Collections#Generic#IEnumerable&lt;Microsoft#CodeAnalysis#SyntaxNodeOrToken&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of SyntaxNodeOrToken) Implements IEnumerable(Of SyntaxNodeOrToken).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;Microsoft::CodeAnalysis::SyntaxNodeOrToken&gt; ^ System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNodeOrToken&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
        <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
        <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToFullString">
      <MemberSignature Language="C#" Value="public string ToFullString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToFullString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.ToFullString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToFullString () As String" />
      <MemberSignature Language="F#" Value="member this.ToFullString : unit -&gt; string" Usage="syntaxNodeOrTokenList.ToFullString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToFullString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns the full string representation of the nodes and tokens in this list including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </summary>
        <returns>
            The full string representation of the nodes and tokens in this list including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="syntaxNodeOrTokenList.ToString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns the string representation of the nodes and tokens in this list, not including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </summary>
        <returns>
            The string representation of the nodes and tokens in this list, not including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>