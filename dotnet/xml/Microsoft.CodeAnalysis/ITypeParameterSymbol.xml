<Type Name="ITypeParameterSymbol" FullName="Microsoft.CodeAnalysis.ITypeParameterSymbol">
  <TypeSignature Language="C#" Value="public interface ITypeParameterSymbol : IEquatable&lt;Microsoft.CodeAnalysis.ISymbol&gt;, Microsoft.CodeAnalysis.ITypeSymbol" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ITypeParameterSymbol implements class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol, class Microsoft.CodeAnalysis.ISymbol, class Microsoft.CodeAnalysis.ITypeSymbol, class System.IEquatable`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt;" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.ITypeParameterSymbol" />
  <TypeSignature Language="VB.NET" Value="Public Interface ITypeParameterSymbol&#xA;Implements IEquatable(Of ISymbol), ITypeSymbol" />
  <TypeSignature Language="F#" Value="type ITypeParameterSymbol = interface&#xA;    interface ITypeSymbol&#xA;    interface INamespaceOrTypeSymbol&#xA;    interface ISymbol&#xA;    interface IEquatable&lt;ISymbol&gt;" />
  <TypeSignature Language="C++ CLI" Value="public interface class ITypeParameterSymbol : IEquatable&lt;Microsoft::CodeAnalysis::ISymbol ^&gt;, Microsoft::CodeAnalysis::ITypeSymbol" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
    <AssemblyVersion>2.6.0.0</AssemblyVersion>
    <AssemblyVersion>2.9.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.CodeAnalysis.ITypeSymbol</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;Microsoft.CodeAnalysis.ISymbol&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
            Represents a type parameter in a generic type or generic method.
            </summary>
    <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
  </Docs>
  <Members>
    <Member MemberName="ConstraintTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; ConstraintTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ITypeSymbol&gt; ConstraintTypes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.ConstraintTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConstraintTypes As ImmutableArray(Of ITypeSymbol)" />
      <MemberSignature Language="F#" Value="member this.ConstraintTypes : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt;" Usage="Microsoft.CodeAnalysis.ITypeParameterSymbol.ConstraintTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ITypeSymbol ^&gt; ConstraintTypes { System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ITypeSymbol ^&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The types that were directly specified as constraints on the type parameter.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.IMethodSymbol DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.IMethodSymbol DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringMethod As IMethodSymbol" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : Microsoft.CodeAnalysis.IMethodSymbol" Usage="Microsoft.CodeAnalysis.ITypeParameterSymbol.DeclaringMethod" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::IMethodSymbol ^ DeclaringMethod { Microsoft::CodeAnalysis::IMethodSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The method that declares the type parameter, or null.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamedTypeSymbol DeclaringType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.ITypeParameterSymbol.DeclaringType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::INamedTypeSymbol ^ DeclaringType { Microsoft::CodeAnalysis::INamedTypeSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The type that declares the type parameter, or null.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasConstructorConstraint">
      <MemberSignature Language="C#" Value="public bool HasConstructorConstraint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasConstructorConstraint" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasConstructorConstraint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasConstructorConstraint As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasConstructorConstraint : bool" Usage="Microsoft.CodeAnalysis.ITypeParameterSymbol.HasConstructorConstraint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasConstructorConstraint { bool get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property bool HasConstructorConstraint { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            True if the parameterless constructor constraint (<c>new()</c>) was specified for the type parameter.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasReferenceTypeConstraint">
      <MemberSignature Language="C#" Value="public bool HasReferenceTypeConstraint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasReferenceTypeConstraint" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasReferenceTypeConstraint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasReferenceTypeConstraint As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasReferenceTypeConstraint : bool" Usage="Microsoft.CodeAnalysis.ITypeParameterSymbol.HasReferenceTypeConstraint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasReferenceTypeConstraint { bool get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property bool HasReferenceTypeConstraint { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            True if the reference type constraint (<c>class</c>) was specified for the type parameter.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasUnmanagedTypeConstraint">
      <MemberSignature Language="C#" Value="public bool HasUnmanagedTypeConstraint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasUnmanagedTypeConstraint" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasUnmanagedTypeConstraint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasUnmanagedTypeConstraint As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasUnmanagedTypeConstraint : bool" Usage="Microsoft.CodeAnalysis.ITypeParameterSymbol.HasUnmanagedTypeConstraint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            True if the value type constraint (<c>unmanaged</c>) was specified for the type parameter.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValueTypeConstraint">
      <MemberSignature Language="C#" Value="public bool HasValueTypeConstraint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValueTypeConstraint" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasValueTypeConstraint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValueTypeConstraint As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasValueTypeConstraint : bool" Usage="Microsoft.CodeAnalysis.ITypeParameterSymbol.HasValueTypeConstraint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValueTypeConstraint { bool get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property bool HasValueTypeConstraint { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            True if the value type constraint (<c>struct</c>) was specified for the type parameter.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ordinal">
      <MemberSignature Language="C#" Value="public int Ordinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Ordinal" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.Ordinal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Ordinal As Integer" />
      <MemberSignature Language="F#" Value="member this.Ordinal : int" Usage="Microsoft.CodeAnalysis.ITypeParameterSymbol.Ordinal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Ordinal { int get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property int Ordinal { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The ordinal position of the type parameter in the parameter list which declares
            it. The first type parameter has ordinal zero.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalDefinition">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.ITypeParameterSymbol OriginalDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.ITypeParameterSymbol OriginalDefinition" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.OriginalDefinition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalDefinition As ITypeParameterSymbol" />
      <MemberSignature Language="F#" Value="member this.OriginalDefinition : Microsoft.CodeAnalysis.ITypeParameterSymbol" Usage="Microsoft.CodeAnalysis.ITypeParameterSymbol.OriginalDefinition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::ITypeParameterSymbol ^ OriginalDefinition { Microsoft::CodeAnalysis::ITypeParameterSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ITypeParameterSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Get the original definition of this type symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReducedFrom">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.ITypeParameterSymbol ReducedFrom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.ITypeParameterSymbol ReducedFrom" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.ReducedFrom" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReducedFrom As ITypeParameterSymbol" />
      <MemberSignature Language="F#" Value="member this.ReducedFrom : Microsoft.CodeAnalysis.ITypeParameterSymbol" Usage="Microsoft.CodeAnalysis.ITypeParameterSymbol.ReducedFrom" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::ITypeParameterSymbol ^ ReducedFrom { Microsoft::CodeAnalysis::ITypeParameterSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ITypeParameterSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            If this is a type parameter of a reduced extension method, gets the type parameter definition that
            this type parameter was reduced from. Otherwise, returns Nothing.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeParameterKind">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.TypeParameterKind TypeParameterKind { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.TypeParameterKind TypeParameterKind" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.TypeParameterKind" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeParameterKind As TypeParameterKind" />
      <MemberSignature Language="F#" Value="member this.TypeParameterKind : Microsoft.CodeAnalysis.TypeParameterKind" Usage="Microsoft.CodeAnalysis.ITypeParameterSymbol.TypeParameterKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::TypeParameterKind TypeParameterKind { Microsoft::CodeAnalysis::TypeParameterKind get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property Microsoft::CodeAnalysis::TypeParameterKind TypeParameterKind { Microsoft::CodeAnalysis::TypeParameterKind get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.TypeParameterKind</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The type parameter kind of this type parameter.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variance">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.VarianceKind Variance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.VarianceKind Variance" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.Variance" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Variance As VarianceKind" />
      <MemberSignature Language="F#" Value="member this.Variance : Microsoft.CodeAnalysis.VarianceKind" Usage="Microsoft.CodeAnalysis.ITypeParameterSymbol.Variance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::VarianceKind Variance { Microsoft::CodeAnalysis::VarianceKind get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property Microsoft::CodeAnalysis::VarianceKind Variance { Microsoft::CodeAnalysis::VarianceKind get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.VarianceKind</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The variance annotation, if any, of the type parameter declaration. Type parameters may be 
            declared as covariant (<c>out</c>), contravariant (<c>in</c>), or neither.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>