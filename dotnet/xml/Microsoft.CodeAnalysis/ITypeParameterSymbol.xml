<Type Name="ITypeParameterSymbol" FullName="Microsoft.CodeAnalysis.ITypeParameterSymbol">
  <TypeSignature Language="C#" Value="public interface ITypeParameterSymbol : IEquatable&lt;Microsoft.CodeAnalysis.ISymbol&gt;, Microsoft.CodeAnalysis.ITypeSymbol" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ITypeParameterSymbol implements class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol, class Microsoft.CodeAnalysis.ISymbol, class Microsoft.CodeAnalysis.ITypeSymbol, class System.IEquatable`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt;" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.ITypeParameterSymbol" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
    <AssemblyVersion>2.4.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.CodeAnalysis.ITypeSymbol</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;Microsoft.CodeAnalysis.ISymbol&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
            Represents a type parameter in a generic type or generic method.
            </summary>
    <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
  </Docs>
  <Members>
    <Member MemberName="ConstraintTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; ConstraintTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ITypeSymbol&gt; ConstraintTypes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.ConstraintTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The types that were directly specified as constraints on the type parameter.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.IMethodSymbol DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.IMethodSymbol DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The method that declares the type parameter, or null.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.INamedTypeSymbol DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamedTypeSymbol DeclaringType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The type that declares the type parameter, or null.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasConstructorConstraint">
      <MemberSignature Language="C#" Value="public bool HasConstructorConstraint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasConstructorConstraint" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasConstructorConstraint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            True if the parameterless constructor constraint (<c>new()</c>) was specified for the type parameter.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasReferenceTypeConstraint">
      <MemberSignature Language="C#" Value="public bool HasReferenceTypeConstraint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasReferenceTypeConstraint" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasReferenceTypeConstraint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            True if the reference type constraint (<c>class</c>) was specified for the type parameter.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValueTypeConstraint">
      <MemberSignature Language="C#" Value="public bool HasValueTypeConstraint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValueTypeConstraint" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.HasValueTypeConstraint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            True if the value type constraint (<c>struct</c>)was specified for the type parameter.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ordinal">
      <MemberSignature Language="C#" Value="public int Ordinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Ordinal" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.Ordinal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The ordinal position of the type parameter in the parameter list which declares
            it. The first type parameter has ordinal zero.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalDefinition">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.ITypeParameterSymbol OriginalDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.ITypeParameterSymbol OriginalDefinition" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.OriginalDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ITypeParameterSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Get the original definition of this type symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReducedFrom">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.ITypeParameterSymbol ReducedFrom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.ITypeParameterSymbol ReducedFrom" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.ReducedFrom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ITypeParameterSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            If this is a type parameter of a reduced extension method, gets the type parameter definition that
            this type parameter was reduced from. Otherwise, returns Nothing.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeParameterKind">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.TypeParameterKind TypeParameterKind { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.TypeParameterKind TypeParameterKind" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.TypeParameterKind" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.TypeParameterKind</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The type parameter kind of this type parameter.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variance">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.VarianceKind Variance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.VarianceKind Variance" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.ITypeParameterSymbol.Variance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.VarianceKind</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The variance annotation, if any, of the type parameter declaration. Type parameters may be 
            declared as covariant (<c>out</c>), contravariant (<c>in</c>), or neither.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>