<Type Name="SemanticModel" FullName="Microsoft.CodeAnalysis.SemanticModel">
  <TypeSignature Language="C#" Value="public abstract class SemanticModel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SemanticModel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.SemanticModel" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SemanticModel" />
  <TypeSignature Language="F#" Value="type SemanticModel = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemanticModel abstract" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
    <AssemblyVersion>2.9.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,
            an instance is obtained by a call to GetBinding on a Compilation or Compilation.
            </summary>
    <remarks>
      <para>An instance of SemanticModel caches local symbols and semantic information. Thus, it
            is much more efficient to use a single instance of SemanticModel when asking multiple
            questions about a syntax tree, because information from the first question may be reused.
            This also means that holding onto an instance of SemanticModel for a long time may keep a
            significant amount of memory from being garbage collected.
            </para>
      <para>
            When an answer is a named symbol that is reachable by traversing from the root of the symbol
            table, (that is, from an AssemblySymbol of the Compilation), that symbol will be returned
            (i.e. the returned value will be reference-equal to one reachable from the root of the
            symbol table). Symbols representing entities without names (e.g. array-of-int) may or may
            not exhibit reference equality. However, some named symbols (such as local variables) are
            not reachable from the root. These symbols are visible as answers to semantic questions.
            When the same SemanticModel object is used, the answers exhibit reference-equality.
            </para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SemanticModel ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SemanticModel();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnalyzeControlFlowCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlowCore (Microsoft.CodeAnalysis.SyntaxNode statement);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlowCore(class Microsoft.CodeAnalysis.SyntaxNode statement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlowCore(Microsoft.CodeAnalysis.SyntaxNode)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function AnalyzeControlFlowCore (statement As SyntaxNode) As ControlFlowAnalysis" />
      <MemberSignature Language="F#" Value="abstract member AnalyzeControlFlowCore : Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.ControlFlowAnalysis" Usage="semanticModel.AnalyzeControlFlowCore statement" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::ControlFlowAnalysis ^ AnalyzeControlFlowCore(Microsoft::CodeAnalysis::SyntaxNode ^ statement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statement" Type="Microsoft.CodeAnalysis.SyntaxNode" />
      </Parameters>
      <Docs>
        <param name="statement">The statement to be analyzed.</param>
        <summary>
            Analyze control-flow within a part of a method body.
            </summary>
        <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
        <remarks>
            The statement must be fully inside the same method body.
            </remarks>
        <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
      </Docs>
    </Member>
    <Member MemberName="AnalyzeControlFlowCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlowCore (Microsoft.CodeAnalysis.SyntaxNode firstStatement, Microsoft.CodeAnalysis.SyntaxNode lastStatement);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlowCore(class Microsoft.CodeAnalysis.SyntaxNode firstStatement, class Microsoft.CodeAnalysis.SyntaxNode lastStatement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlowCore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function AnalyzeControlFlowCore (firstStatement As SyntaxNode, lastStatement As SyntaxNode) As ControlFlowAnalysis" />
      <MemberSignature Language="F#" Value="abstract member AnalyzeControlFlowCore : Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.ControlFlowAnalysis" Usage="semanticModel.AnalyzeControlFlowCore (firstStatement, lastStatement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::ControlFlowAnalysis ^ AnalyzeControlFlowCore(Microsoft::CodeAnalysis::SyntaxNode ^ firstStatement, Microsoft::CodeAnalysis::SyntaxNode ^ lastStatement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.SyntaxNode" />
      </Parameters>
      <Docs>
        <param name="firstStatement">The first node to be included within the analysis.</param>
        <param name="lastStatement">The last node to be included within the analysis.</param>
        <summary>
            Analyze control-flow within a part of a method body.
            </summary>
        <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
        <remarks>
            The first and last nodes must be fully inside the same method body.
            </remarks>
        <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
      </Docs>
    </Member>
    <Member MemberName="AnalyzeDataFlowCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlowCore (Microsoft.CodeAnalysis.SyntaxNode statementOrExpression);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlowCore(class Microsoft.CodeAnalysis.SyntaxNode statementOrExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlowCore(Microsoft.CodeAnalysis.SyntaxNode)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function AnalyzeDataFlowCore (statementOrExpression As SyntaxNode) As DataFlowAnalysis" />
      <MemberSignature Language="F#" Value="abstract member AnalyzeDataFlowCore : Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.DataFlowAnalysis" Usage="semanticModel.AnalyzeDataFlowCore statementOrExpression" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::DataFlowAnalysis ^ AnalyzeDataFlowCore(Microsoft::CodeAnalysis::SyntaxNode ^ statementOrExpression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statementOrExpression" Type="Microsoft.CodeAnalysis.SyntaxNode" />
      </Parameters>
      <Docs>
        <param name="statementOrExpression">The statement or expression to be analyzed.</param>
        <summary>
            Analyze data-flow within a part of a method body.
            </summary>
        <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
        <remarks>
            The statement or expression must be fully inside a method body.
            </remarks>
        <exception cref="T:System.ArgumentException">The statement or expression is not with a method
            body or field or property initializer.</exception>
      </Docs>
    </Member>
    <Member MemberName="AnalyzeDataFlowCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlowCore (Microsoft.CodeAnalysis.SyntaxNode firstStatement, Microsoft.CodeAnalysis.SyntaxNode lastStatement);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlowCore(class Microsoft.CodeAnalysis.SyntaxNode firstStatement, class Microsoft.CodeAnalysis.SyntaxNode lastStatement) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlowCore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function AnalyzeDataFlowCore (firstStatement As SyntaxNode, lastStatement As SyntaxNode) As DataFlowAnalysis" />
      <MemberSignature Language="F#" Value="abstract member AnalyzeDataFlowCore : Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.DataFlowAnalysis" Usage="semanticModel.AnalyzeDataFlowCore (firstStatement, lastStatement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::DataFlowAnalysis ^ AnalyzeDataFlowCore(Microsoft::CodeAnalysis::SyntaxNode ^ firstStatement, Microsoft::CodeAnalysis::SyntaxNode ^ lastStatement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.SyntaxNode" />
      </Parameters>
      <Docs>
        <param name="firstStatement">The first node to be included within the analysis.</param>
        <param name="lastStatement">The last node to be included within the analysis.</param>
        <summary>
            Analyze data-flow within a part of a method body.
            </summary>
        <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
        <remarks>
            The first and last nodes must be fully inside the same method body.
            </remarks>
        <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
      </Docs>
    </Member>
    <Member MemberName="Compilation">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Compilation Compilation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.Compilation Compilation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SemanticModel.Compilation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Compilation As Compilation" />
      <MemberSignature Language="F#" Value="member this.Compilation : Microsoft.CodeAnalysis.Compilation" Usage="Microsoft.CodeAnalysis.SemanticModel.Compilation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::Compilation ^ Compilation { Microsoft::CodeAnalysis::Compilation ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The compilation this model was obtained from.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompilationCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.Compilation CompilationCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.Compilation CompilationCore" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SemanticModel.CompilationCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property CompilationCore As Compilation" />
      <MemberSignature Language="F#" Value="member this.CompilationCore : Microsoft.CodeAnalysis.Compilation" Usage="Microsoft.CodeAnalysis.SemanticModel.CompilationCore" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property Microsoft::CodeAnalysis::Compilation ^ CompilationCore { Microsoft::CodeAnalysis::Compilation ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The compilation this model was obtained from.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAliasInfoCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfoCore (Microsoft.CodeAnalysis.SyntaxNode nameSyntax, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfoCore(class Microsoft.CodeAnalysis.SyntaxNode nameSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetAliasInfoCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetAliasInfoCore : Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="semanticModel.GetAliasInfoCore (nameSyntax, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="nameSyntax">Name to get alias info for.</param>
        <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the alias information.</param>
        <summary>
            If "nameSyntax" resolves to an alias name, return the IAliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstantValue">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Optional&lt;object&gt; GetConstantValue (Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.Optional`1&lt;object&gt; GetConstantValue(class Microsoft.CodeAnalysis.SyntaxNode node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetConstantValue(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="member this.GetConstantValue : Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.Optional&lt;obj&gt;" Usage="semanticModel.GetConstantValue (node, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Optional&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            If the node provided has a constant value an Optional value will be returned with
            HasValue set to true and with Value set to the constant.  If the node does not have an
            constant value, an Optional will be returned with HasValue set to false.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstantValueCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.Optional&lt;object&gt; GetConstantValueCore (Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype Microsoft.CodeAnalysis.Optional`1&lt;object&gt; GetConstantValueCore(class Microsoft.CodeAnalysis.SyntaxNode node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetConstantValueCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetConstantValueCore : Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.Optional&lt;obj&gt;" Usage="semanticModel.GetConstantValueCore (node, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Optional&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            If the node provided has a constant value an Optional value will be returned with
            HasValue set to true and with Value set to the constant.  If the node does not have an
            constant value, an Optional will be returned with HasValue set to false.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclarationDiagnostics">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetDeclarationDiagnostics (Nullable&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt; span = null, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetDeclarationDiagnostics(valuetype System.Nullable`1&lt;valuetype Microsoft.CodeAnalysis.Text.TextSpan&gt; span, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclarationDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclarationDiagnostics : Nullable&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt; * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="semanticModel.GetDeclarationDiagnostics (span, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Nullable&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="span">Optional span within the syntax tree for which to get diagnostics.
            If no argument is specified, then diagnostics for the entire tree are returned.</param>
        <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
        <summary>
            Get all of the declaration errors within the syntax tree associated with this
            object. Does not get errors involving incorrect syntax, compiling method bodies or initializers.
            </summary>
        <returns>To be added.</returns>
        <remarks>The declaration errors for a syntax tree are cached. The first time this method
            is called, all declarations are analyzed for diagnostics. Calling this a second time
            will return the cached diagnostics.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbolCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbolCore (Microsoft.CodeAnalysis.SyntaxNode declaration, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbolCore(class Microsoft.CodeAnalysis.SyntaxNode declaration, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredSymbolCore : Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="semanticModel.GetDeclaredSymbolCore (declaration, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax</param>
        <param name="cancellationToken">The cancellation token.</param>
        <summary>
            Gets the symbol associated with a declaration syntax node.
            </summary>
        <returns>The symbol declared by the node or null if the node is not a declaration.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclaredSymbolsCore">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetDeclaredSymbolsCore (Microsoft.CodeAnalysis.SyntaxNode declaration, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetDeclaredSymbolsCore(class Microsoft.CodeAnalysis.SyntaxNode declaration, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolsCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetDeclaredSymbolsCore : Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="semanticModel.GetDeclaredSymbolsCore (declaration, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax</param>
        <param name="cancellationToken">The cancellation token.</param>
        <summary>
            Gets the symbol associated with a declaration syntax node. Unlike <see cref="M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolForNode(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />,
            this method returns all symbols declared by a given declaration syntax node. Specifically, in the case of field declaration syntax nodes,
            which can declare multiple symbols, this method returns all declared symbols.
            </summary>
        <returns>The symbols declared by the node.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDiagnostics">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics (Nullable&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt; span = null, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics(valuetype System.Nullable`1&lt;valuetype Microsoft.CodeAnalysis.Text.TextSpan&gt; span, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetDiagnostics : Nullable&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt; * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="semanticModel.GetDiagnostics (span, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Nullable&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="span">Optional span within the syntax tree for which to get diagnostics.
            If no argument is specified, then diagnostics for the entire tree are returned.</param>
        <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
        <summary>
            Get all the errors within the syntax tree associated with this object. Includes errors
            involving compiling method bodies or initializers, in addition to the errors returned by
            GetDeclarationDiagnostics.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            Because this method must semantically bind all method bodies and initializers to check
            for diagnostics, it may take a significant amount of time. Unlike
            GetDeclarationDiagnostics, diagnostics for method bodies and initializers are not
            cached, any semantic information used to obtain the diagnostics is discarded.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingSymbol">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.ISymbol GetEnclosingSymbol (int position, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.ISymbol GetEnclosingSymbol(int32 position, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetEnclosingSymbol(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="member this.GetEnclosingSymbol : int * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="semanticModel.GetEnclosingSymbol (position, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a position in the SyntaxTree for this SemanticModel returns the innermost Symbol
            that the position is considered inside of.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingSymbolCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.ISymbol GetEnclosingSymbolCore (int position, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.ISymbol GetEnclosingSymbolCore(int32 position, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetEnclosingSymbolCore(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetEnclosingSymbolCore : int * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="semanticModel.GetEnclosingSymbolCore (position, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Given a position in the SyntaxTree for this SemanticModel returns the innermost Symbol
            that the position is considered inside of.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMemberGroupCore">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroupCore (Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroupCore(class Microsoft.CodeAnalysis.SyntaxNode node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetMemberGroupCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetMemberGroupCore : Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="semanticModel.GetMemberGroupCore (node, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            When getting information for a symbol that resolves to a method group or property group,
            from which a method is then chosen; the chosen method or property is present in Symbol;
            all methods in the group that was consulted are placed in this property.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBodyDiagnostics">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetMethodBodyDiagnostics (Nullable&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt; span = null, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetMethodBodyDiagnostics(valuetype System.Nullable`1&lt;valuetype Microsoft.CodeAnalysis.Text.TextSpan&gt; span, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetMethodBodyDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetMethodBodyDiagnostics : Nullable&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt; * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="semanticModel.GetMethodBodyDiagnostics (span, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Nullable&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="span">Optional span within the syntax tree for which to get diagnostics.
            If no argument is specified, then diagnostics for the entire tree are returned.</param>
        <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
        <summary>
            Get all of the method body and initializer errors within the syntax tree associated with this
            object. Does not get errors involving incorrect syntax or declarations.
            </summary>
        <returns>To be added.</returns>
        <remarks>The method body errors for a syntax tree are not cached. The first time this method
            is called, all method bodies are analyzed for diagnostics. Calling this a second time
            will repeat this work.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOperation">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.IOperation GetOperation (Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.IOperation GetOperation(class Microsoft.CodeAnalysis.SyntaxNode node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetOperation(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="member this.GetOperation : Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IOperation" Usage="semanticModel.GetOperation (node, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="node">The expression or statement syntax node.</param>
        <param name="cancellationToken">An optional cancellation token.</param>
        <summary>
            Gets the operation corresponding to the expression or statement syntax node.
            </summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOperationCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.IOperation GetOperationCore (Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.IOperation GetOperationCore(class Microsoft.CodeAnalysis.SyntaxNode node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetOperationCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetOperationCore : Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IOperation" Usage="semanticModel.GetOperationCore (node, cancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::IOperation ^ GetOperationCore(Microsoft::CodeAnalysis::SyntaxNode ^ node, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPreprocessingSymbolInfo">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.PreprocessingSymbolInfo GetPreprocessingSymbolInfo (Microsoft.CodeAnalysis.SyntaxNode nameSyntax);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.PreprocessingSymbolInfo GetPreprocessingSymbolInfo(class Microsoft.CodeAnalysis.SyntaxNode nameSyntax) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.SyntaxNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPreprocessingSymbolInfo (nameSyntax As SyntaxNode) As PreprocessingSymbolInfo" />
      <MemberSignature Language="F#" Value="member this.GetPreprocessingSymbolInfo : Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.PreprocessingSymbolInfo" Usage="semanticModel.GetPreprocessingSymbolInfo nameSyntax" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::PreprocessingSymbolInfo GetPreprocessingSymbolInfo(Microsoft::CodeAnalysis::SyntaxNode ^ nameSyntax);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.PreprocessingSymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.SyntaxNode" />
      </Parameters>
      <Docs>
        <param name="nameSyntax">The nameSyntax node to get semantic information for.</param>
        <summary>
            If <paramref name="nameSyntax" /> is an identifier name syntax node, return the <see cref="T:Microsoft.CodeAnalysis.PreprocessingSymbolInfo" /> corresponding
            to it.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPreprocessingSymbolInfoCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.PreprocessingSymbolInfo GetPreprocessingSymbolInfoCore (Microsoft.CodeAnalysis.SyntaxNode nameSyntax);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype Microsoft.CodeAnalysis.PreprocessingSymbolInfo GetPreprocessingSymbolInfoCore(class Microsoft.CodeAnalysis.SyntaxNode nameSyntax) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetPreprocessingSymbolInfoCore(Microsoft.CodeAnalysis.SyntaxNode)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPreprocessingSymbolInfoCore (nameSyntax As SyntaxNode) As PreprocessingSymbolInfo" />
      <MemberSignature Language="F#" Value="abstract member GetPreprocessingSymbolInfoCore : Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.PreprocessingSymbolInfo" Usage="semanticModel.GetPreprocessingSymbolInfoCore nameSyntax" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::PreprocessingSymbolInfo GetPreprocessingSymbolInfoCore(Microsoft::CodeAnalysis::SyntaxNode ^ nameSyntax);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.PreprocessingSymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.SyntaxNode" />
      </Parameters>
      <Docs>
        <param name="nameSyntax">The nameSyntax node to get semantic information for.</param>
        <summary>
            If <paramref name="nameSyntax" /> is an identifier name syntax node, return the <see cref="T:Microsoft.CodeAnalysis.PreprocessingSymbolInfo" /> corresponding
            to it.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeAliasInfoCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfoCore (int position, Microsoft.CodeAnalysis.SyntaxNode nameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfoCore(int32 position, class Microsoft.CodeAnalysis.SyntaxNode nameSyntax, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeAliasInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetSpeculativeAliasInfoCore (position As Integer, nameSyntax As SyntaxNode, bindingOption As SpeculativeBindingOption) As IAliasSymbol" />
      <MemberSignature Language="F#" Value="abstract member GetSpeculativeAliasInfoCore : int * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="semanticModel.GetSpeculativeAliasInfoCore (position, nameSyntax, bindingOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::IAliasSymbol ^ GetSpeculativeAliasInfoCore(int position, Microsoft::CodeAnalysis::SyntaxNode ^ nameSyntax, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
        <param name="nameSyntax">A syntax node that represents a name. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
        <param name="bindingOption">Indicates whether to binding the name as a full expression,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
        <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
        <returns>To be added.</returns>
        <remarks>The passed in name is interpreted as a stand-alone name, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeSymbolInfoCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfoCore (int position, Microsoft.CodeAnalysis.SyntaxNode expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfoCore(int32 position, class Microsoft.CodeAnalysis.SyntaxNode expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeSymbolInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetSpeculativeSymbolInfoCore (position As Integer, expression As SyntaxNode, bindingOption As SpeculativeBindingOption) As SymbolInfo" />
      <MemberSignature Language="F#" Value="abstract member GetSpeculativeSymbolInfoCore : int * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="semanticModel.GetSpeculativeSymbolInfoCore (position, expression, bindingOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::SymbolInfo GetSpeculativeSymbolInfoCore(int position, Microsoft::CodeAnalysis::SyntaxNode ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
        <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
        <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
        <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
        <returns>The semantic information for the topmost node of the expression.</returns>
        <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSpeculativeTypeInfoCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfoCore (int position, Microsoft.CodeAnalysis.SyntaxNode expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfoCore(int32 position, class Microsoft.CodeAnalysis.SyntaxNode expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeTypeInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetSpeculativeTypeInfoCore (position As Integer, expression As SyntaxNode, bindingOption As SpeculativeBindingOption) As TypeInfo" />
      <MemberSignature Language="F#" Value="abstract member GetSpeculativeTypeInfoCore : int * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="semanticModel.GetSpeculativeTypeInfoCore (position, expression, bindingOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::TypeInfo GetSpeculativeTypeInfoCore(int position, Microsoft::CodeAnalysis::SyntaxNode ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="expression" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
      </Parameters>
      <Docs>
        <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
        <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
        <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
        <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
        <returns>The semantic information for the topmost node of the expression.</returns>
        <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolInfoCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfoCore (Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfoCore(class Microsoft.CodeAnalysis.SyntaxNode node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetSymbolInfoCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetSymbolInfoCore : Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="semanticModel.GetSymbolInfoCore (node, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="node">The syntax node to get semantic information for.</param>
        <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        <summary>
            Gets symbol information about a syntax node.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSyntaxDiagnostics">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetSyntaxDiagnostics (Nullable&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt; span = null, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetSyntaxDiagnostics(valuetype System.Nullable`1&lt;valuetype Microsoft.CodeAnalysis.Text.TextSpan&gt; span, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetSyntaxDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetSyntaxDiagnostics : Nullable&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt; * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="semanticModel.GetSyntaxDiagnostics (span, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Nullable&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="span">Optional span within the syntax tree for which to get diagnostics.
            If no argument is specified, then diagnostics for the entire tree are returned.</param>
        <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
        <summary>
            Get all of the syntax errors within the syntax tree associated with this
            object. Does not get errors involving declarations or compiling method bodies or initializers.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTopmostNodeForDiagnosticAnalysis">
      <MemberSignature Language="C#" Value="protected internal virtual Microsoft.CodeAnalysis.SyntaxNode GetTopmostNodeForDiagnosticAnalysis (Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SyntaxNode declaringSyntax);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxNode GetTopmostNodeForDiagnosticAnalysis(class Microsoft.CodeAnalysis.ISymbol symbol, class Microsoft.CodeAnalysis.SyntaxNode declaringSyntax) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetTopmostNodeForDiagnosticAnalysis(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SyntaxNode)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetTopmostNodeForDiagnosticAnalysis (symbol As ISymbol, declaringSyntax As SyntaxNode) As SyntaxNode" />
      <MemberSignature Language="F#" Value="abstract member GetTopmostNodeForDiagnosticAnalysis : Microsoft.CodeAnalysis.ISymbol * Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.SyntaxNode&#xA;override this.GetTopmostNodeForDiagnosticAnalysis : Microsoft.CodeAnalysis.ISymbol * Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.SyntaxNode" Usage="semanticModel.GetTopmostNodeForDiagnosticAnalysis (symbol, declaringSyntax)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual Microsoft::CodeAnalysis::SyntaxNode ^ GetTopmostNodeForDiagnosticAnalysis(Microsoft::CodeAnalysis::ISymbol ^ symbol, Microsoft::CodeAnalysis::SyntaxNode ^ declaringSyntax);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" />
        <Parameter Name="declaringSyntax" Type="Microsoft.CodeAnalysis.SyntaxNode" />
      </Parameters>
      <Docs>
        <param name="symbol">To be added.</param>
        <param name="declaringSyntax">To be added.</param>
        <summary>
            Takes a Symbol and syntax for one of its declaring syntax reference and returns the topmost syntax node to be used by syntax analyzer.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfoCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.TypeInfo GetTypeInfoCore (Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfoCore(class Microsoft.CodeAnalysis.SyntaxNode node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.GetTypeInfoCore(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetTypeInfoCore : Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="semanticModel.GetTypeInfoCore (node, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="node">The syntax node to get semantic information for.</param>
        <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        <summary>
            Gets type information about a syntax node.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoresAccessibility">
      <MemberSignature Language="C#" Value="public virtual bool IgnoresAccessibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoresAccessibility" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SemanticModel.IgnoresAccessibility" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IgnoresAccessibility As Boolean" />
      <MemberSignature Language="F#" Value="member this.IgnoresAccessibility : bool" Usage="Microsoft.CodeAnalysis.SemanticModel.IgnoresAccessibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IgnoresAccessibility { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns true if this is a SemanticModel that ignores accessibility rules when answering semantic questions.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAccessible">
      <MemberSignature Language="C#" Value="public bool IsAccessible (int position, Microsoft.CodeAnalysis.ISymbol symbol);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAccessible(int32 position, class Microsoft.CodeAnalysis.ISymbol symbol) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.IsAccessible(System.Int32,Microsoft.CodeAnalysis.ISymbol)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAccessible (position As Integer, symbol As ISymbol) As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsAccessible : int * Microsoft.CodeAnalysis.ISymbol -&gt; bool" Usage="semanticModel.IsAccessible (position, symbol)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAccessible(int position, Microsoft::CodeAnalysis::ISymbol ^ symbol);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" />
      </Parameters>
      <Docs>
        <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
        <param name="symbol">The symbol that we are checking to see if it accessible.</param>
        <summary>
            Determines if the symbol is accessible from the specified location.
            </summary>
        <returns>
            True if "symbol is accessible, false otherwise.</returns>
        <remarks>
            This method only checks accessibility from the point of view of the accessibility
            modifiers on symbol and its containing types. Even if true is returned, the given symbol
            may not be able to be referenced for other reasons, such as name hiding.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAccessibleCore">
      <MemberSignature Language="C#" Value="protected abstract bool IsAccessibleCore (int position, Microsoft.CodeAnalysis.ISymbol symbol);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsAccessibleCore(int32 position, class Microsoft.CodeAnalysis.ISymbol symbol) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.IsAccessibleCore(System.Int32,Microsoft.CodeAnalysis.ISymbol)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsAccessibleCore (position As Integer, symbol As ISymbol) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsAccessibleCore : int * Microsoft.CodeAnalysis.ISymbol -&gt; bool" Usage="semanticModel.IsAccessibleCore (position, symbol)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsAccessibleCore(int position, Microsoft::CodeAnalysis::ISymbol ^ symbol);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" />
      </Parameters>
      <Docs>
        <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
        <param name="symbol">The symbol that we are checking to see if it accessible.</param>
        <summary>
            Determines if the symbol is accessible from the specified location.
            </summary>
        <returns>
            True if "symbol is accessible, false otherwise.</returns>
        <remarks>
            This method only checks accessibility from the point of view of the accessibility
            modifiers on symbol and its containing types. Even if true is returned, the given symbol
            may not be able to be referenced for other reasons, such as name hiding.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEventUsableAsField">
      <MemberSignature Language="C#" Value="public bool IsEventUsableAsField (int position, Microsoft.CodeAnalysis.IEventSymbol eventSymbol);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEventUsableAsField(int32 position, class Microsoft.CodeAnalysis.IEventSymbol eventSymbol) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.IsEventUsableAsField(System.Int32,Microsoft.CodeAnalysis.IEventSymbol)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEventUsableAsField (position As Integer, eventSymbol As IEventSymbol) As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsEventUsableAsField : int * Microsoft.CodeAnalysis.IEventSymbol -&gt; bool" Usage="semanticModel.IsEventUsableAsField (position, eventSymbol)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEventUsableAsField(int position, Microsoft::CodeAnalysis::IEventSymbol ^ eventSymbol);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="eventSymbol" Type="Microsoft.CodeAnalysis.IEventSymbol" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <param name="eventSymbol">To be added.</param>
        <summary>
            Field-like events can be used as fields in types that can access private
            members of the declaring type of the event.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            Always false for VB events.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEventUsableAsFieldCore">
      <MemberSignature Language="C#" Value="protected abstract bool IsEventUsableAsFieldCore (int position, Microsoft.CodeAnalysis.IEventSymbol eventSymbol);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsEventUsableAsFieldCore(int32 position, class Microsoft.CodeAnalysis.IEventSymbol eventSymbol) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.IsEventUsableAsFieldCore(System.Int32,Microsoft.CodeAnalysis.IEventSymbol)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsEventUsableAsFieldCore (position As Integer, eventSymbol As IEventSymbol) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsEventUsableAsFieldCore : int * Microsoft.CodeAnalysis.IEventSymbol -&gt; bool" Usage="semanticModel.IsEventUsableAsFieldCore (position, eventSymbol)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsEventUsableAsFieldCore(int position, Microsoft::CodeAnalysis::IEventSymbol ^ eventSymbol);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="eventSymbol" Type="Microsoft.CodeAnalysis.IEventSymbol" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <param name="eventSymbol">To be added.</param>
        <summary>
            Field-like events can be used as fields in types that can access private
            members of the declaring type of the event.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            Always false for VB events.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpeculativeSemanticModel">
      <MemberSignature Language="C#" Value="public abstract bool IsSpeculativeSemanticModel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpeculativeSemanticModel" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsSpeculativeSemanticModel As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsSpeculativeSemanticModel : bool" Usage="Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsSpeculativeSemanticModel { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns true if this is a speculative semantic model created with any of the TryGetSpeculativeSemanticModel methods.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public abstract string Language { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Language" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SemanticModel.Language" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Language As String" />
      <MemberSignature Language="F#" Value="member this.Language : string" Usage="Microsoft.CodeAnalysis.SemanticModel.Language" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Language { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the source language ("C#" or "Visual Basic").
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupBaseMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; LookupBaseMembers (int position, string name = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; LookupBaseMembers(int32 position, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembers(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LookupBaseMembers (position As Integer, Optional name As String = null) As ImmutableArray(Of ISymbol)" />
      <MemberSignature Language="F#" Value="member this.LookupBaseMembers : int * string -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="semanticModel.LookupBaseMembers (position, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">The character position for determining the enclosing declaration scope and
             accessibility.</param>
        <param name="name">The name of the symbol to find. If null is specified then symbols
             with any names are returned.</param>
        <summary>
             Gets the available base type members in the context of the specified location.  Akin to
             calling <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)" /> with the container set to the immediate base type of
             the type in which <paramref name="position" /> occurs.  However, the accessibility rules
             are different: protected members of the base type will be visible.
            
             Consider the following example:
            
               public class Base
               {
                   protected void M() { }
               }
            
               public class Derived : Base
               {
                   void Test(Base b)
                   {
                       b.M(); // Error - cannot access protected member.
                       base.M();
                   }
               }
            
             Protected members of an instance of another type are only accessible if the instance is known
             to be "this" instance (as indicated by the "base" keyword).
             </summary>
        <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
        <remarks>
             The "position" is used to determine what variables are visible and accessible.
            
             Non-reduced extension methods are considered, but reduced extension methods are not.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupBaseMembersCore">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; LookupBaseMembersCore (int position, string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; LookupBaseMembersCore(int32 position, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembersCore(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function LookupBaseMembersCore (position As Integer, name As String) As ImmutableArray(Of ISymbol)" />
      <MemberSignature Language="F#" Value="abstract member LookupBaseMembersCore : int * string -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="semanticModel.LookupBaseMembersCore (position, name)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ISymbol ^&gt; LookupBaseMembersCore(int position, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <param name="name">To be added.</param>
        <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembers(System.Int32,System.String)" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupLabels">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; LookupLabels (int position, string name = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; LookupLabels(int32 position, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LookupLabels (position As Integer, Optional name As String = null) As ImmutableArray(Of ISymbol)" />
      <MemberSignature Language="F#" Value="member this.LookupLabels : int * string -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="semanticModel.LookupLabels (position, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
        <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
        <summary>
            Gets the available named label symbols in the context of the specified location and optional container.
            Only members that are accessible and visible from the given location are returned.
            </summary>
        <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
        <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupLabelsCore">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; LookupLabelsCore (int position, string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; LookupLabelsCore(int32 position, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.LookupLabelsCore(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function LookupLabelsCore (position As Integer, name As String) As ImmutableArray(Of ISymbol)" />
      <MemberSignature Language="F#" Value="abstract member LookupLabelsCore : int * string -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="semanticModel.LookupLabelsCore (position, name)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ISymbol ^&gt; LookupLabelsCore(int position, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <param name="name">To be added.</param>
        <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupNamespacesAndTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; LookupNamespacesAndTypes (int position, Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container = null, string name = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; LookupNamespacesAndTypes(int32 position, class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypes(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LookupNamespacesAndTypes (position As Integer, Optional container As INamespaceOrTypeSymbol = null, Optional name As String = null) As ImmutableArray(Of ISymbol)" />
      <MemberSignature Language="F#" Value="member this.LookupNamespacesAndTypes : int * Microsoft.CodeAnalysis.INamespaceOrTypeSymbol * string -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="semanticModel.LookupNamespacesAndTypes (position, container, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="container" Type="Microsoft.CodeAnalysis.INamespaceOrTypeSymbol" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">The character position for determining the enclosing declaration scope and
             accessibility.</param>
        <param name="container">The container to search for symbols within. If null then the enclosing declaration
             scope around position is used.</param>
        <param name="name">The name of the symbol to find. If null is specified then symbols
             with any names are returned.</param>
        <summary>
             Gets the available named namespace and type symbols in the context of the specified location and optional container.
             Only members that are accessible and visible from the given location are returned.
             </summary>
        <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
        <remarks>
             The "position" is used to determine what variables are visible and accessible. Even if "container" is
             specified, the "position" location is significant for determining which members of "containing" are
             accessible.
            
             Does not return INamespaceOrTypeSymbol, because there could be aliases.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupNamespacesAndTypesCore">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; LookupNamespacesAndTypesCore (int position, Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; LookupNamespacesAndTypesCore(int32 position, class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypesCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function LookupNamespacesAndTypesCore (position As Integer, container As INamespaceOrTypeSymbol, name As String) As ImmutableArray(Of ISymbol)" />
      <MemberSignature Language="F#" Value="abstract member LookupNamespacesAndTypesCore : int * Microsoft.CodeAnalysis.INamespaceOrTypeSymbol * string -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="semanticModel.LookupNamespacesAndTypesCore (position, container, name)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ISymbol ^&gt; LookupNamespacesAndTypesCore(int position, Microsoft::CodeAnalysis::INamespaceOrTypeSymbol ^ container, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="container" Type="Microsoft.CodeAnalysis.INamespaceOrTypeSymbol" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <param name="container">To be added.</param>
        <param name="name">To be added.</param>
        <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypes(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupStaticMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; LookupStaticMembers (int position, Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container = null, string name = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; LookupStaticMembers(int32 position, class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembers(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LookupStaticMembers (position As Integer, Optional container As INamespaceOrTypeSymbol = null, Optional name As String = null) As ImmutableArray(Of ISymbol)" />
      <MemberSignature Language="F#" Value="member this.LookupStaticMembers : int * Microsoft.CodeAnalysis.INamespaceOrTypeSymbol * string -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="semanticModel.LookupStaticMembers (position, container, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="container" Type="Microsoft.CodeAnalysis.INamespaceOrTypeSymbol" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">The character position for determining the enclosing declaration scope and
             accessibility.</param>
        <param name="container">The container to search for symbols within. If null then the enclosing declaration
             scope around position is used.</param>
        <param name="name">The name of the symbol to find. If null is specified then symbols
             with any names are returned.</param>
        <summary>
             Gets the available named static member symbols in the context of the specified location and optional container.
             Only members that are accessible and visible from the given location are returned.
            
             Non-reduced extension methods are considered, since they are static methods.
             </summary>
        <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
        <remarks>
             The "position" is used to determine what variables are visible and accessible. Even if "container" is
             specified, the "position" location is significant for determining which members of "containing" are
             accessible.
            
             Essentially the same as filtering instance members out of the results of an analogous <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)" /> call.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupStaticMembersCore">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; LookupStaticMembersCore (int position, Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; LookupStaticMembersCore(int32 position, class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembersCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function LookupStaticMembersCore (position As Integer, container As INamespaceOrTypeSymbol, name As String) As ImmutableArray(Of ISymbol)" />
      <MemberSignature Language="F#" Value="abstract member LookupStaticMembersCore : int * Microsoft.CodeAnalysis.INamespaceOrTypeSymbol * string -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="semanticModel.LookupStaticMembersCore (position, container, name)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ISymbol ^&gt; LookupStaticMembersCore(int position, Microsoft::CodeAnalysis::INamespaceOrTypeSymbol ^ container, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="container" Type="Microsoft.CodeAnalysis.INamespaceOrTypeSymbol" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <param name="container">To be added.</param>
        <param name="name">To be added.</param>
        <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembers(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSymbols">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; LookupSymbols (int position, Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container = null, string name = null, bool includeReducedExtensionMethods = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; LookupSymbols(int32 position, class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LookupSymbols (position As Integer, Optional container As INamespaceOrTypeSymbol = null, Optional name As String = null, Optional includeReducedExtensionMethods As Boolean = false) As ImmutableArray(Of ISymbol)" />
      <MemberSignature Language="F#" Value="member this.LookupSymbols : int * Microsoft.CodeAnalysis.INamespaceOrTypeSymbol * string * bool -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="semanticModel.LookupSymbols (position, container, name, includeReducedExtensionMethods)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="container" Type="Microsoft.CodeAnalysis.INamespaceOrTypeSymbol" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="includeReducedExtensionMethods" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">The character position for determining the enclosing declaration scope and
             accessibility.</param>
        <param name="container">The container to search for symbols within. If null then the enclosing declaration
             scope around position is used.</param>
        <param name="name">The name of the symbol to find. If null is specified then symbols
             with any names are returned.</param>
        <param name="includeReducedExtensionMethods">Consider (reduced) extension methods.</param>
        <summary>
             Gets the available named symbols in the context of the specified location and optional container. Only
             symbols that are accessible and visible from the given location are returned.
             </summary>
        <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
        <remarks>
             The "position" is used to determine what variables are visible and accessible. Even if "container" is
             specified, the "position" location is significant for determining which members of "containing" are
             accessible.
            
             Labels are not considered (see <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)" />).
            
             Non-reduced extension methods are considered regardless of the value of <paramref name="includeReducedExtensionMethods" />.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSymbolsCore">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; LookupSymbolsCore (int position, Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; LookupSymbolsCore(int32 position, class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbolsCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function LookupSymbolsCore (position As Integer, container As INamespaceOrTypeSymbol, name As String, includeReducedExtensionMethods As Boolean) As ImmutableArray(Of ISymbol)" />
      <MemberSignature Language="F#" Value="abstract member LookupSymbolsCore : int * Microsoft.CodeAnalysis.INamespaceOrTypeSymbol * string * bool -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="semanticModel.LookupSymbolsCore (position, container, name, includeReducedExtensionMethods)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ISymbol ^&gt; LookupSymbolsCore(int position, Microsoft::CodeAnalysis::INamespaceOrTypeSymbol ^ container, System::String ^ name, bool includeReducedExtensionMethods);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="container" Type="Microsoft.CodeAnalysis.INamespaceOrTypeSymbol" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="includeReducedExtensionMethods" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <param name="container">To be added.</param>
        <param name="name">To be added.</param>
        <param name="includeReducedExtensionMethods">To be added.</param>
        <summary>
            Backing implementation of <see cref="M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalPositionForSpeculation">
      <MemberSignature Language="C#" Value="public abstract int OriginalPositionForSpeculation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OriginalPositionForSpeculation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SemanticModel.OriginalPositionForSpeculation" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property OriginalPositionForSpeculation As Integer" />
      <MemberSignature Language="F#" Value="member this.OriginalPositionForSpeculation : int" Usage="Microsoft.CodeAnalysis.SemanticModel.OriginalPositionForSpeculation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int OriginalPositionForSpeculation { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            If this is a speculative semantic model, returns the original position at which the speculative model was created.
            Otherwise, returns 0.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentModel">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SemanticModel ParentModel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.SemanticModel ParentModel" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SemanticModel.ParentModel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentModel As SemanticModel" />
      <MemberSignature Language="F#" Value="member this.ParentModel : Microsoft.CodeAnalysis.SemanticModel" Usage="Microsoft.CodeAnalysis.SemanticModel.ParentModel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::SemanticModel ^ ParentModel { Microsoft::CodeAnalysis::SemanticModel ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SemanticModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            If this is a speculative semantic model, then returns its parent semantic model.
            Otherwise, returns null.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentModelCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.SemanticModel ParentModelCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.SemanticModel ParentModelCore" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SemanticModel.ParentModelCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property ParentModelCore As SemanticModel" />
      <MemberSignature Language="F#" Value="member this.ParentModelCore : Microsoft.CodeAnalysis.SemanticModel" Usage="Microsoft.CodeAnalysis.SemanticModel.ParentModelCore" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property Microsoft::CodeAnalysis::SemanticModel ^ ParentModelCore { Microsoft::CodeAnalysis::SemanticModel ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SemanticModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            If this is a speculative semantic model, then returns its parent semantic model.
            Otherwise, returns null.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RootCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.SyntaxNode RootCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.SyntaxNode RootCore" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SemanticModel.RootCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property RootCore As SyntaxNode" />
      <MemberSignature Language="F#" Value="member this.RootCore : Microsoft.CodeAnalysis.SyntaxNode" Usage="Microsoft.CodeAnalysis.SemanticModel.RootCore" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property Microsoft::CodeAnalysis::SyntaxNode ^ RootCore { Microsoft::CodeAnalysis::SyntaxNode ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Root of this semantic model
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SyntaxTree">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxTree SyntaxTree { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.SyntaxTree SyntaxTree" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SemanticModel.SyntaxTree" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyntaxTree As SyntaxTree" />
      <MemberSignature Language="F#" Value="member this.SyntaxTree : Microsoft.CodeAnalysis.SyntaxTree" Usage="Microsoft.CodeAnalysis.SemanticModel.SyntaxTree" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::SyntaxTree ^ SyntaxTree { Microsoft::CodeAnalysis::SyntaxTree ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTree</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The syntax tree this model was obtained from.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SyntaxTreeCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.SyntaxTree SyntaxTreeCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.SyntaxTree SyntaxTreeCore" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SemanticModel.SyntaxTreeCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property SyntaxTreeCore As SyntaxTree" />
      <MemberSignature Language="F#" Value="member this.SyntaxTreeCore : Microsoft.CodeAnalysis.SyntaxTree" Usage="Microsoft.CodeAnalysis.SemanticModel.SyntaxTreeCore" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property Microsoft::CodeAnalysis::SyntaxTree ^ SyntaxTreeCore { Microsoft::CodeAnalysis::SyntaxTree ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTree</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The syntax tree this model was obtained from.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>