<Type Name="IErrorTypeSymbol" FullName="Microsoft.CodeAnalysis.IErrorTypeSymbol">
  <TypeSignature Language="C#" Value="public interface IErrorTypeSymbol : IEquatable&lt;Microsoft.CodeAnalysis.ISymbol&gt;, Microsoft.CodeAnalysis.INamedTypeSymbol" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IErrorTypeSymbol implements class Microsoft.CodeAnalysis.INamedTypeSymbol, class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol, class Microsoft.CodeAnalysis.ISymbol, class Microsoft.CodeAnalysis.ITypeSymbol, class System.IEquatable`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt;" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.IErrorTypeSymbol" />
  <TypeSignature Language="VB.NET" Value="Public Interface IErrorTypeSymbol&#xA;Implements IEquatable(Of ISymbol), INamedTypeSymbol" />
  <TypeSignature Language="F#" Value="type IErrorTypeSymbol = interface&#xA;    interface INamedTypeSymbol&#xA;    interface ITypeSymbol&#xA;    interface INamespaceOrTypeSymbol&#xA;    interface ISymbol&#xA;    interface IEquatable&lt;ISymbol&gt;" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
    <AssemblyVersion>2.4.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.CodeAnalysis.INamedTypeSymbol</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;Microsoft.CodeAnalysis.ISymbol&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
            An IErrorTypeSymbol is used when the compiler cannot determine a symbol object to return because
            of an error. For example, if a field is declared "Foo x;", and the type "Foo" cannot be
            found, an IErrorTypeSymbol is returned when asking the field "x" what it's type is.
            </summary>
    <remarks>
            This interface is reserved for implementation by its associated APIs. We reserve the right to
            change it in the future.
            </remarks>
  </Docs>
  <Members>
    <Member MemberName="CandidateReason">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CandidateReason CandidateReason { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.CandidateReason CandidateReason" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.IErrorTypeSymbol.CandidateReason" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CandidateReason As CandidateReason" />
      <MemberSignature Language="F#" Value="member this.CandidateReason : Microsoft.CodeAnalysis.CandidateReason" Usage="Microsoft.CodeAnalysis.IErrorTypeSymbol.CandidateReason" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CandidateReason</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             If CandidateSymbols returns one or more symbols, returns the reason that those
             symbols were not chosen. Otherwise, returns None.
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CandidateSymbols">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; CandidateSymbols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; CandidateSymbols" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.IErrorTypeSymbol.CandidateSymbols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CandidateSymbols As ImmutableArray(Of ISymbol)" />
      <MemberSignature Language="F#" Value="member this.CandidateSymbols : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="Microsoft.CodeAnalysis.IErrorTypeSymbol.CandidateSymbols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.4.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            When constructing this type, there may have been symbols that seemed to
            be what the user intended, but were unsuitable. For example, a type might have been
            inaccessible, or ambiguous. This property returns the possible symbols that the user
            might have intended. It will return no symbols if no possible symbols were found.
            See the CandidateReason property to understand why the symbols were unsuitable.
            </summary>
        <value>To be added.</value>
        <remarks>
            This only applies if this INamedTypeSymbol has TypeKind TypeKind.Error.
            If not, an empty ImmutableArray is returned.
            </remarks>
      </Docs>
    </Member>
  </Members>
</Type>