<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.Workspaces.Desktop</name>
    </assembly>
    <members>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.s_utf8Encoding">
            <summary>
            Encoding to use when there is no byte order mark (BOM) on the stream. This encoder may throw a <see cref="T:System.Text.DecoderFallbackException"/>
            if the stream contains invalid UTF-8 bytes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.s_fallbackEncoding">
            <summary>
            Encoding to use when UTF-8 fails. We try to find the following, in order, if available:
                1. The default ANSI codepage
                2. CodePage 1252.
                3. Latin1.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Create(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)">
            <summary>
            Initializes an instance of <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from the provided stream. This version differs
            from <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)"/> in two ways:
            1. It attempts to minimize allocations by trying to read the stream into a byte array.
            2. If <paramref name="defaultEncoding"/> is null, it will first try UTF8 and, if that fails, it will
               try CodePage 1252. If CodePage 1252 is not available on the system, then it will try Latin1.
            </summary>
            <param name="stream">The stream containing encoded text.</param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding. If these heuristics fail the decoding is assumed to be Encoding.Default.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <param name="canBeEmbedded">Indicates if the file can be embedded in the PDB.</param>
            <param name="checksumAlgorithm">Hash algorithm used to calculate document checksum.</param>
            <exception cref="T:System.IO.InvalidDataException">
            The stream content can't be decoded using the specified <paramref name="defaultEncoding"/>, or
            <paramref name="defaultEncoding"/> is null and the stream appears to be a binary file.
            </exception>
            <exception cref="T:System.IO.IOException">An IO error occurred while reading from the stream.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Decode(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean,System.Boolean)">
            <summary>
            Try to create a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from the given stream using the given encoding.
            </summary>
            <param name="data">The input stream containing the encoded text. The stream will not be closed.</param>
            <param name="encoding">The expected encoding of the stream. The actual encoding used may be different if byte order marks are detected.</param>
            <param name="checksumAlgorithm">The checksum algorithm to use.</param>
            <param name="throwIfBinaryDetected">Throw <see cref="T:System.IO.InvalidDataException"/> if binary (non-text) data is detected.</param>
            <param name="canBeEmbedded">Indicates if the text can be embedded in the PDB.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> decoded from the stream.</returns>
            <exception cref="T:System.Text.DecoderFallbackException">The decoder was unable to decode the stream with the given encoding.</exception>
            <exception cref="T:System.IO.IOException">Error reading from stream.</exception> 
            <remarks>
            internal for unit testing
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetBytesFromStream(System.IO.Stream,System.ArraySegment{System.Byte}@)">
            <summary>
            Some streams are easily represented as bytes.
            </summary>
            <param name="data">The stream</param>
            <param name="bytes">The bytes, if available.</param>
            <returns>
            True if the stream's bytes could easily be read, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetBytesFromFileStream(System.IO.FileStream,System.ArraySegment{System.Byte}@)">
            <summary>
            Read the contents of a FileStream into a byte array.
            </summary>
            <param name="stream">The FileStream with encoded text.</param>
            <param name="bytes">A byte array filled with the contents of the file.</param>
            <returns>True if a byte array could be created.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CoreClrShim">
            <summary>
            Shim for APIs available only on CoreCLR.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DesktopAnalyzerAssemblyLoader">
            <summary>
            Loads analyzer assemblies from their original locations in the file system.
            Assemblies will only be loaded from the locations specified when the loader
            is instantiated.
            </summary>
            <remarks>
            This type is meant to be used in scenarios where it is OK for the analyzer
            assemblies to be locked on disk for the lifetime of the host; for example,
            csc.exe and vbc.exe. In scenarios where support for updating or deleting
            the analyzer on disk is required a different loader should be used.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.ReferenceSerializationServiceFactory">
            <summary>
            this is desktop implementation of IReferenceSerializationService
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.SerializationAnalyzerAssemblyLoader">
            <summary>
            This is assembly loader for serialized analyzer reference. 
            
            this will record display path (<see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.FullPath"/>  returns) and 
            actual path (<see cref="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.GetAssembly"/> ) assembly needed to be loaded 
            
            when requested, it will load from actual path.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EtwLogger">
            <summary>
            A logger that publishes events to ETW using an EventSource.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource">
            <summary>
            This EventSource exposes our events to ETW.
            RoslynEventSource GUID is {bf965e67-c7fb-5c5b-d98f-cdf68f8154c2}.
            
            When updating this class, use the following to also update Main\Source\Test\Performance\Log\RoslynEventSourceParser.cs:
            Main\Tools\Source\TraceParserGen\bin\Debug\TraceParserGen.exe Microsoft.CodeAnalysis.Workspaces.dll -eventsource:RoslynEventSource
            
            Use this command to register the ETW manifest on any machine where you need to decode events in xperf/etlstackbrowse:
            "\\clrmain\tools\managed\etw\eventRegister\bin\Debug\eventRegister.exe" Microsoft.CodeAnalysis.Workspaces.dll
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WorkspaceDesktopResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.Invalid_assembly_name">
            <summary>
              Looks up a localized string similar to Invalid assembly name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.Invalid_characters_in_assembly_name">
            <summary>
              Looks up a localized string similar to Invalid characters in assembly name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.Msbuild_failed_when_processing_the_file_0">
            <summary>
              Looks up a localized string similar to Msbuild failed when processing the file &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceDesktopResources.Msbuild_failed_when_processing_the_file_0_with_message_1">
            <summary>
              Looks up a localized string similar to Msbuild failed when processing the file &apos;{0}&apos; with message: {1}.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineProject.CreateProjectInfo(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/> structure initialized from a compilers command line arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineProject.CreateProjectInfo(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/> structure initialized with data from a compiler command line.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FileTextLoaderOptions.FileLengthThreshold">
            <summary>
            Hidden registry key to control maximum size of a text file we will read into memory. 
            we have this option to reduce a chance of OOM when user adds massive size files to the solution.
            Default threshold is 100MB which came from some internal data on big files and some discussion.
            
            User can override default value by setting DWORD value on FileLengthThreshold in 
            "[VS HIVE]\Roslyn\Internal\Performance\Text"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Creates a content loader for specified file.
            </summary>
            <param name="path">An absolute file path.</param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding. If these heuristics fail the decoding is assumed to be <see cref="P:System.Text.Encoding.Default"/>.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is not an absolute path.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileTextLoader.Path">
            <summary>
            Absolute path of the file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileTextLoader.DefaultEncoding">
            <summary>
            Specifies an encoding to be used if the actual encoding of the file 
            can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If <c>null</c> auto-detect heuristics are used to determine the encoding. 
            If these heuristics fail the decoding is assumed to be <see cref="P:System.Text.Encoding.Default"/>.
            Note that if the stream starts with Byte Order Mark the value of <see cref="P:Microsoft.CodeAnalysis.FileTextLoader.DefaultEncoding"/> is ignored.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.LoadTextAndVersionAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Load a text and a version of the document in the workspace.
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.LoadTextAndVersionSynchronously(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Load a text and a version of the document in the workspace.
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices">
            <summary>
            A class that provides host services via classes instances exported via a MEF version 1 composition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.CreateWorkspaceServices(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/> associated with the specified workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.GetExports``2">
            <summary>
            Gets all the MEF exports of the specified type with the specified metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.GetExports``1">
            <summary>
            Gets all the MEF exports of the specified type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService">
            <summary>
            Temporarily stores text and streams in memory mapped files.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo">
            <summary>
            Our own abstraction on top of memory map file so that we can have shared views over mmf files. 
            Otherwise, each view has minimum size of 64K due to requirement forced by windows.
            
            most of our view will have short lifetime, but there are cases where view might live a bit longer such as
            metadata dll shadow copy. shared view will help those cases.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo._streamCount">
            <summary>
            ref count of stream given out
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo._accessor">
            <summary>
            actual memory accessor that owns the VM
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.Name">
            <summary>
            Name and Size of memory map file
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateReadableStream">
            <summary>
            Caller is responsible for disposing the returned stream.
            multiple call of this will not increase VM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream">
            <summary>
            Caller is responsible for disposing the returned stream.
            multiple call of this will increase VM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.SharedReadableStream.GetPointer">
            <summary>
            Get underlying native memory directly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.SharedReadableStream.AcquirePointer(System.IO.MemoryMappedFiles.MemoryMappedViewAccessor)">
            <summary>
            Acquire the fixed pointer to the start of the memory mapped view.
            The pointer will be released during <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.SharedReadableStream.Dispose(System.Boolean)"/>
            </summary>
            <returns>The pointer to the start of the memory mapped view. The pointer is valid, and remains fixed for the lifetime of this object.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace">
            <summary>
            A workspace that can be populated by opening MSBuild solution and project files.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Create">
            <summary>
            Create a new instance of a workspace that can be populated by opening solution and project files.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Create(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Create a new instance of a workspace that can be populated by opening solution and project files.
            </summary>
            <param name="properties">An optional set of MSBuild properties used when interpreting project files.
            These are the same properties that are passed to msbuild via the /property:&lt;n&gt;=&lt;v&gt; command line argument.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Create(Microsoft.CodeAnalysis.Host.HostServices)">
            <summary>
            Create a new instance of a workspace that can be populated by opening solution and project files.
            </summary>
            <param name="hostServices">The <see cref="T:Microsoft.CodeAnalysis.Host.HostServices"/> used to configure this workspace.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Create(System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.CodeAnalysis.Host.HostServices)">
            <summary>
            Create a new instance of a workspace that can be populated by opening solution and project files.
            </summary>
            <param name="properties">The MSBuild properties used when interpreting project files.
            These are the same properties that are passed to msbuild via the /property:&lt;n&gt;=&lt;v&gt; command line argument.</param>
            <param name="hostServices">The <see cref="T:Microsoft.CodeAnalysis.Host.HostServices"/> used to configure this workspace.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Properties">
            <summary>
            The MSBuild properties used when interpreting project files.
            These are the same properties that are passed to msbuild via the /property:&lt;n&gt;=&lt;v&gt; command line argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Diagnostics">
            <summary>
            Diagnostics logged while opening solutions, projects and documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.LoadMetadataForReferencedProjects">
            <summary>
            Determines if metadata from existing output assemblies is loaded instead of opening referenced projects.
            If the referenced project is already opened, the metadata will not be loaded.
            If the metadata assembly cannot be found the referenced project will be opened instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.SkipUnrecognizedProjects">
            <summary>
            Determines if unrecognized projects are skipped when solutions or projects are opened.
            
            An project is unrecognized if it either has 
              a) an invalid file path, 
              b) a non-existent project file,
              c) has an unrecognized file extension or 
              d) a file extension associated with an unsupported language.
            
            If unrecognized projects cannot be skipped a corresponding exception is thrown.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.AssociateFileExtensionWithLanguage(System.String,System.String)">
            <summary>
            Associates a project file extension with a language name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.CloseSolution">
            <summary>
            Close the open solution, and reset the workspace to a new empty solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.OpenSolutionAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Open a solution file and all referenced projects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.OpenProjectAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Open a project file and all referenced projects.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo">
            <summary>
            Represents a source file that is part of a project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.FilePath">
            <summary>
            The absolute path to the document file on disk.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.LogicalPath">
            <summary>
            A fictional path to the document, relative to the project.
            The document may not actually exist at this location, and is used
            to represent linked documents. This includes the file name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.IsLinked">
            <summary>
            True if the document has a logical path that differs from its 
            absolute file path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.IsGenerated">
            <summary>
            True if the file was generated during build.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.IProjectFile">
            <summary>
            Represents a project file loaded from disk.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.IProjectFile.FilePath">
            <summary>
            The path to the project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.IProjectFile.ErrorMessage">
            <summary>
            The error message produced when a failure occurred attempting to access the project file. 
            If a failure occurred the projectd file info will be inaccessible.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.GetProjectFileInfoAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the project file info asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.GetSourceCodeKind(System.String)">
            <summary>
            Get the kind of source found in the specified file. 
            This is usually determined by the file name extension.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.GetDocumentExtension(Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Gets the corresponding extension for a source file of a given kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.AddDocument(System.String,System.String)">
            <summary>
            Add a source document to a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.RemoveDocument(System.String)">
            <summary>
            Remove a source document from a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.AddMetadataReference(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
             Add a metadata reference to a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.RemoveMetadataReference(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            Remove a metadata reference from a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.AddProjectReference(System.String,Microsoft.CodeAnalysis.MSBuild.ProjectFileReference)">
            <summary>
            Add a reference to another project to a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.RemoveProjectReference(System.String,System.String)">
            <summary>
            Remove a reference to another project from a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.AddAnalyzerReference(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Add an analyzer reference to the project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.RemoveAnalyzerReference(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Remove an analyzer reference from the project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.Save">
            <summary>
            Save the current state of the project file to disk.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.ProjectFile.CreateProjectFileReference(Microsoft.Build.Execution.ProjectItemInstance)">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference"/> from a ProjectReference node in the MSBuild file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.ProjectFile.GetAbsolutePath(System.String)">
            <summary>
            Resolves the given path that is possibly relative to the project directory.
            </summary>
            <remarks>
            The resulting path is absolute but might not be normalized.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo">
            <summary>
            Represents a project file loaded from disk.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.OutputFilePath">
            <summary>
            The path to the output file this project generates.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.AssemblyName">
            <summary>
            The assembly name of the output.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.CommandLineArgs">
            <summary>
            The command line args used to compile the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.Documents">
            <summary>
            The source documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.AdditionalDocuments">
            <summary>
            The additional documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.ProjectReferences">
            <summary>
            References to other projects.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.ErrorMessage">
            <summary>
            The error message produced when a failure occurred attempting to get the info. 
            If a failure occurred some or all of the information may be inaccurate or incomplete.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference">
            <summary>
            Represents a reference to another project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference.Path">
            <summary>
            The path on disk to the other project file. 
            This path may be relative to the referencing project's file or an absolute path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference.Aliases">
            <summary>
            The aliases assigned to this reference, if any.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.SectionBlock">
            <summary>
            Represents a SectionBlock in a .sln file. Section blocks are of the form:
            
            Type(ParenthesizedName) = Value
                Key = Value
                [more keys/values]
            EndType
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader">
            <summary>
            An API for loading msbuild project files.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.#ctor(Microsoft.CodeAnalysis.Workspace,System.Collections.Immutable.ImmutableDictionary{System.String,System.String})">
            <summary>
            Create a new instance of an <see cref="T:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.Properties">
            <summary>
            The MSBuild properties used when interpreting project files.
            These are the same properties that are passed to msbuild via the /property:&lt;n&gt;=&lt;v&gt; command line argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.LoadMetadataForReferencedProjects">
            <summary>
            Determines if metadata from existing output assemblies is loaded instead of opening referenced projects.
            If the referenced project is already opened, the metadata will not be loaded.
            If the metadata assembly cannot be found the referenced project will be opened instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.SkipUnrecognizedProjects">
            <summary>
            Determines if unrecognized projects are skipped when solutions or projects are opened.
            
            A project is unrecognized if it either has 
              a) an invalid file path, 
              b) a non-existent project file,
              c) has an unrecognized file extension or 
              d) a file extension associated with an unsupported language.
            
            If unrecognized projects cannot be skipped a corresponding exception is thrown.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.AssociateFileExtensionWithLanguage(System.String,System.String)">
            <summary>
            Associates a project file extension with a language name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.LoadSolutionInfoAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Loads the <see cref="T:Microsoft.CodeAnalysis.SolutionInfo"/> for the specified solution file, including all projects referenced by the solution file and 
            all the projects referenced by the project files.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.LoadProjectInfoAsync(System.String,System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ProjectId},System.Threading.CancellationToken)">
            <summary>
            Loads the <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/> from the specified project file and all referenced projects.
            The first <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/> in the result corresponds to the specified project file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.LoadState._projectAlreadyReferencesProjectResultCache">
            <summary>
            Used to memoize results of <see cref="M:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.LoadState.ProjectAlreadyReferencesProject(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectId)"/> calls.
            Reset any time internal state is changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.LoadState.ProjectAlreadyReferencesProject(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Returns true if the project identified by <paramref name="fromProject"/> has a reference (even indirectly)
            on the project identified by <paramref name="targetProject"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildProjectLoader.GetProjectMetadata(System.String,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Gets a MetadataReference to a project's output assembly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionSize.SolutionSizeTracker">
            <summary>
            Track approximate solution size.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionSize.SolutionSizeTracker.GetSolutionSize(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.SolutionId)">
            <summary>
            Get approximate solution size at the point of call.
            
            This API is not supposed to return 100% accurate size. 
            
            if a feature require 100% accurate size, use Solution to calculate it. this API is supposed to
            lazy and very cheap on answering that question.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.Interop.ResettableSqlStatement">
             <summary>
             Simple wrapper struct for a <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/> that helps ensure that the statement
             is always <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Reset"/> after it is used.
             
             See https://sqlite.org/c3ref/stmt.html:
             The life-cycle of a prepared statement object usually goes like this:
                1) Create the prepared statement object using sqlite3_prepare_v2().
                2) Bind values to parameters using the sqlite3_bind_* () interfaces.
                3) Run the SQL by calling sqlite3_step() one or more times.
                4) Reset the prepared statement using sqlite3_reset() then go back to step 2. Do this zero or more times.
                5) Destroy the object using sqlite3_finalize().
            
             This type helps ensure that '4' happens properly by clients executing statement.
             Note that destroying/finalizing a statement is not the responsibility of a client
             as it will happen to all prepared statemnets when the <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/> is
             <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Close_OnlyForUseBySqlConnection"/>d.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection">
            <summary>
            Encapsulates a connection to a sqlite database.  On construction an attempt will be made
            to open the DB if it exists, or create it if it does not.
            
            Connections are considered relatively heavyweight and are pooled until the <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage"/>
            is <see cref="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Close"/>d.  Connections can be used by different threads,
            but only as long as they are used by one thread at a time.  They are not safe for concurrent
            use by several threads.
            
            <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/>s can be created through the user of <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.GetResettableStatement(System.String)"/>.
            These statements are cached for the lifetime of the connection and are only finalized
            (i.e. destroyed) when the connection is closed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection._handle">
            <summary>
            The raw handle to the underlying DB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection._queryToStatement">
            <summary>
            Our cache of prepared statements for given sql strings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.IsInTransaction">
            <summary>
            Whether or not we're in a transaction.  We currently don't supported nested transactions.
            If we want that, we can achieve it through sqlite "save points".  However, that's adds a 
            lot of complexity that is nice to avoid.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement">
            <summary>
            Represents a prepared sqlite statement.  <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/>s can be 
            <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Step(System.Boolean)"/>ed (i.e. executed).  Executing a statement can result in 
            either <see cref="F:Microsoft.CodeAnalysis.SQLite.Interop.Result.DONE"/> if the command completed and produced no
            value, or <see cref="F:Microsoft.CodeAnalysis.SQLite.Interop.Result.ROW"/> if it evaluated out to a sql row that can
            then be queried.
            
            If a statement is parameterized then parameters can be provided by the 
            BindXXX overloads.  Bind is 1-based (to match sqlite).  
            
            When done executing a statement, the statement should be <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Reset"/>.
            The easiest way to ensure this is to just use a 'using' statement along with
            a <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.ResettableSqlStatement"/>.  By resetting the statement, it can
            then be used in the future with new bound parameters.
            
            Finalization/destruction of the underlying raw sqlite statement is handled
            by <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.Close_OnlyForUseBySqlPersistentStorage"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage">
            <summary>
            Implementation of an <see cref="T:Microsoft.CodeAnalysis.Host.IPersistentStorage"/> backed by SQLite.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3">
            <summary>
            Abstracts out access to specific tables in the DB.  This allows us to share overall
            logic around cancellation/pooling/error-handling/etc, while still hitting different
            db tables.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3._writeQueueKeyToWrites">
            <summary>
            Queue of actions we want to perform all at once against the DB in a single transaction.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3._writeQueueKeyToCountdown">
            <summary>
            Keep track of how many threads are trying to write out this particular queue.  All threads
            trying to write out the queue will wait until all the writes are done.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.StringInfoTableName">
            <summary>
            Inside the DB we have a table dedicated to storing strings that also provides a unique 
            integral ID per string.  This allows us to store data keyed in a much more efficient
            manner as we can use those IDs instead of duplicating strings all over the place.  For
            example, there may be many pieces of data associated with a file.  We don't want to 
            key off the file path in all these places as that would cause a large amount of bloat.
            
            Because the string table can map from arbitrary strings to unique IDs, it can also be
            used to create IDs for compound objects.  For example, given the IDs for the FilePath
            and Name of a Project, we can get an ID that represents the project itself by just
            creating a compound key of those two IDs.  This ID can then be used in other compound
            situations.  For example, a Document's ID is creating by compounding its Project's 
            ID, along with the IDs for the Document's FilePath and Name.
            
            The format of the table is:
            
             StringInfo
             --------------------------------------------------------------
             | Id (integer, primary key, auto increment) | Data (varchar) |
             --------------------------------------------------------------
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.SolutionDataTableName">
            <summary>
            Inside the DB we have a table for data corresponding to the <see cref="T:Microsoft.CodeAnalysis.Solution"/>.  The 
            data is just a blob that is keyed by a string Id.  Data with this ID can be retrieved
            or overwritten.
            
            The format of the table is:
            
             SolutionData
             -----------------------------------------------
             | DataId (primary key, varchar) | Data (blob) |
             -----------------------------------------------
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ProjectDataTableName">
            <summary>
            Inside the DB we have a table for data that we want associated with a <see cref="T:Microsoft.CodeAnalysis.Project"/>.
            The data is keyed off of an integral value produced by combining the ID of the Project and
            the ID of the name of the data (see <see cref="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ReadStreamAsync(Microsoft.CodeAnalysis.Project,System.String,System.Threading.CancellationToken)"/>.
            
            This gives a very efficient integral key, and means that the we only have to store a 
            single mapping from stream name to ID in the string table.
            
            The format of the table is:
            
             ProjectData
             -----------------------------------------------
             | DataId (primary key, integer) | Data (blob) |
             -----------------------------------------------
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.DocumentDataTableName">
            <summary>
            Inside the DB we have a table for data that we want associated with a <see cref="T:Microsoft.CodeAnalysis.Document"/>.
            The data is keyed off of an integral value produced by combining the ID of the Document and
            the ID of the name of the data (see <see cref="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ReadStreamAsync(Microsoft.CodeAnalysis.Document,System.String,System.Threading.CancellationToken)"/>.
            
            This gives a very efficient integral key, and means that the we only have to store a 
            single mapping from stream name to ID in the string table.
            
            The format of the table is:
            
             DocumentData
             ----------------------------------------------
             | DataId (primary key, integer) | Data (blob) |
             ----------------------------------------------
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.DocumentAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3"/> responsible for storing and 
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.DocumentDataTableName"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._projectIdToIdMap">
            <summary>
            Mapping from the workspace's ID for a project, to the ID we use in the DB for the project.
            Kept locally so we don't have to hit the DB for the common case of trying to determine the 
            DB id for a project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.TryGetProjectDataId(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Project,System.String,System.Int64@)">
            <summary>
            Given a project, and the name of a stream to read/write, gets the integral DB ID to 
            use to find the data inside the ProjectData table.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ProjectAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3"/> responsible for storing and
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ProjectDataTableName"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.FlushAllDelayMS">
            <summary>
            Amount of time to wait between flushing writes to disk.  250ms means we can flush
            writes to disk four times a second.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.MaxPooledByteArrayLength">
            <summary>
            We use a pool to cache reads/writes that are less than 4k.  Testing with Roslyn,
            99% of all writes (48.5k out of 49.5k) are less than that size.  So this helps
            ensure that we can pool as much as possible, without caching excessively large 
            arrays (for example, Roslyn does write out nearly 50 chunks that are larger than
            100k each).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.MaxPooledByteArrays">
            <summary>
            The max amount of byte[]s we cache.  This caps our cache at 4MB while allowing
            us to massively speed up writing (by batching writes).  Because we can write to
            disk 4 times a second.  That means a total of 16MB/s that can be written to disk
            using only our cache.  Given that Roslyn itself only writes about 50MB to disk
            after several minutes of analysis, this amount of bandwidth is more than sufficient.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._documentIdToIdMap">
            <summary>
            Mapping from the workspace's ID for a document, to the ID we use in the DB for the document.
            Kept locally so we don't have to hit the DB for the common case of trying to determine the 
            DB id for a document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.TryGetDocumentDataId(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Document,System.String,System.Int64@)">
            <summary>
            Given a document, and the name of a stream to read/write, gets the integral DB ID to 
            use to find the data inside the DocumentData table.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.SolutionAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3"/> responsible for storing and 
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.SolutionDataTableName"/>.  Note that with the Solution 
            table there is no need for key->id translation.  i.e. the key acts as the ID itself.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._writeQueueGate">
            <summary>
            Lock protecting the write queues and <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._flushAllTask"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._flushAllTask">
            <summary>
            Task kicked off to actually do the work of flushing all data to the DB.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.BulkPopulateIds(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Solution,System.Boolean)">
            <remarks>
            We have a lot of ID information to put into the DB. IDs for all strings we intend to 
            intern, as well as compound IDs for our projects and documents. Inserting these 
            individually is far too slow as SQLite will lock the DB for each insert and will have
            to do all the journalling work to ensure ACID semantics.  To avoid that, we attempt
            to precompute all the information we'd need to put in the ID tables and perform it
            all at once per project.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.BulkPopulateProjectIdsWorker(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Project)">
            <summary>
            Returns 'true' if the bulk population succeeds, or false if it doesn't.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService">
            <summary>
            A service that enables storing and retrieving of information associated with solutions,
            projects or documents across runtime sessions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Storage.StorageOptions.SolutionSizeThreshold">
            <summary>
            Solution size threshold to start to use a DB (Default: 50MB)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StreamExtensions.TryReadAll(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Attempts to read all of the requested bytes from the stream into the buffer
            </summary>
            <returns>
            The number of bytes read. Less than <paramref name="count" /> will
            only be returned if the end of stream is reached before all bytes can be read.
            </returns>
            <remarks>
            Unlike <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> it is not guaranteed that
            the stream position or the output buffer will be unchanged if an exception is
            returned.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.EncodingExtensions.GetMaxCharCountOrThrowIfHuge(System.Text.Encoding,System.IO.Stream)">
            <summary>
            Get maximum char count needed to decode the entire stream.
            </summary>
            <exception cref="T:System.IO.IOException">Stream is so big that max char count can't fit in <see cref="T:System.Int32"/>.</exception> 
        </member>
        <member name="F:Roslyn.Utilities.FileKey.FullPath">
            <summary>
            Full case-insensitive path.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.FileKey.Timestamp">
            <summary>
            Last write time (UTC).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.#ctor(System.String,System.DateTime)">
            <summary>
            Constructor.
            </summary>
            <param name="fullPath">Full path.</param>
            <param name="timestamp">Last write time (UTC).</param>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.Create(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
    </members>
</doc>
