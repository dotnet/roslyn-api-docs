<Type Name="SymbolCallerInfo" FullName="Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo">
  <TypeSignature Language="C#" Value="public struct SymbolCallerInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit SymbolCallerInfo extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo" />
  <TypeSignature Language="VB.NET" Value="Public Structure SymbolCallerInfo" />
  <TypeSignature Language="F#" Value="type SymbolCallerInfo = struct" />
  <TypeSignature Language="C++ CLI" Value="public value class SymbolCallerInfo" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis.Workspaces</AssemblyName>
    <AssemblyVersion>2.9.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            Contains information about a call from one symbol to another.  The symbol making the call is
            stored in CallingSymbol and the symbol that the call was made to is stored in CalledSymbol.
            Whether or not the call is direct or indirect is also stored.  A direct call is a call that
            does not go through any other symbols in the inheritance hierarchy of CalledSymbol, while an
            indirect call does go through the inheritance hierarchy.  For example, calls through a base
            member that this symbol overrides, or through an interface member that this symbol
            implements will be considered 'indirect'. 
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="CalledSymbol">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.ISymbol CalledSymbol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.ISymbol CalledSymbol" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.CalledSymbol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CalledSymbol As ISymbol" />
      <MemberSignature Language="F#" Value="member this.CalledSymbol : Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.CalledSymbol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::ISymbol ^ CalledSymbol { Microsoft::CodeAnalysis::ISymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.Workspaces</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The symbol being called.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingSymbol">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.ISymbol CallingSymbol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.ISymbol CallingSymbol" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.CallingSymbol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CallingSymbol As ISymbol" />
      <MemberSignature Language="F#" Value="member this.CallingSymbol : Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.CallingSymbol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::ISymbol ^ CallingSymbol { Microsoft::CodeAnalysis::ISymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.Workspaces</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The symbol that is calling the symbol being called.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirect">
      <MemberSignature Language="C#" Value="public bool IsDirect { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirect" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.IsDirect" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirect As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsDirect : bool" Usage="Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.IsDirect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirect { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.Workspaces</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            True if the CallingSymbol is directly calling CalledSymbol.  False if it is calling a
            symbol in the inheritance hierarchy of the CalledSymbol.  For example, if the called
            symbol is a class method, then an indirect call might be through an interface method that
            the class method implements.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Locations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Location&gt; Locations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.Location&gt; Locations" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.Locations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Locations As IEnumerable(Of Location)" />
      <MemberSignature Language="F#" Value="member this.Locations : seq&lt;Microsoft.CodeAnalysis.Location&gt;" Usage="Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.Locations" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::Location ^&gt; ^ Locations { System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::Location ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.Workspaces</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Location&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The locations inside the calling symbol where the called symbol is referenced.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>