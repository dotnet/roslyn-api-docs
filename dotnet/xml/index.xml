<Overview>
  <Assemblies>
    <Assembly Name="Microsoft.CodeAnalysis.CSharp" Version="2.3.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 b5 fc 90 e7 02 7f 67 87 1e 77 3a 8f de 89 38 c8 1d d4 02 ba 65 b9 20 1d 60 59 3e 96 c4 92 65 1e 88 9c c1 3f 14 15 eb b5 3f ac 11 31 ae 0b d3 33 c5 ee 60 21 67 2d 97 18 ea 31 a8 ae bd 0d a0 07 2f 25 d8 7d ba 6f c9 0f fd 59 8e d4 da 35 e4 4c 39 8c 45 43 07 e8 e3 3b 84 26 14 3d ae c9 f5 96 83 6f 97 c8 f7 47 50 e5 97 5c 64 e2 18 9f 45 de f4 6b 2a 2b 12 47 ad c3 65 2b f5 c3 08 05 5d a9 ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.CodeAnalysis.CommitHash("57c813192bd494bb15aaa841f415f28f50438e19")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("2.3.1.61919")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("2.3.1-beta1-61919-13. Commit Hash: 57c813192bd494bb15aaa841f415f28f50438e19")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyMetadata("Serviceable", "True")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.ExpressionEvaluator.ExpressionCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("csc, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("csi, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Scripting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.InteractiveEditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CompilerServer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("VBCSCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("VBCSCompilerPortable, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Emit.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.WinRT.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.EnC.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Semantic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Symbol.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Syntax.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Test.Utilities.Desktop, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.ExpressionEvaluator.CSharp.ExpressionCompiler.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities.Desktop, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities.FX45, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Scripting.Destkop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Scripting.Desktop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.CSharp.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor2.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.CodeAnalysis.CSharp.Workspaces" Version="2.3.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 b5 fc 90 e7 02 7f 67 87 1e 77 3a 8f de 89 38 c8 1d d4 02 ba 65 b9 20 1d 60 59 3e 96 c4 92 65 1e 88 9c c1 3f 14 15 eb b5 3f ac 11 31 ae 0b d3 33 c5 ee 60 21 67 2d 97 18 ea 31 a8 ae bd 0d a0 07 2f 25 d8 7d ba 6f c9 0f fd 59 8e d4 da 35 e4 4c 39 8c 45 43 07 e8 e3 3b 84 26 14 3d ae c9 f5 96 83 6f 97 c8 f7 47 50 e5 97 5c 64 e2 18 9f 45 de f4 6b 2a 2b 12 47 ad c3 65 2b f5 c3 08 05 5d a9 ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("2.3.1.61919")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("2.3.1-beta1-61919-13. Commit Hash: 57c813192bd494bb15aaa841f415f28f50438e19")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyMetadata("Serviceable", "True")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.EditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Features, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.CSharp, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.InteractiveEditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.CSharp.Repl, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Hosting.Diagnostics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.InteractiveWindow.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.CSharp.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.CSharp2.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor2.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.CSharp.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.CSharp.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Services.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Test.Utilities2, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Next.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.CSharpBinding, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.CSharpBinding.Tests, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.CodeAnalysis.VisualBasic" Version="2.3.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 b5 fc 90 e7 02 7f 67 87 1e 77 3a 8f de 89 38 c8 1d d4 02 ba 65 b9 20 1d 60 59 3e 96 c4 92 65 1e 88 9c c1 3f 14 15 eb b5 3f ac 11 31 ae 0b d3 33 c5 ee 60 21 67 2d 97 18 ea 31 a8 ae bd 0d a0 07 2f 25 d8 7d ba 6f c9 0f fd 59 8e d4 da 35 e4 4c 39 8c 45 43 07 e8 e3 3b 84 26 14 3d ae c9 f5 96 83 6f 97 c8 f7 47 50 e5 97 5c 64 e2 18 9f 45 de f4 6b 2a 2b 12 47 ad c3 65 2b f5 c3 08 05 5d a9 ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.CodeAnalysis.CommitHash("57c813192bd494bb15aaa841f415f28f50438e19")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("2.3.1.61919")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("2.3.1-beta1-61919-13. Commit Hash: 57c813192bd494bb15aaa841f415f28f50438e19")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyMetadata("Serviceable", "True")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.ExpressionEvaluator.ExpressionCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.Scripting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.InteractiveEditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("vbc, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("vbi, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CompilerServer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("VBCSCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("VBCSCompilerPortable, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Emit.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Semantic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Symbol.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Syntax.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Test.Utilities.Desktop, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.ExpressionEvaluator.VisualBasic.ExpressionCompiler.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.ExpressionEvaluator.ExpressionCompiler.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities.Desktop, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities.FX45, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Scripting.Desktop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.Scripting.Desktop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Services.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.VisualBasic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor2.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.CodeAnalysis.VisualBasic.Workspaces" Version="2.3.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 b5 fc 90 e7 02 7f 67 87 1e 77 3a 8f de 89 38 c8 1d d4 02 ba 65 b9 20 1d 60 59 3e 96 c4 92 65 1e 88 9c c1 3f 14 15 eb b5 3f ac 11 31 ae 0b d3 33 c5 ee 60 21 67 2d 97 18 ea 31 a8 ae bd 0d a0 07 2f 25 d8 7d ba 6f c9 0f fd 59 8e d4 da 35 e4 4c 39 8c 45 43 07 e8 e3 3b 84 26 14 3d ae c9 f5 96 83 6f 97 c8 f7 47 50 e5 97 5c 64 e2 18 9f 45 de f4 6b 2a 2b 12 47 ad c3 65 2b f5 c3 08 05 5d a9 ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("2.3.1.61919")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("2.3.1-beta1-61919-13. Commit Hash: 57c813192bd494bb15aaa841f415f28f50438e19")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyMetadata("Serviceable", "True")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.EditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.Features, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.VisualBasic, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.InteractiveEditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.VisualBasic.Repl, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Hosting.Diagnostics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Test.Utilities2, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor2.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.VisualBasic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.VisualBasic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Services.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Test.Utilities2, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.VBNetBinding.Tests, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
  </Assemblies>
  <Remarks>To be added.</Remarks>
  <Copyright>To be added.</Copyright>
  <Types>
    <Namespace Name="Microsoft.CodeAnalysis">
      <Type Name="CSharpExtensions" Kind="Class" />
      <Type Name="VisualBasicExtensions" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.CSharp">
      <Type Name="AwaitExpressionInfo" Kind="Structure" />
      <Type Name="Conversion" Kind="Structure" />
      <Type Name="CSharpCommandLineArguments" Kind="Class" />
      <Type Name="CSharpCommandLineParser" Kind="Class" />
      <Type Name="CSharpCompilation" Kind="Class" />
      <Type Name="CSharpCompilationOptions" Kind="Class" />
      <Type Name="CSharpDiagnosticFormatter" Kind="Class" />
      <Type Name="CSharpExtensions" Kind="Class" />
      <Type Name="CSharpFileSystemExtensions" Kind="Class" />
      <Type Name="CSharpParseOptions" Kind="Class" />
      <Type Name="CSharpScriptCompilationInfo" Kind="Class" />
      <Type Name="CSharpSyntaxNode" Kind="Class" />
      <Type Name="CSharpSyntaxRewriter" Kind="Class" />
      <Type Name="CSharpSyntaxTree" Kind="Class" />
      <Type Name="CSharpSyntaxVisitor" Kind="Class" />
      <Type Name="CSharpSyntaxVisitor`1" DisplayName="CSharpSyntaxVisitor&lt;TResult&gt;" Kind="Class" />
      <Type Name="CSharpSyntaxWalker" Kind="Class" />
      <Type Name="ForEachStatementInfo" Kind="Structure" />
      <Type Name="LanguageVersion" Kind="Enumeration" />
      <Type Name="LanguageVersionFacts" Kind="Class" />
      <Type Name="QueryClauseInfo" Kind="Structure" />
      <Type Name="SymbolDisplay" Kind="Class" />
      <Type Name="SyntaxExtensions" Kind="Class" />
      <Type Name="SyntaxFactory" Kind="Class" />
      <Type Name="SyntaxFacts" Kind="Class" />
      <Type Name="SyntaxKind" Kind="Enumeration" />
      <Type Name="TypedConstantExtensions" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.CSharp.Formatting">
      <Type Name="BinaryOperatorSpacingOptions" Kind="Enumeration" />
      <Type Name="CSharpFormattingOptions" Kind="Class" />
      <Type Name="LabelPositionOptions" Kind="Enumeration" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.CSharp.Syntax">
      <Type Name="AccessorDeclarationSyntax" Kind="Class" />
      <Type Name="AccessorListSyntax" Kind="Class" />
      <Type Name="AliasQualifiedNameSyntax" Kind="Class" />
      <Type Name="AnonymousFunctionExpressionSyntax" Kind="Class" />
      <Type Name="AnonymousMethodExpressionSyntax" Kind="Class" />
      <Type Name="AnonymousObjectCreationExpressionSyntax" Kind="Class" />
      <Type Name="AnonymousObjectMemberDeclaratorSyntax" Kind="Class" />
      <Type Name="ArgumentListSyntax" Kind="Class" />
      <Type Name="ArgumentSyntax" Kind="Class" />
      <Type Name="ArrayCreationExpressionSyntax" Kind="Class" />
      <Type Name="ArrayRankSpecifierSyntax" Kind="Class" />
      <Type Name="ArrayTypeSyntax" Kind="Class" />
      <Type Name="ArrowExpressionClauseSyntax" Kind="Class" />
      <Type Name="AssignmentExpressionSyntax" Kind="Class" />
      <Type Name="AttributeArgumentListSyntax" Kind="Class" />
      <Type Name="AttributeArgumentSyntax" Kind="Class" />
      <Type Name="AttributeListSyntax" Kind="Class" />
      <Type Name="AttributeSyntax" Kind="Class" />
      <Type Name="AttributeTargetSpecifierSyntax" Kind="Class" />
      <Type Name="AwaitExpressionSyntax" Kind="Class" />
      <Type Name="BadDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="BaseArgumentListSyntax" Kind="Class" />
      <Type Name="BaseCrefParameterListSyntax" Kind="Class" />
      <Type Name="BaseExpressionSyntax" Kind="Class" />
      <Type Name="BaseFieldDeclarationSyntax" Kind="Class" />
      <Type Name="BaseListSyntax" Kind="Class" />
      <Type Name="BaseMethodDeclarationSyntax" Kind="Class" />
      <Type Name="BaseParameterListSyntax" Kind="Class" />
      <Type Name="BasePropertyDeclarationSyntax" Kind="Class" />
      <Type Name="BaseTypeDeclarationSyntax" Kind="Class" />
      <Type Name="BaseTypeSyntax" Kind="Class" />
      <Type Name="BinaryExpressionSyntax" Kind="Class" />
      <Type Name="BlockSyntax" Kind="Class" />
      <Type Name="BracketedArgumentListSyntax" Kind="Class" />
      <Type Name="BracketedParameterListSyntax" Kind="Class" />
      <Type Name="BranchingDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="BreakStatementSyntax" Kind="Class" />
      <Type Name="CasePatternSwitchLabelSyntax" Kind="Class" />
      <Type Name="CaseSwitchLabelSyntax" Kind="Class" />
      <Type Name="CastExpressionSyntax" Kind="Class" />
      <Type Name="CatchClauseSyntax" Kind="Class" />
      <Type Name="CatchDeclarationSyntax" Kind="Class" />
      <Type Name="CatchFilterClauseSyntax" Kind="Class" />
      <Type Name="CheckedExpressionSyntax" Kind="Class" />
      <Type Name="CheckedStatementSyntax" Kind="Class" />
      <Type Name="ClassDeclarationSyntax" Kind="Class" />
      <Type Name="ClassOrStructConstraintSyntax" Kind="Class" />
      <Type Name="CommonForEachStatementSyntax" Kind="Class" />
      <Type Name="CompilationUnitSyntax" Kind="Class" />
      <Type Name="ConditionalAccessExpressionSyntax" Kind="Class" />
      <Type Name="ConditionalDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="ConditionalExpressionSyntax" Kind="Class" />
      <Type Name="ConstantPatternSyntax" Kind="Class" />
      <Type Name="ConstructorConstraintSyntax" Kind="Class" />
      <Type Name="ConstructorDeclarationSyntax" Kind="Class" />
      <Type Name="ConstructorInitializerSyntax" Kind="Class" />
      <Type Name="ContinueStatementSyntax" Kind="Class" />
      <Type Name="ConversionOperatorDeclarationSyntax" Kind="Class" />
      <Type Name="ConversionOperatorMemberCrefSyntax" Kind="Class" />
      <Type Name="CrefBracketedParameterListSyntax" Kind="Class" />
      <Type Name="CrefParameterListSyntax" Kind="Class" />
      <Type Name="CrefParameterSyntax" Kind="Class" />
      <Type Name="CrefSyntax" Kind="Class" />
      <Type Name="DeclarationExpressionSyntax" Kind="Class" />
      <Type Name="DeclarationPatternSyntax" Kind="Class" />
      <Type Name="DefaultExpressionSyntax" Kind="Class" />
      <Type Name="DefaultSwitchLabelSyntax" Kind="Class" />
      <Type Name="DefineDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="DelegateDeclarationSyntax" Kind="Class" />
      <Type Name="DestructorDeclarationSyntax" Kind="Class" />
      <Type Name="DirectiveTriviaSyntax" Kind="Class" />
      <Type Name="DiscardDesignationSyntax" Kind="Class" />
      <Type Name="DocumentationCommentTriviaSyntax" Kind="Class" />
      <Type Name="DoStatementSyntax" Kind="Class" />
      <Type Name="ElementAccessExpressionSyntax" Kind="Class" />
      <Type Name="ElementBindingExpressionSyntax" Kind="Class" />
      <Type Name="ElifDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="ElseClauseSyntax" Kind="Class" />
      <Type Name="ElseDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EmptyStatementSyntax" Kind="Class" />
      <Type Name="EndIfDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EndRegionDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EnumDeclarationSyntax" Kind="Class" />
      <Type Name="EnumMemberDeclarationSyntax" Kind="Class" />
      <Type Name="EqualsValueClauseSyntax" Kind="Class" />
      <Type Name="ErrorDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EventDeclarationSyntax" Kind="Class" />
      <Type Name="EventFieldDeclarationSyntax" Kind="Class" />
      <Type Name="ExplicitInterfaceSpecifierSyntax" Kind="Class" />
      <Type Name="ExpressionStatementSyntax" Kind="Class" />
      <Type Name="ExpressionSyntax" Kind="Class" />
      <Type Name="ExternAliasDirectiveSyntax" Kind="Class" />
      <Type Name="FieldDeclarationSyntax" Kind="Class" />
      <Type Name="FinallyClauseSyntax" Kind="Class" />
      <Type Name="FixedStatementSyntax" Kind="Class" />
      <Type Name="ForEachStatementSyntax" Kind="Class" />
      <Type Name="ForEachVariableStatementSyntax" Kind="Class" />
      <Type Name="ForStatementSyntax" Kind="Class" />
      <Type Name="FromClauseSyntax" Kind="Class" />
      <Type Name="GenericNameSyntax" Kind="Class" />
      <Type Name="GlobalStatementSyntax" Kind="Class" />
      <Type Name="GotoStatementSyntax" Kind="Class" />
      <Type Name="GroupClauseSyntax" Kind="Class" />
      <Type Name="IdentifierNameSyntax" Kind="Class" />
      <Type Name="IfDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="IfStatementSyntax" Kind="Class" />
      <Type Name="ImplicitArrayCreationExpressionSyntax" Kind="Class" />
      <Type Name="ImplicitElementAccessSyntax" Kind="Class" />
      <Type Name="IncompleteMemberSyntax" Kind="Class" />
      <Type Name="IndexerDeclarationSyntax" Kind="Class" />
      <Type Name="IndexerMemberCrefSyntax" Kind="Class" />
      <Type Name="InitializerExpressionSyntax" Kind="Class" />
      <Type Name="InstanceExpressionSyntax" Kind="Class" />
      <Type Name="InterfaceDeclarationSyntax" Kind="Class" />
      <Type Name="InterpolatedStringContentSyntax" Kind="Class" />
      <Type Name="InterpolatedStringExpressionSyntax" Kind="Class" />
      <Type Name="InterpolatedStringTextSyntax" Kind="Class" />
      <Type Name="InterpolationAlignmentClauseSyntax" Kind="Class" />
      <Type Name="InterpolationFormatClauseSyntax" Kind="Class" />
      <Type Name="InterpolationSyntax" Kind="Class" />
      <Type Name="InvocationExpressionSyntax" Kind="Class" />
      <Type Name="IsPatternExpressionSyntax" Kind="Class" />
      <Type Name="JoinClauseSyntax" Kind="Class" />
      <Type Name="JoinIntoClauseSyntax" Kind="Class" />
      <Type Name="LabeledStatementSyntax" Kind="Class" />
      <Type Name="LambdaExpressionSyntax" Kind="Class" />
      <Type Name="LetClauseSyntax" Kind="Class" />
      <Type Name="LineDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="LiteralExpressionSyntax" Kind="Class" />
      <Type Name="LoadDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="LocalDeclarationStatementSyntax" Kind="Class" />
      <Type Name="LocalFunctionStatementSyntax" Kind="Class" />
      <Type Name="LockStatementSyntax" Kind="Class" />
      <Type Name="MakeRefExpressionSyntax" Kind="Class" />
      <Type Name="MemberAccessExpressionSyntax" Kind="Class" />
      <Type Name="MemberBindingExpressionSyntax" Kind="Class" />
      <Type Name="MemberCrefSyntax" Kind="Class" />
      <Type Name="MemberDeclarationSyntax" Kind="Class" />
      <Type Name="MethodDeclarationSyntax" Kind="Class" />
      <Type Name="NameColonSyntax" Kind="Class" />
      <Type Name="NameEqualsSyntax" Kind="Class" />
      <Type Name="NameMemberCrefSyntax" Kind="Class" />
      <Type Name="NamespaceDeclarationSyntax" Kind="Class" />
      <Type Name="NameSyntax" Kind="Class" />
      <Type Name="NullableTypeSyntax" Kind="Class" />
      <Type Name="ObjectCreationExpressionSyntax" Kind="Class" />
      <Type Name="OmittedArraySizeExpressionSyntax" Kind="Class" />
      <Type Name="OmittedTypeArgumentSyntax" Kind="Class" />
      <Type Name="OperatorDeclarationSyntax" Kind="Class" />
      <Type Name="OperatorMemberCrefSyntax" Kind="Class" />
      <Type Name="OrderByClauseSyntax" Kind="Class" />
      <Type Name="OrderingSyntax" Kind="Class" />
      <Type Name="ParameterListSyntax" Kind="Class" />
      <Type Name="ParameterSyntax" Kind="Class" />
      <Type Name="ParenthesizedExpressionSyntax" Kind="Class" />
      <Type Name="ParenthesizedLambdaExpressionSyntax" Kind="Class" />
      <Type Name="ParenthesizedVariableDesignationSyntax" Kind="Class" />
      <Type Name="PatternSyntax" Kind="Class" />
      <Type Name="PointerTypeSyntax" Kind="Class" />
      <Type Name="PostfixUnaryExpressionSyntax" Kind="Class" />
      <Type Name="PragmaChecksumDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="PragmaWarningDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="PredefinedTypeSyntax" Kind="Class" />
      <Type Name="PrefixUnaryExpressionSyntax" Kind="Class" />
      <Type Name="PropertyDeclarationSyntax" Kind="Class" />
      <Type Name="QualifiedCrefSyntax" Kind="Class" />
      <Type Name="QualifiedNameSyntax" Kind="Class" />
      <Type Name="QueryBodySyntax" Kind="Class" />
      <Type Name="QueryClauseSyntax" Kind="Class" />
      <Type Name="QueryContinuationSyntax" Kind="Class" />
      <Type Name="QueryExpressionSyntax" Kind="Class" />
      <Type Name="ReferenceDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="RefExpressionSyntax" Kind="Class" />
      <Type Name="RefTypeExpressionSyntax" Kind="Class" />
      <Type Name="RefTypeSyntax" Kind="Class" />
      <Type Name="RefValueExpressionSyntax" Kind="Class" />
      <Type Name="RegionDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="ReturnStatementSyntax" Kind="Class" />
      <Type Name="SelectClauseSyntax" Kind="Class" />
      <Type Name="SelectOrGroupClauseSyntax" Kind="Class" />
      <Type Name="ShebangDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="SimpleBaseTypeSyntax" Kind="Class" />
      <Type Name="SimpleLambdaExpressionSyntax" Kind="Class" />
      <Type Name="SimpleNameSyntax" Kind="Class" />
      <Type Name="SingleVariableDesignationSyntax" Kind="Class" />
      <Type Name="SizeOfExpressionSyntax" Kind="Class" />
      <Type Name="SkippedTokensTriviaSyntax" Kind="Class" />
      <Type Name="StackAllocArrayCreationExpressionSyntax" Kind="Class" />
      <Type Name="StatementSyntax" Kind="Class" />
      <Type Name="StructDeclarationSyntax" Kind="Class" />
      <Type Name="StructuredTriviaSyntax" Kind="Class" />
      <Type Name="SwitchLabelSyntax" Kind="Class" />
      <Type Name="SwitchSectionSyntax" Kind="Class" />
      <Type Name="SwitchStatementSyntax" Kind="Class" />
      <Type Name="ThisExpressionSyntax" Kind="Class" />
      <Type Name="ThrowExpressionSyntax" Kind="Class" />
      <Type Name="ThrowStatementSyntax" Kind="Class" />
      <Type Name="TryStatementSyntax" Kind="Class" />
      <Type Name="TupleElementSyntax" Kind="Class" />
      <Type Name="TupleExpressionSyntax" Kind="Class" />
      <Type Name="TupleTypeSyntax" Kind="Class" />
      <Type Name="TypeArgumentListSyntax" Kind="Class" />
      <Type Name="TypeConstraintSyntax" Kind="Class" />
      <Type Name="TypeCrefSyntax" Kind="Class" />
      <Type Name="TypeDeclarationSyntax" Kind="Class" />
      <Type Name="TypeOfExpressionSyntax" Kind="Class" />
      <Type Name="TypeParameterConstraintClauseSyntax" Kind="Class" />
      <Type Name="TypeParameterConstraintSyntax" Kind="Class" />
      <Type Name="TypeParameterListSyntax" Kind="Class" />
      <Type Name="TypeParameterSyntax" Kind="Class" />
      <Type Name="TypeSyntax" Kind="Class" />
      <Type Name="UndefDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="UnsafeStatementSyntax" Kind="Class" />
      <Type Name="UsingDirectiveSyntax" Kind="Class" />
      <Type Name="UsingStatementSyntax" Kind="Class" />
      <Type Name="VariableDeclarationSyntax" Kind="Class" />
      <Type Name="VariableDeclaratorSyntax" Kind="Class" />
      <Type Name="VariableDesignationSyntax" Kind="Class" />
      <Type Name="WarningDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="WhenClauseSyntax" Kind="Class" />
      <Type Name="WhereClauseSyntax" Kind="Class" />
      <Type Name="WhileStatementSyntax" Kind="Class" />
      <Type Name="XmlAttributeSyntax" Kind="Class" />
      <Type Name="XmlCDataSectionSyntax" Kind="Class" />
      <Type Name="XmlCommentSyntax" Kind="Class" />
      <Type Name="XmlCrefAttributeSyntax" Kind="Class" />
      <Type Name="XmlElementEndTagSyntax" Kind="Class" />
      <Type Name="XmlElementStartTagSyntax" Kind="Class" />
      <Type Name="XmlElementSyntax" Kind="Class" />
      <Type Name="XmlEmptyElementSyntax" Kind="Class" />
      <Type Name="XmlNameAttributeElementKind" Kind="Enumeration" />
      <Type Name="XmlNameAttributeSyntax" Kind="Class" />
      <Type Name="XmlNameSyntax" Kind="Class" />
      <Type Name="XmlNodeSyntax" Kind="Class" />
      <Type Name="XmlPrefixSyntax" Kind="Class" />
      <Type Name="XmlProcessingInstructionSyntax" Kind="Class" />
      <Type Name="XmlTextAttributeSyntax" Kind="Class" />
      <Type Name="XmlTextSyntax" Kind="Class" />
      <Type Name="YieldStatementSyntax" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.VisualBasic">
      <Type Name="AggregateClauseSymbolInfo" Kind="Structure" />
      <Type Name="AwaitExpressionInfo" Kind="Structure" />
      <Type Name="CollectionRangeVariableSymbolInfo" Kind="Structure" />
      <Type Name="Conversion" Kind="Structure" />
      <Type Name="ForEachStatementInfo" Kind="Structure" />
      <Type Name="GeneratedExtensionSyntaxFacts" Kind="Class" />
      <Type Name="GlobalImport" Kind="Class" />
      <Type Name="HandledEvent" Kind="Class" />
      <Type Name="HandledEventKind" Kind="Enumeration" />
      <Type Name="LanguageVersion" Kind="Enumeration" />
      <Type Name="LanguageVersionFacts" Kind="Class" />
      <Type Name="LocalizableErrorArgument" Kind="Structure" />
      <Type Name="OptionStrict" Kind="Enumeration" />
      <Type Name="PredefinedPreprocessorSymbols" Kind="Class" />
      <Type Name="SymbolDisplay" Kind="Class" />
      <Type Name="SyntaxExtensions" Kind="Class" />
      <Type Name="SyntaxFactory" Kind="Class" />
      <Type Name="SyntaxFacts" Kind="Class" />
      <Type Name="SyntaxKind" Kind="Enumeration" />
      <Type Name="TypedConstantExtensions" Kind="Class" />
      <Type Name="VisualBasicCommandLineArguments" Kind="Class" />
      <Type Name="VisualBasicCommandLineParser" Kind="Class" />
      <Type Name="VisualBasicCompilation" Kind="Class" />
      <Type Name="VisualBasicCompilationOptions" Kind="Class" />
      <Type Name="VisualBasicDiagnosticFormatter" Kind="Class" />
      <Type Name="VisualBasicExtensions" Kind="Class" />
      <Type Name="VisualBasicParseOptions" Kind="Class" />
      <Type Name="VisualBasicSyntaxNode" Kind="Class" />
      <Type Name="VisualBasicSyntaxRewriter" Kind="Class" />
      <Type Name="VisualBasicSyntaxTree" Kind="Class" />
      <Type Name="VisualBasicSyntaxVisitor" Kind="Class" />
      <Type Name="VisualBasicSyntaxVisitor`1" DisplayName="VisualBasicSyntaxVisitor&lt;TResult&gt;" Kind="Class" />
      <Type Name="VisualBasicSyntaxWalker" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.VisualBasic.Syntax">
      <Type Name="AccessorBlockSyntax" Kind="Class" />
      <Type Name="AccessorStatementSyntax" Kind="Class" />
      <Type Name="AddRemoveHandlerStatementSyntax" Kind="Class" />
      <Type Name="AggregateClauseSyntax" Kind="Class" />
      <Type Name="AggregationRangeVariableSyntax" Kind="Class" />
      <Type Name="AggregationSyntax" Kind="Class" />
      <Type Name="AnonymousObjectCreationExpressionSyntax" Kind="Class" />
      <Type Name="ArgumentListSyntax" Kind="Class" />
      <Type Name="ArgumentSyntax" Kind="Class" />
      <Type Name="ArrayCreationExpressionSyntax" Kind="Class" />
      <Type Name="ArrayRankSpecifierSyntax" Kind="Class" />
      <Type Name="ArrayTypeSyntax" Kind="Class" />
      <Type Name="AsClauseSyntax" Kind="Class" />
      <Type Name="AsNewClauseSyntax" Kind="Class" />
      <Type Name="AssignmentStatementSyntax" Kind="Class" />
      <Type Name="AttributeListSyntax" Kind="Class" />
      <Type Name="AttributesStatementSyntax" Kind="Class" />
      <Type Name="AttributeSyntax" Kind="Class" />
      <Type Name="AttributeTargetSyntax" Kind="Class" />
      <Type Name="AwaitExpressionSyntax" Kind="Class" />
      <Type Name="BadDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="BaseXmlAttributeSyntax" Kind="Class" />
      <Type Name="BinaryConditionalExpressionSyntax" Kind="Class" />
      <Type Name="BinaryExpressionSyntax" Kind="Class" />
      <Type Name="CallStatementSyntax" Kind="Class" />
      <Type Name="CaseBlockSyntax" Kind="Class" />
      <Type Name="CaseClauseSyntax" Kind="Class" />
      <Type Name="CaseStatementSyntax" Kind="Class" />
      <Type Name="CastExpressionSyntax" Kind="Class" />
      <Type Name="CatchBlockSyntax" Kind="Class" />
      <Type Name="CatchFilterClauseSyntax" Kind="Class" />
      <Type Name="CatchStatementSyntax" Kind="Class" />
      <Type Name="ClassBlockSyntax" Kind="Class" />
      <Type Name="ClassStatementSyntax" Kind="Class" />
      <Type Name="CollectionInitializerSyntax" Kind="Class" />
      <Type Name="CollectionRangeVariableSyntax" Kind="Class" />
      <Type Name="CompilationUnitSyntax" Kind="Class" />
      <Type Name="ConditionalAccessExpressionSyntax" Kind="Class" />
      <Type Name="ConstDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="ConstraintSyntax" Kind="Class" />
      <Type Name="ConstructorBlockSyntax" Kind="Class" />
      <Type Name="ContinueStatementSyntax" Kind="Class" />
      <Type Name="CrefOperatorReferenceSyntax" Kind="Class" />
      <Type Name="CrefReferenceSyntax" Kind="Class" />
      <Type Name="CrefSignaturePartSyntax" Kind="Class" />
      <Type Name="CrefSignatureSyntax" Kind="Class" />
      <Type Name="CTypeExpressionSyntax" Kind="Class" />
      <Type Name="DeclarationStatementSyntax" Kind="Class" />
      <Type Name="DeclareStatementSyntax" Kind="Class" />
      <Type Name="DelegateStatementSyntax" Kind="Class" />
      <Type Name="DirectCastExpressionSyntax" Kind="Class" />
      <Type Name="DirectiveTriviaSyntax" Kind="Class" />
      <Type Name="DisableWarningDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="DistinctClauseSyntax" Kind="Class" />
      <Type Name="DocumentationCommentTriviaSyntax" Kind="Class" />
      <Type Name="DoLoopBlockSyntax" Kind="Class" />
      <Type Name="DoStatementSyntax" Kind="Class" />
      <Type Name="ElseBlockSyntax" Kind="Class" />
      <Type Name="ElseCaseClauseSyntax" Kind="Class" />
      <Type Name="ElseDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="ElseIfBlockSyntax" Kind="Class" />
      <Type Name="ElseIfStatementSyntax" Kind="Class" />
      <Type Name="ElseStatementSyntax" Kind="Class" />
      <Type Name="EmptyStatementSyntax" Kind="Class" />
      <Type Name="EnableWarningDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EndBlockStatementSyntax" Kind="Class" />
      <Type Name="EndExternalSourceDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EndIfDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EndRegionDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EnumBlockSyntax" Kind="Class" />
      <Type Name="EnumMemberDeclarationSyntax" Kind="Class" />
      <Type Name="EnumStatementSyntax" Kind="Class" />
      <Type Name="EqualsValueSyntax" Kind="Class" />
      <Type Name="EraseStatementSyntax" Kind="Class" />
      <Type Name="ErrorStatementSyntax" Kind="Class" />
      <Type Name="EventBlockSyntax" Kind="Class" />
      <Type Name="EventContainerSyntax" Kind="Class" />
      <Type Name="EventStatementSyntax" Kind="Class" />
      <Type Name="ExecutableStatementSyntax" Kind="Class" />
      <Type Name="ExitStatementSyntax" Kind="Class" />
      <Type Name="ExpressionRangeVariableSyntax" Kind="Class" />
      <Type Name="ExpressionStatementSyntax" Kind="Class" />
      <Type Name="ExpressionSyntax" Kind="Class" />
      <Type Name="ExternalChecksumDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="ExternalSourceDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="FieldDeclarationSyntax" Kind="Class" />
      <Type Name="FieldInitializerSyntax" Kind="Class" />
      <Type Name="FinallyBlockSyntax" Kind="Class" />
      <Type Name="FinallyStatementSyntax" Kind="Class" />
      <Type Name="ForBlockSyntax" Kind="Class" />
      <Type Name="ForEachBlockSyntax" Kind="Class" />
      <Type Name="ForEachStatementSyntax" Kind="Class" />
      <Type Name="ForOrForEachBlockSyntax" Kind="Class" />
      <Type Name="ForOrForEachStatementSyntax" Kind="Class" />
      <Type Name="ForStatementSyntax" Kind="Class" />
      <Type Name="ForStepClauseSyntax" Kind="Class" />
      <Type Name="FromClauseSyntax" Kind="Class" />
      <Type Name="FunctionAggregationSyntax" Kind="Class" />
      <Type Name="GenericNameSyntax" Kind="Class" />
      <Type Name="GetTypeExpressionSyntax" Kind="Class" />
      <Type Name="GetXmlNamespaceExpressionSyntax" Kind="Class" />
      <Type Name="GlobalNameSyntax" Kind="Class" />
      <Type Name="GoToStatementSyntax" Kind="Class" />
      <Type Name="GroupAggregationSyntax" Kind="Class" />
      <Type Name="GroupByClauseSyntax" Kind="Class" />
      <Type Name="GroupJoinClauseSyntax" Kind="Class" />
      <Type Name="HandlesClauseItemSyntax" Kind="Class" />
      <Type Name="HandlesClauseSyntax" Kind="Class" />
      <Type Name="IdentifierNameSyntax" Kind="Class" />
      <Type Name="IfDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="IfStatementSyntax" Kind="Class" />
      <Type Name="ImplementsClauseSyntax" Kind="Class" />
      <Type Name="ImplementsStatementSyntax" Kind="Class" />
      <Type Name="ImportAliasClauseSyntax" Kind="Class" />
      <Type Name="ImportsClauseSyntax" Kind="Class" />
      <Type Name="ImportsStatementSyntax" Kind="Class" />
      <Type Name="IncompleteMemberSyntax" Kind="Class" />
      <Type Name="InferredFieldInitializerSyntax" Kind="Class" />
      <Type Name="InheritsOrImplementsStatementSyntax" Kind="Class" />
      <Type Name="InheritsStatementSyntax" Kind="Class" />
      <Type Name="InstanceExpressionSyntax" Kind="Class" />
      <Type Name="InterfaceBlockSyntax" Kind="Class" />
      <Type Name="InterfaceStatementSyntax" Kind="Class" />
      <Type Name="InterpolatedStringContentSyntax" Kind="Class" />
      <Type Name="InterpolatedStringExpressionSyntax" Kind="Class" />
      <Type Name="InterpolatedStringTextSyntax" Kind="Class" />
      <Type Name="InterpolationAlignmentClauseSyntax" Kind="Class" />
      <Type Name="InterpolationFormatClauseSyntax" Kind="Class" />
      <Type Name="InterpolationSyntax" Kind="Class" />
      <Type Name="InvocationExpressionSyntax" Kind="Class" />
      <Type Name="JoinClauseSyntax" Kind="Class" />
      <Type Name="JoinConditionSyntax" Kind="Class" />
      <Type Name="KeywordEventContainerSyntax" Kind="Class" />
      <Type Name="LabelStatementSyntax" Kind="Class" />
      <Type Name="LabelSyntax" Kind="Class" />
      <Type Name="LambdaExpressionSyntax" Kind="Class" />
      <Type Name="LambdaHeaderSyntax" Kind="Class" />
      <Type Name="LetClauseSyntax" Kind="Class" />
      <Type Name="LiteralBase" Kind="Enumeration" />
      <Type Name="LiteralExpressionSyntax" Kind="Class" />
      <Type Name="LocalDeclarationStatementSyntax" Kind="Class" />
      <Type Name="LoopStatementSyntax" Kind="Class" />
      <Type Name="MeExpressionSyntax" Kind="Class" />
      <Type Name="MemberAccessExpressionSyntax" Kind="Class" />
      <Type Name="MethodBaseSyntax" Kind="Class" />
      <Type Name="MethodBlockBaseSyntax" Kind="Class" />
      <Type Name="MethodBlockSyntax" Kind="Class" />
      <Type Name="MethodStatementSyntax" Kind="Class" />
      <Type Name="MidExpressionSyntax" Kind="Class" />
      <Type Name="ModifiedIdentifierSyntax" Kind="Class" />
      <Type Name="ModuleBlockSyntax" Kind="Class" />
      <Type Name="ModuleStatementSyntax" Kind="Class" />
      <Type Name="MultiLineIfBlockSyntax" Kind="Class" />
      <Type Name="MultiLineLambdaExpressionSyntax" Kind="Class" />
      <Type Name="MyBaseExpressionSyntax" Kind="Class" />
      <Type Name="MyClassExpressionSyntax" Kind="Class" />
      <Type Name="NameColonEqualsSyntax" Kind="Class" />
      <Type Name="NamedFieldInitializerSyntax" Kind="Class" />
      <Type Name="NamedTupleElementSyntax" Kind="Class" />
      <Type Name="NameOfExpressionSyntax" Kind="Class" />
      <Type Name="NamespaceBlockSyntax" Kind="Class" />
      <Type Name="NamespaceStatementSyntax" Kind="Class" />
      <Type Name="NameSyntax" Kind="Class" />
      <Type Name="NewExpressionSyntax" Kind="Class" />
      <Type Name="NextStatementSyntax" Kind="Class" />
      <Type Name="NullableTypeSyntax" Kind="Class" />
      <Type Name="ObjectCollectionInitializerSyntax" Kind="Class" />
      <Type Name="ObjectCreationExpressionSyntax" Kind="Class" />
      <Type Name="ObjectCreationInitializerSyntax" Kind="Class" />
      <Type Name="ObjectMemberInitializerSyntax" Kind="Class" />
      <Type Name="OmittedArgumentSyntax" Kind="Class" />
      <Type Name="OnErrorGoToStatementSyntax" Kind="Class" />
      <Type Name="OnErrorResumeNextStatementSyntax" Kind="Class" />
      <Type Name="OperatorBlockSyntax" Kind="Class" />
      <Type Name="OperatorStatementSyntax" Kind="Class" />
      <Type Name="OptionStatementSyntax" Kind="Class" />
      <Type Name="OrderByClauseSyntax" Kind="Class" />
      <Type Name="OrderingSyntax" Kind="Class" />
      <Type Name="ParameterListSyntax" Kind="Class" />
      <Type Name="ParameterSyntax" Kind="Class" />
      <Type Name="ParenthesizedExpressionSyntax" Kind="Class" />
      <Type Name="PartitionClauseSyntax" Kind="Class" />
      <Type Name="PartitionWhileClauseSyntax" Kind="Class" />
      <Type Name="PredefinedCastExpressionSyntax" Kind="Class" />
      <Type Name="PredefinedTypeSyntax" Kind="Class" />
      <Type Name="PrintStatementSyntax" Kind="Class" />
      <Type Name="PropertyBlockSyntax" Kind="Class" />
      <Type Name="PropertyStatementSyntax" Kind="Class" />
      <Type Name="QualifiedCrefOperatorReferenceSyntax" Kind="Class" />
      <Type Name="QualifiedNameSyntax" Kind="Class" />
      <Type Name="QueryClauseSyntax" Kind="Class" />
      <Type Name="QueryExpressionSyntax" Kind="Class" />
      <Type Name="RaiseEventStatementSyntax" Kind="Class" />
      <Type Name="RangeArgumentSyntax" Kind="Class" />
      <Type Name="RangeCaseClauseSyntax" Kind="Class" />
      <Type Name="RedimClauseSyntax" Kind="Class" />
      <Type Name="ReDimStatementSyntax" Kind="Class" />
      <Type Name="ReferenceDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="RegionDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="RelationalCaseClauseSyntax" Kind="Class" />
      <Type Name="ResumeStatementSyntax" Kind="Class" />
      <Type Name="ReturnStatementSyntax" Kind="Class" />
      <Type Name="SelectBlockSyntax" Kind="Class" />
      <Type Name="SelectClauseSyntax" Kind="Class" />
      <Type Name="SelectStatementSyntax" Kind="Class" />
      <Type Name="SimpleArgumentSyntax" Kind="Class" />
      <Type Name="SimpleAsClauseSyntax" Kind="Class" />
      <Type Name="SimpleCaseClauseSyntax" Kind="Class" />
      <Type Name="SimpleImportsClauseSyntax" Kind="Class" />
      <Type Name="SimpleJoinClauseSyntax" Kind="Class" />
      <Type Name="SimpleNameSyntax" Kind="Class" />
      <Type Name="SingleLineElseClauseSyntax" Kind="Class" />
      <Type Name="SingleLineIfStatementSyntax" Kind="Class" />
      <Type Name="SingleLineLambdaExpressionSyntax" Kind="Class" />
      <Type Name="SkippedTokensTriviaSyntax" Kind="Class" />
      <Type Name="SpecialConstraintSyntax" Kind="Class" />
      <Type Name="StatementSyntax" Kind="Class" />
      <Type Name="StopOrEndStatementSyntax" Kind="Class" />
      <Type Name="StructureBlockSyntax" Kind="Class" />
      <Type Name="StructuredTriviaSyntax" Kind="Class" />
      <Type Name="StructureStatementSyntax" Kind="Class" />
      <Type Name="SubNewStatementSyntax" Kind="Class" />
      <Type Name="SyncLockBlockSyntax" Kind="Class" />
      <Type Name="SyncLockStatementSyntax" Kind="Class" />
      <Type Name="SyntaxNodeRemover" Kind="Class" />
      <Type Name="TernaryConditionalExpressionSyntax" Kind="Class" />
      <Type Name="ThrowStatementSyntax" Kind="Class" />
      <Type Name="TryBlockSyntax" Kind="Class" />
      <Type Name="TryCastExpressionSyntax" Kind="Class" />
      <Type Name="TryStatementSyntax" Kind="Class" />
      <Type Name="TupleElementSyntax" Kind="Class" />
      <Type Name="TupleExpressionSyntax" Kind="Class" />
      <Type Name="TupleTypeSyntax" Kind="Class" />
      <Type Name="TypeArgumentListSyntax" Kind="Class" />
      <Type Name="TypeBlockSyntax" Kind="Class" />
      <Type Name="TypeCharacter" Kind="Enumeration" />
      <Type Name="TypeConstraintSyntax" Kind="Class" />
      <Type Name="TypedTupleElementSyntax" Kind="Class" />
      <Type Name="TypeOfExpressionSyntax" Kind="Class" />
      <Type Name="TypeParameterConstraintClauseSyntax" Kind="Class" />
      <Type Name="TypeParameterListSyntax" Kind="Class" />
      <Type Name="TypeParameterMultipleConstraintClauseSyntax" Kind="Class" />
      <Type Name="TypeParameterSingleConstraintClauseSyntax" Kind="Class" />
      <Type Name="TypeParameterSyntax" Kind="Class" />
      <Type Name="TypeStatementSyntax" Kind="Class" />
      <Type Name="TypeSyntax" Kind="Class" />
      <Type Name="UnaryExpressionSyntax" Kind="Class" />
      <Type Name="UsingBlockSyntax" Kind="Class" />
      <Type Name="UsingStatementSyntax" Kind="Class" />
      <Type Name="VariableDeclaratorSyntax" Kind="Class" />
      <Type Name="VariableNameEqualsSyntax" Kind="Class" />
      <Type Name="WhereClauseSyntax" Kind="Class" />
      <Type Name="WhileBlockSyntax" Kind="Class" />
      <Type Name="WhileOrUntilClauseSyntax" Kind="Class" />
      <Type Name="WhileStatementSyntax" Kind="Class" />
      <Type Name="WithBlockSyntax" Kind="Class" />
      <Type Name="WithEventsEventContainerSyntax" Kind="Class" />
      <Type Name="WithEventsPropertyEventContainerSyntax" Kind="Class" />
      <Type Name="WithStatementSyntax" Kind="Class" />
      <Type Name="XmlAttributeSyntax" Kind="Class" />
      <Type Name="XmlBracketedNameSyntax" Kind="Class" />
      <Type Name="XmlCDataSectionSyntax" Kind="Class" />
      <Type Name="XmlCommentSyntax" Kind="Class" />
      <Type Name="XmlCrefAttributeSyntax" Kind="Class" />
      <Type Name="XmlDeclarationOptionSyntax" Kind="Class" />
      <Type Name="XmlDeclarationSyntax" Kind="Class" />
      <Type Name="XmlDocumentSyntax" Kind="Class" />
      <Type Name="XmlElementEndTagSyntax" Kind="Class" />
      <Type Name="XmlElementStartTagSyntax" Kind="Class" />
      <Type Name="XmlElementSyntax" Kind="Class" />
      <Type Name="XmlEmbeddedExpressionSyntax" Kind="Class" />
      <Type Name="XmlEmptyElementSyntax" Kind="Class" />
      <Type Name="XmlMemberAccessExpressionSyntax" Kind="Class" />
      <Type Name="XmlNameAttributeSyntax" Kind="Class" />
      <Type Name="XmlNamespaceImportsClauseSyntax" Kind="Class" />
      <Type Name="XmlNameSyntax" Kind="Class" />
      <Type Name="XmlNodeSyntax" Kind="Class" />
      <Type Name="XmlPrefixNameSyntax" Kind="Class" />
      <Type Name="XmlPrefixSyntax" Kind="Class" />
      <Type Name="XmlProcessingInstructionSyntax" Kind="Class" />
      <Type Name="XmlStringSyntax" Kind="Class" />
      <Type Name="XmlTextSyntax" Kind="Class" />
      <Type Name="YieldStatementSyntax" Kind="Class" />
    </Namespace>
  </Types>
  <Title>Untitled</Title>
  <ExtensionMethods>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeControlFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="statement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="statement">To be added.</param>
          <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeControlFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
          <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="firstStatement">To be added.</param>
          <param name="lastStatement">To be added.</param>
          <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeDataFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <summary>
            Analyze data-flow within an expression. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeDataFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="statement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="statement">To be added.</param>
          <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeDataFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
          <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="firstStatement">To be added.</param>
          <param name="lastStatement">To be added.</param>
          <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="ClassifyConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.Compilation compilation, class Microsoft.CodeAnalysis.ITypeSymbol source, class Microsoft.CodeAnalysis.ITypeSymbol destination) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
          <Parameter Name="source" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
          <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        </Parameters>
        <Docs>
          <param name="compilation">To be added.</param>
          <param name="source">To be added.</param>
          <param name="destination">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="ClassifyConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, class Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
          <Parameter Name="isExplicitInSource" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="destination">To be added.</param>
          <param name="isExplicitInSource">To be added.</param>
          <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="ClassifyConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, class Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
          <Parameter Name="isExplicitInSource" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="destination">To be added.</param>
          <param name="isExplicitInSource">To be added.</param>
          <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetAliasInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="nameSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            If <paramref name="nameSyntax" /> resolves to an alias name, return the AliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetAwaitExpressionInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo GetAwaitExpressionInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax awaitExpression);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo GetAwaitExpressionInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax awaitExpression) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="awaitExpression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="awaitExpression">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetCollectionInitializerSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetCollectionInitializerSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetCollectionInitializerSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax 
            within <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.Initializer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTree" />
      </Targets>
      <Member MemberName="GetCompilationUnitRoot">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax GetCompilationUnitRoot (this Microsoft.CodeAnalysis.SyntaxTree tree, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax GetCompilationUnitRoot(class Microsoft.CodeAnalysis.SyntaxTree tree, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="tree" Type="Microsoft.CodeAnalysis.SyntaxTree" RefType="this" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="tree">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetConstantValue">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.Optional&lt;object&gt; GetConstantValue (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.Optional`1&lt;object&gt; GetConstantValue(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.Optional&lt;System.Object&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion GetConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion GetConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node that declares a property or member accessor, get the corresponding symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declaratorSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declaratorSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declaratorSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node of a tuple argument, get the tuple element symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a base method declaration syntax, get the corresponding method symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a type declaration, get the corresponding type symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax catchDeclaration, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax catchDeclaration, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ILocalSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="catchDeclaration" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="catchDeclaration">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a catch declaration, get the symbol for the exception variable
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a delegate declaration, get the corresponding type symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IFieldSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IFieldSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IFieldSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a enum member declaration, get the corresponding field symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IEventSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node that declares a (custom) event, get the corresponding event symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given an extern alias declaration get the corresponding symbol for the alias that was introduced.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ILocalSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="forEachStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="forEachStatement">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a foreach statement, get the symbol for the iteration variable
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node that declares an indexer, get the corresponding declared symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Get the query range variable declared in a join into clause.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ILabelSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a labeled statement syntax, get the corresponding label symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a member declaration syntax, get the corresponding symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for
            the declaration assembly.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IParameterSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IParameterSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IParameterSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a parameter declaration syntax node, get the corresponding symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node that declares a property, get the corresponding declared symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax queryClause, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax queryClause, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="queryClause" Type="Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="queryClause">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Get the query range variable declared in a query continuation clause.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax designationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax designationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="designationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="designationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ILabelSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a switch label syntax, get the corresponding label symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a tuple element syntax, get the corresponding symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declaratorSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node of tuple expression, get the tuple type symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ITypeParameterSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax typeParameter, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ITypeParameterSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax typeParameter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ITypeParameterSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="typeParameter" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="typeParameter">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a type parameter declaration (field or method), get the corresponding symbol
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a using declaration get the corresponding symbol for the using alias that was introduced.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="GetFirstDirective">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetFirstDirective (this Microsoft.CodeAnalysis.SyntaxNode node, Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,bool&gt; predicate = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetFirstDirective(class Microsoft.CodeAnalysis.SyntaxNode node, class System.Func`2&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool&gt; predicate) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="predicate" Type="System.Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean&gt;" />
        </Parameters>
        <Docs>
          <param name="node">To be added.</param>
          <param name="predicate">To be added.</param>
          <summary>
            Gets the first directive of the tree rooted by this node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetForEachStatementInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEachStatement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEachStatement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="forEachStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="forEachStatement">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetForEachStatementInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="forEachStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="forEachStatement">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetIndexerGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IPropertySymbol&gt; GetIndexerGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.IPropertySymbol&gt; GetIndexerGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IPropertySymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="GetLastDirective">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetLastDirective (this Microsoft.CodeAnalysis.SyntaxNode node, Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,bool&gt; predicate = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetLastDirective(class Microsoft.CodeAnalysis.SyntaxNode node, class System.Func`2&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool&gt; predicate) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="predicate" Type="System.Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean&gt;" />
        </Parameters>
        <Docs>
          <param name="node">To be added.</param>
          <param name="predicate">To be added.</param>
          <summary>
            Gets the last directive of the tree rooted by this node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetMemberGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="attribute">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetMemberGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="initializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="initializer">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetMemberGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetQueryClauseInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.QueryClauseInfo GetQueryClauseInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.QueryClauseInfo GetQueryClauseInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.QueryClauseInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets the semantic information associated with a query clause.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeAliasInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="nameSyntax">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion GetSpeculativeConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion GetSpeculativeConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="attribute">To be added.</param>
          <summary>
            Bind the attribute in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about an attribute
            that did not actually appear in the source code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="constructorInitializer">To be added.</param>
          <summary>
            Bind the constructor initializer in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about a constructor
            initializer that did not actually appear in the source code.
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
            Binds the CrefSyntax expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
            Binds the expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
            Binds the expression in the context of the specified location and gets type information.
            This method is used to get type information about an expression that did not actually
            appear in the source code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="attributeSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="attributeSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Returns what symbol(s), if any, the given attribute syntax bound to in the program.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="constructorInitializer">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="crefSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="crefSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets the semantic information associated with a documentation comment cref.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Returns what symbol(s), if any, the given expression syntax bound to in the program.
            
            An AliasSymbol will never be returned by this method. What the alias refers to will be
            returned instead. To get information about aliases, call GetAliasInfo.
            
            If binding the type name C in the expression "new C(...)" the actual constructor bound to
            will be returned (or all constructor if overload resolution failed). This occurs as long as C
            unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple
            types, or C binds to a static class, then type(s) are returned.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets the semantic information for an ordering clause in an orderby query clause.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets the semantic information associated with a select or group clause.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="attributeSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="attributeSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets type information about an attribute.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="constructorInitializer">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets type information about a constructor initializer.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets type information about an expression.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTokenList" />
      </Targets>
      <Member MemberName="Insert">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTokenList Insert (this Microsoft.CodeAnalysis.SyntaxTokenList list, int index, Microsoft.CodeAnalysis.SyntaxToken[] items);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxTokenList Insert(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, int32 index, valuetype Microsoft.CodeAnalysis.SyntaxToken[] items) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTokenList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
          <Parameter Name="index" Type="System.Int32" />
          <Parameter Name="items" Type="Microsoft.CodeAnalysis.SyntaxToken[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="list">To be added.</param>
          <param name="index">To be added.</param>
          <param name="items">To be added.</param>
          <summary>
            Insert one or more tokens in the list at the specified index.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsContextualKeyword">
        <MemberSignature Language="C#" Value="public static bool IsContextualKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsContextualKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsKeyword">
        <MemberSignature Language="C#" Value="public static bool IsKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsReservedKeyword">
        <MemberSignature Language="C#" Value="public static bool IsReservedKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsReservedKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsVerbatimIdentifier">
        <MemberSignature Language="C#" Value="public static bool IsVerbatimIdentifier (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsVerbatimIdentifier(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsVerbatimStringLiteral">
        <MemberSignature Language="C#" Value="public static bool IsVerbatimStringLiteral (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsVerbatimStringLiteral(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxNode node);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(class Microsoft.CodeAnalysis.SyntaxNode node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
        </Parameters>
        <Docs>
          <param name="node">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="nodeOrToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTrivia" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxTrivia trivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxTrivia trivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" RefType="this" />
        </Parameters>
        <Docs>
          <param name="trivia">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="ReplaceTrivia">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia (this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, Microsoft.CodeAnalysis.SyntaxTrivia newTrivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(valuetype Microsoft.CodeAnalysis.SyntaxToken token, valuetype Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia newTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="oldTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
          <Parameter Name="newTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
        </Parameters>
        <Docs>
          <param name="token" />
          <param name="oldTrivia">The trivia to be replaced.</param>
          <param name="newTrivia">The new trivia to use in the new tree in place of the old
            trivia.</param>
          <summary>
            Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in
            the token's leading or trailing trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="ReplaceTrivia">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia (this Microsoft.CodeAnalysis.SyntaxToken token, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(valuetype Microsoft.CodeAnalysis.SyntaxToken token, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, class System.Func`3&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="trivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
          <Parameter Name="computeReplacementTrivia" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        </Parameters>
        <Docs>
          <param name="token" />
          <param name="trivia">The trivia to be replaced; descendants of the root token.</param>
          <param name="computeReplacementTrivia">A function that computes a replacement trivia for
            the argument trivia. The first argument is the original trivia. The second argument is
            the same trivia rewritten with replaced structure.</param>
          <summary>
            Creates a new token with the specified old trivia replaced with computed new trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, class Microsoft.CodeAnalysis.SemanticModel speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expressionBody" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expressionBody">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with an expression body that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an expression body that did not appear in source code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, class Microsoft.CodeAnalysis.SemanticModel speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="attribute">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with an attribute that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an attribute that did not appear in source code. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, class Microsoft.CodeAnalysis.SemanticModel speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="constructorInitializer">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with a constructor initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a constructor initializer that did not appear in source code. 
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, class Microsoft.CodeAnalysis.SemanticModel speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="crefSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="crefSyntax">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with a cref syntax node that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a cref syntax that did not appear in source code. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer, class Microsoft.CodeAnalysis.SemanticModel speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="initializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="initializer">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with an initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a field initializer or default parameter value that did not appear in source code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, class Microsoft.CodeAnalysis.SemanticModel speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="statement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="statement">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with a statement that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a statement that did not appear in source code. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, out Microsoft.CodeAnalysis.SemanticModel speculativeModel, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption = Microsoft.CodeAnalysis.SpeculativeBindingOption.BindAsExpression);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, class Microsoft.CodeAnalysis.SemanticModel speculativeModel, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="type" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="type">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with a type syntax node that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a type syntax that did not appear in source code. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModelForMethodBody">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModelForMethodBody (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax accessor, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModelForMethodBody(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax accessor, class Microsoft.CodeAnalysis.SemanticModel speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="accessor" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="accessor">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position" /> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModelForMethodBody">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModelForMethodBody (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax method, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModelForMethodBody(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax method, class Microsoft.CodeAnalysis.SemanticModel speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="method" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="method">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position" /> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="VarianceKindFromToken">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VarianceKind VarianceKindFromToken (this Microsoft.CodeAnalysis.SyntaxToken node);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.VarianceKind VarianceKindFromToken(valuetype Microsoft.CodeAnalysis.SyntaxToken node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VarianceKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="node">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation" />
      </Targets>
      <Member MemberName="Emit">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.Emit.EmitResult Emit (this Microsoft.CodeAnalysis.CSharp.CSharpCompilation compilation, string outputPath, string pdbPath = null, string xmlDocumentationPath = null, string win32ResourcesPath = null, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ResourceDescription&gt; manifestResources = null, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.Emit.EmitResult Emit(class Microsoft.CodeAnalysis.CSharp.CSharpCompilation compilation, string outputPath, string pdbPath, string xmlDocumentationPath, string win32ResourcesPath, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.ResourceDescription&gt; manifestResources, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpFileSystemExtensions.Emit(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.Emit.EmitResult</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.CSharp.CSharpCompilation" RefType="this" />
          <Parameter Name="outputPath" Type="System.String" />
          <Parameter Name="pdbPath" Type="System.String" />
          <Parameter Name="xmlDocumentationPath" Type="System.String" />
          <Parameter Name="win32ResourcesPath" Type="System.String" />
          <Parameter Name="manifestResources" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ResourceDescription&gt;" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="compilation">Compilation.</param>
          <param name="outputPath">Path of the file to which the PE image will be written.</param>
          <param name="pdbPath">Path of the file to which the compilation's debug info will be written.
            Also embedded in the output file.  Null to forego PDB generation.
            </param>
          <param name="xmlDocumentationPath">Path of the file to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
          <param name="win32ResourcesPath">Path of the file from which the compilation's Win32 resources will be read (in RES format).  
            Null to indicate that there are none.</param>
          <param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
          <param name="cancellationToken">To cancel the emit process.</param>
          <summary>
            Emit the IL for the compilation into the specified stream.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpFileSystemExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpFileSystemExtensions.Emit(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.CSharp.LanguageVersion" />
      </Targets>
      <Member MemberName="MapSpecifiedToEffectiveVersion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.LanguageVersion MapSpecifiedToEffectiveVersion (this Microsoft.CodeAnalysis.CSharp.LanguageVersion version);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.LanguageVersion MapSpecifiedToEffectiveVersion(valuetype Microsoft.CodeAnalysis.CSharp.LanguageVersion version) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.MapSpecifiedToEffectiveVersion(Microsoft.CodeAnalysis.CSharp.LanguageVersion)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.LanguageVersion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="version" Type="Microsoft.CodeAnalysis.CSharp.LanguageVersion" RefType="this" />
        </Parameters>
        <Docs>
          <param name="version">To be added.</param>
          <summary>
            Map a language version (such as Default, Latest, or CSharpN) to a specific version (CSharpM).
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts" Member="M:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.MapSpecifiedToEffectiveVersion(Microsoft.CodeAnalysis.CSharp.LanguageVersion)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.CSharp.LanguageVersion" />
      </Targets>
      <Member MemberName="ToDisplayString">
        <MemberSignature Language="C#" Value="public static string ToDisplayString (this Microsoft.CodeAnalysis.CSharp.LanguageVersion version);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToDisplayString(valuetype Microsoft.CodeAnalysis.CSharp.LanguageVersion version) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.ToDisplayString(Microsoft.CodeAnalysis.CSharp.LanguageVersion)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="version" Type="Microsoft.CodeAnalysis.CSharp.LanguageVersion" RefType="this" />
        </Parameters>
        <Docs>
          <param name="version">To be added.</param>
          <summary>
            Displays the version number in the format expected on the command-line (/langver flag).
            For instance, "6", "7", "7.1", "latest".
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts" Member="M:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.ToDisplayString(Microsoft.CodeAnalysis.CSharp.LanguageVersion)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.String" />
      </Targets>
      <Member MemberName="TryParse">
        <MemberSignature Language="C#" Value="public static bool TryParse (this string version, out Microsoft.CodeAnalysis.CSharp.LanguageVersion result);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string version, valuetype Microsoft.CodeAnalysis.CSharp.LanguageVersion result) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.TryParse(System.String,Microsoft.CodeAnalysis.CSharp.LanguageVersion@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="version" Type="System.String" RefType="this" />
          <Parameter Name="result" Type="Microsoft.CodeAnalysis.CSharp.LanguageVersion&amp;" RefType="out" />
        </Parameters>
        <Docs>
          <param name="version">To be added.</param>
          <param name="result">To be added.</param>
          <summary>
            Try parse a <see cref="T:Microsoft.CodeAnalysis.CSharp.LanguageVersion" /> from a string input, returning default if input was null.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts" Member="M:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.TryParse(System.String,Microsoft.CodeAnalysis.CSharp.LanguageVersion@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="NormalizeWhitespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace (this Microsoft.CodeAnalysis.SyntaxToken token, string indentation, bool elasticTrivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace(valuetype Microsoft.CodeAnalysis.SyntaxToken token, string indentation, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.Boolean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="token">The token to normalize.</param>
          <param name="indentation">A sequence of whitespace characters that defines a single level of indentation.</param>
          <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
          <summary>
            Creates a new syntax token with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="NormalizeWhitespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace (this Microsoft.CodeAnalysis.SyntaxToken token, string indentation = &quot;    &quot;, string eol = &quot;&#xD;&#xA;&quot;, bool elasticTrivia = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace(valuetype Microsoft.CodeAnalysis.SyntaxToken token, string indentation, string eol, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.String,System.Boolean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="eol" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="token">The token to normalize.</param>
          <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
          <param name="eol">An optional sequence of whitespace characters used for end of line.</param>
          <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
          <summary>
            Creates a new syntax token with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />
      </Targets>
      <Member MemberName="NormalizeWhitespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace (this Microsoft.CodeAnalysis.SyntaxTriviaList list, string indentation, bool elasticTrivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace(valuetype Microsoft.CodeAnalysis.SyntaxTriviaList list, string indentation, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Boolean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTriviaList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="list">The trivia list to normalize.</param>
          <param name="indentation">A sequence of whitespace characters that defines a single level of indentation.</param>
          <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
          <summary>
            Creates a new syntax trivia list with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />
      </Targets>
      <Member MemberName="NormalizeWhitespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace (this Microsoft.CodeAnalysis.SyntaxTriviaList list, string indentation = &quot;    &quot;, string eol = &quot;&#xD;&#xA;&quot;, bool elasticTrivia = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace(valuetype Microsoft.CodeAnalysis.SyntaxTriviaList list, string indentation, string eol, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,System.Boolean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTriviaList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="eol" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="list">The trivia list to normalize.</param>
          <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
          <param name="eol">An optional sequence of whitespace characters used for end of line.</param>
          <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
          <summary>
            Creates a new syntax trivia list with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ToSyntaxTriviaList">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTriviaList ToSyntaxTriviaList (this System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; sequence);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxTriviaList ToSyntaxTriviaList(class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; sequence) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.ToSyntaxTriviaList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTriviaList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="sequence" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="sequence">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.ToSyntaxTriviaList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax" />
      </Targets>
      <Member MemberName="Update">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax Update (this Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax syntax, Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken thisKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax Update(class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax syntax, valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; attributeLists, valuetype Microsoft.CodeAnalysis.SyntaxTokenList modifiers, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, class Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, valuetype Microsoft.CodeAnalysis.SyntaxToken thisKeyword, class Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList, class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="syntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax" RefType="this" />
          <Parameter Name="attributeLists" Type="Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt;" />
          <Parameter Name="modifiers" Type="Microsoft.CodeAnalysis.SyntaxTokenList" />
          <Parameter Name="type" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" />
          <Parameter Name="explicitInterfaceSpecifier" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax" />
          <Parameter Name="thisKeyword" Type="Microsoft.CodeAnalysis.SyntaxToken" />
          <Parameter Name="parameterList" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax" />
          <Parameter Name="accessorList" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax" />
        </Parameters>
        <Docs>
          <param name="syntax">To be added.</param>
          <param name="attributeLists">To be added.</param>
          <param name="modifiers">To be added.</param>
          <param name="type">To be added.</param>
          <param name="explicitInterfaceSpecifier">To be added.</param>
          <param name="thisKeyword">To be added.</param>
          <param name="parameterList">To be added.</param>
          <param name="accessorList">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax" />
      </Targets>
      <Member MemberName="Update">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax Update (this Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax syntax, Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax&gt; constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxToken semicolonToken);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax Update(class Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax syntax, valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; attributeLists, valuetype Microsoft.CodeAnalysis.SyntaxTokenList modifiers, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, class Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, valuetype Microsoft.CodeAnalysis.SyntaxToken identifier, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax&gt; constraintClauses, class Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, valuetype Microsoft.CodeAnalysis.SyntaxToken semicolonToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="syntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax" RefType="this" />
          <Parameter Name="attributeLists" Type="Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt;" />
          <Parameter Name="modifiers" Type="Microsoft.CodeAnalysis.SyntaxTokenList" />
          <Parameter Name="returnType" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" />
          <Parameter Name="explicitInterfaceSpecifier" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax" />
          <Parameter Name="identifier" Type="Microsoft.CodeAnalysis.SyntaxToken" />
          <Parameter Name="typeParameterList" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax" />
          <Parameter Name="parameterList" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax" />
          <Parameter Name="constraintClauses" Type="Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax&gt;" />
          <Parameter Name="block" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax" />
          <Parameter Name="semicolonToken" Type="Microsoft.CodeAnalysis.SyntaxToken" />
        </Parameters>
        <Docs>
          <param name="syntax">To be added.</param>
          <param name="attributeLists">To be added.</param>
          <param name="modifiers">To be added.</param>
          <param name="returnType">To be added.</param>
          <param name="explicitInterfaceSpecifier">To be added.</param>
          <param name="identifier">To be added.</param>
          <param name="typeParameterList">To be added.</param>
          <param name="parameterList">To be added.</param>
          <param name="constraintClauses">To be added.</param>
          <param name="block">To be added.</param>
          <param name="semicolonToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax" />
      </Targets>
      <Member MemberName="Update">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax Update (this Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax syntax, Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxToken semicolonToken);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax Update(class Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax syntax, valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; attributeLists, valuetype Microsoft.CodeAnalysis.SyntaxTokenList modifiers, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, valuetype Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, valuetype Microsoft.CodeAnalysis.SyntaxToken operatorToken, class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, class Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, valuetype Microsoft.CodeAnalysis.SyntaxToken semicolonToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="syntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax" RefType="this" />
          <Parameter Name="attributeLists" Type="Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt;" />
          <Parameter Name="modifiers" Type="Microsoft.CodeAnalysis.SyntaxTokenList" />
          <Parameter Name="returnType" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" />
          <Parameter Name="operatorKeyword" Type="Microsoft.CodeAnalysis.SyntaxToken" />
          <Parameter Name="operatorToken" Type="Microsoft.CodeAnalysis.SyntaxToken" />
          <Parameter Name="parameterList" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax" />
          <Parameter Name="block" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax" />
          <Parameter Name="semicolonToken" Type="Microsoft.CodeAnalysis.SyntaxToken" />
        </Parameters>
        <Docs>
          <param name="syntax">To be added.</param>
          <param name="attributeLists">To be added.</param>
          <param name="modifiers">To be added.</param>
          <param name="returnType">To be added.</param>
          <param name="operatorKeyword">To be added.</param>
          <param name="operatorToken">To be added.</param>
          <param name="parameterList">To be added.</param>
          <param name="block">To be added.</param>
          <param name="semicolonToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax" />
      </Targets>
      <Member MemberName="WithIdentifier">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax WithIdentifier (this Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax simpleName, Microsoft.CodeAnalysis.SyntaxToken identifier);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax WithIdentifier(class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax simpleName, valuetype Microsoft.CodeAnalysis.SyntaxToken identifier) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.WithIdentifier(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="simpleName" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax" RefType="this" />
          <Parameter Name="identifier" Type="Microsoft.CodeAnalysis.SyntaxToken" />
        </Parameters>
        <Docs>
          <param name="simpleName" />
          <param name="identifier" />
          <summary>
            Updates the given SimpleNameSyntax node with the given identifier token.
            This function is a wrapper that calls WithIdentifier on derived syntax nodes.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.WithIdentifier(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="TryGetInferredMemberName">
        <MemberSignature Language="C#" Value="public static string TryGetInferredMemberName (this Microsoft.CodeAnalysis.SyntaxNode syntax);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TryGetInferredMemberName(class Microsoft.CodeAnalysis.SyntaxNode syntax) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.TryGetInferredMemberName(Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="syntax" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
        </Parameters>
        <Docs>
          <param name="syntax">To be added.</param>
          <summary>
            Given an initializer expression infer the name of anonymous property or tuple element.
            Returns null if unsuccessful
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxFacts" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.TryGetInferredMemberName(Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.TypedConstant" />
      </Targets>
      <Member MemberName="ToCSharpString">
        <MemberSignature Language="C#" Value="public static string ToCSharpString (this Microsoft.CodeAnalysis.TypedConstant constant);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToCSharpString(valuetype Microsoft.CodeAnalysis.TypedConstant constant) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.TypedConstantExtensions.ToCSharpString(Microsoft.CodeAnalysis.TypedConstant)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="constant" Type="Microsoft.CodeAnalysis.TypedConstant" RefType="this" />
        </Parameters>
        <Docs>
          <param name="constant">To be added.</param>
          <summary>
            Returns the System.String that represents the current TypedConstant.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.TypedConstantExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.TypedConstantExtensions.ToCSharpString(Microsoft.CodeAnalysis.TypedConstant)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTokenList" />
      </Targets>
      <Member MemberName="Any">
        <MemberSignature Language="C#" Value="public static bool Any (this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.Any(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list" />
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind" /> to test for.</param>
          <summary>
            Tests whether a list contains a token of a particular kind.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.Any(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />
      </Targets>
      <Member MemberName="Any">
        <MemberSignature Language="C#" Value="public static bool Any (this Microsoft.CodeAnalysis.SyntaxTriviaList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any(valuetype Microsoft.CodeAnalysis.SyntaxTriviaList list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.Any(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>
            True if the list has at least one trivia of the specified kind.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.Any(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />
      </Targets>
      <Member MemberName="Any&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static bool Any&lt;TNode&gt; (this Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SeparatedSyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.Any``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>
            True if the list has at least one node of the specified kind.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.Any``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxList`1" />
      </Targets>
      <Member MemberName="Any&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static bool Any&lt;TNode&gt; (this Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.Any``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>
            True if the list has at least one node of the specified kind.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.Any``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTokenList" />
      </Targets>
      <Member MemberName="IndexOf">
        <MemberSignature Language="C#" Value="public static int IndexOf (this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list">Token list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind" /> to find.</param>
          <summary>
            Returns the index of the first token of a specified kind in the token list.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />
      </Targets>
      <Member MemberName="IndexOf">
        <MemberSignature Language="C#" Value="public static int IndexOf (this Microsoft.CodeAnalysis.SyntaxTriviaList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(valuetype Microsoft.CodeAnalysis.SyntaxTriviaList list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list">Trivia list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind" /> to find.</param>
          <summary>
            Returns the index of the first trivia of a specified kind in the trivia list.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />
      </Targets>
      <Member MemberName="IndexOf&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static int IndexOf&lt;TNode&gt; (this Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SeparatedSyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">Node list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind" /> to find.</param>
          <summary>
            Returns the index of the first node of a specified kind in the node list.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxList`1" />
      </Targets>
      <Member MemberName="IndexOf&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static int IndexOf&lt;TNode&gt; (this Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">Node list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind" /> to find.</param>
          <summary>
            Returns the index of the first node of a specified kind in the node list.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKind(class Microsoft.CodeAnalysis.SyntaxNode node, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="node">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKind(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="nodeOrToken">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKind(valuetype Microsoft.CodeAnalysis.SyntaxToken token, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTrivia" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxTrivia trivia, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKind(valuetype Microsoft.CodeAnalysis.SyntaxTrivia trivia, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="trivia">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
      </Targets>
      <Member MemberName="GetText">
        <MemberSignature Language="C#" Value="public static string GetText (this Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static string GetText(valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.GeneratedExtensionSyntaxFacts.GetText(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" RefType="this" />
        </Parameters>
        <Docs>
          <param name="kind">To be added.</param>
          <summary>
 Return keyword or punctuation text based on SyntaxKind
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.GeneratedExtensionSyntaxFacts" Member="M:Microsoft.CodeAnalysis.VisualBasic.GeneratedExtensionSyntaxFacts.GetText(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.VisualBasic.LanguageVersion" />
      </Targets>
      <Member MemberName="MapSpecifiedToEffectiveVersion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.LanguageVersion MapSpecifiedToEffectiveVersion (this Microsoft.CodeAnalysis.VisualBasic.LanguageVersion version);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.LanguageVersion MapSpecifiedToEffectiveVersion(valuetype Microsoft.CodeAnalysis.VisualBasic.LanguageVersion version) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts.MapSpecifiedToEffectiveVersion(Microsoft.CodeAnalysis.VisualBasic.LanguageVersion)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.LanguageVersion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="version" Type="Microsoft.CodeAnalysis.VisualBasic.LanguageVersion" RefType="this" />
        </Parameters>
        <Docs>
          <param name="version">To be added.</param>
          <summary>
 Map a language version (such as Default, Latest, Or VisualBasicN) to a specific version (VisualBasicN).
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts" Member="M:Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts.MapSpecifiedToEffectiveVersion(Microsoft.CodeAnalysis.VisualBasic.LanguageVersion)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.VisualBasic.LanguageVersion" />
      </Targets>
      <Member MemberName="ToDisplayString">
        <MemberSignature Language="C#" Value="public static string ToDisplayString (this Microsoft.CodeAnalysis.VisualBasic.LanguageVersion version);" />
        <MemberSignature Language="ILAsm" Value=".method public static string ToDisplayString(valuetype Microsoft.CodeAnalysis.VisualBasic.LanguageVersion version) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts.ToDisplayString(Microsoft.CodeAnalysis.VisualBasic.LanguageVersion)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="version" Type="Microsoft.CodeAnalysis.VisualBasic.LanguageVersion" RefType="this" />
        </Parameters>
        <Docs>
          <param name="version">To be added.</param>
          <summary>
 Displays the version number in the format understood on the command-line (/langver flag).
 For instance, "9", "15", "latest".
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts" Member="M:Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts.ToDisplayString(Microsoft.CodeAnalysis.VisualBasic.LanguageVersion)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.String" />
      </Targets>
      <Member MemberName="TryParse">
        <MemberSignature Language="C#" Value="public static bool TryParse (this string version, ref Microsoft.CodeAnalysis.VisualBasic.LanguageVersion result);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool TryParse(string version, valuetype Microsoft.CodeAnalysis.VisualBasic.LanguageVersion result) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts.TryParse(System.String,Microsoft.CodeAnalysis.VisualBasic.LanguageVersion@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="version" Type="System.String" RefType="this" />
          <Parameter Name="result" Type="Microsoft.CodeAnalysis.VisualBasic.LanguageVersion&amp;" RefType="ref" />
        </Parameters>
        <Docs>
          <param name="version">To be added.</param>
          <param name="result">To be added.</param>
          <summary>
 Parse a LanguageVersion from a string input, as the command-line compiler does.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts" Member="M:Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts.TryParse(System.String,Microsoft.CodeAnalysis.VisualBasic.LanguageVersion@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax" />
      </Targets>
      <Member MemberName="Attributes">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax&gt; Attributes (this Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseSyntax);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax&gt; Attributes(class Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseSyntax) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Attributes(Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="asClauseSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax" RefType="this" />
        </Parameters>
        <Docs>
          <param name="asClauseSyntax">To be added.</param>
          <summary>
 Returns the AttributeBlockSyntax of the given AsClauseSyntax if specified.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Attributes(Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="NormalizeWhitespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace (this Microsoft.CodeAnalysis.SyntaxToken token, string indentation, bool elasticTrivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace(valuetype Microsoft.CodeAnalysis.SyntaxToken token, string indentation, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.Boolean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <param name="indentation">To be added.</param>
          <param name="elasticTrivia">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="NormalizeWhitespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace (this Microsoft.CodeAnalysis.SyntaxToken token, string indentation = &quot;    &quot;, string eol = &quot;&#xD;&#xA;&quot;, bool elasticTrivia = false, bool useDefaultCasing = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace(valuetype Microsoft.CodeAnalysis.SyntaxToken token, string indentation, string eol, bool elasticTrivia, bool useDefaultCasing) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.String,System.Boolean,System.Boolean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="eol" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
          <Parameter Name="useDefaultCasing" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <param name="indentation">To be added.</param>
          <param name="eol">To be added.</param>
          <param name="elasticTrivia">To be added.</param>
          <param name="useDefaultCasing">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.String,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />
      </Targets>
      <Member MemberName="NormalizeWhitespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace (this Microsoft.CodeAnalysis.SyntaxTriviaList trivia, string indentation = &quot;    &quot;, string eol = &quot;&#xD;&#xA;&quot;, bool elasticTrivia = false, bool useDefaultCasing = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace(valuetype Microsoft.CodeAnalysis.SyntaxTriviaList trivia, string indentation, string eol, bool elasticTrivia, bool useDefaultCasing) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,System.Boolean,System.Boolean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTriviaList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="eol" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
          <Parameter Name="useDefaultCasing" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="trivia">To be added.</param>
          <param name="indentation">To be added.</param>
          <param name="eol">To be added.</param>
          <param name="elasticTrivia">To be added.</param>
          <param name="useDefaultCasing">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="NormalizeWhitespace&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static TNode NormalizeWhitespace&lt;TNode&gt; (this TNode node, bool useDefaultCasing, string indentation, bool elasticTrivia) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static !!TNode NormalizeWhitespace&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(!!TNode node, bool useDefaultCasing, string indentation, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace``1(``0,System.Boolean,System.String,System.Boolean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TNode</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TNode" RefType="this" />
          <Parameter Name="useDefaultCasing" Type="System.Boolean" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="node">To be added.</param>
          <param name="useDefaultCasing">To be added.</param>
          <param name="indentation">To be added.</param>
          <param name="elasticTrivia">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace``1(``0,System.Boolean,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="NormalizeWhitespace&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static TNode NormalizeWhitespace&lt;TNode&gt; (this TNode node, bool useDefaultCasing, string indentation = &quot;    &quot;, string eol = &quot;&#xD;&#xA;&quot;, bool elasticTrivia = false) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static !!TNode NormalizeWhitespace&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(!!TNode node, bool useDefaultCasing, string indentation, string eol, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace``1(``0,System.Boolean,System.String,System.String,System.Boolean)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TNode</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TNode" RefType="this" />
          <Parameter Name="useDefaultCasing" Type="System.Boolean" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="eol" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="node">To be added.</param>
          <param name="useDefaultCasing">To be added.</param>
          <param name="indentation">To be added.</param>
          <param name="eol">To be added.</param>
          <param name="elasticTrivia">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace``1(``0,System.Boolean,System.String,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ToSyntaxTriviaList">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTriviaList ToSyntaxTriviaList (this System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; sequence);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxTriviaList ToSyntaxTriviaList(class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; sequence) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.ToSyntaxTriviaList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTriviaList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="sequence" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="sequence">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.ToSyntaxTriviaList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="TryGetInferredMemberName">
        <MemberSignature Language="C#" Value="public static string TryGetInferredMemberName (this Microsoft.CodeAnalysis.SyntaxNode syntax);" />
        <MemberSignature Language="ILAsm" Value=".method public static string TryGetInferredMemberName(class Microsoft.CodeAnalysis.SyntaxNode syntax) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.TryGetInferredMemberName(Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="syntax" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
        </Parameters>
        <Docs>
          <param name="syntax">To be added.</param>
          <summary>
 Given an initializer expression infer the name of anonymous property or tuple element.
 Returns Nothing if unsuccessful
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.TryGetInferredMemberName(Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax" />
      </Targets>
      <Member MemberName="Type">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax Type (this Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseSyntax);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax Type(class Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseSyntax) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Type(Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="asClauseSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax" RefType="this" />
        </Parameters>
        <Docs>
          <param name="asClauseSyntax">To be added.</param>
          <summary>
 Returns the TypeSyntax of the given AsClauseSyntax if specified.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Type(Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax" />
      </Targets>
      <Member MemberName="Type">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax Type (this Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax newExpressionSyntax);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax Type(class Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax newExpressionSyntax) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Type(Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="newExpressionSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax" RefType="this" />
        </Parameters>
        <Docs>
          <param name="newExpressionSyntax">To be added.</param>
          <summary>
 Returns the TypeSyntax of the given NewExpressionSyntax if specified.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Type(Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax" />
      </Targets>
      <Member MemberName="WithIdentifier">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax WithIdentifier (this Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax simpleName, Microsoft.CodeAnalysis.SyntaxToken identifier);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax WithIdentifier(class Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax simpleName, valuetype Microsoft.CodeAnalysis.SyntaxToken identifier) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.WithIdentifier(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="simpleName" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax" RefType="this" />
          <Parameter Name="identifier" Type="Microsoft.CodeAnalysis.SyntaxToken" />
        </Parameters>
        <Docs>
          <param name="simpleName" />
          <param name="identifier" />
          <summary>
 Updates the given SimpleNameSyntax node with the given identifier token.
 This function is a wrapper that calls WithIdentifier on derived syntax nodes.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.WithIdentifier(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.TypedConstant" />
      </Targets>
      <Member MemberName="ToVisualBasicString">
        <MemberSignature Language="C#" Value="public static string ToVisualBasicString (this Microsoft.CodeAnalysis.TypedConstant constant);" />
        <MemberSignature Language="ILAsm" Value=".method public static string ToVisualBasicString(valuetype Microsoft.CodeAnalysis.TypedConstant constant) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.TypedConstantExtensions.ToVisualBasicString(Microsoft.CodeAnalysis.TypedConstant)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="constant" Type="Microsoft.CodeAnalysis.TypedConstant" RefType="this" />
        </Parameters>
        <Docs>
          <param name="constant">To be added.</param>
          <summary>
 Returns the System.String that represents the current TypedConstant.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.TypedConstantExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.TypedConstantExtensions.ToVisualBasicString(Microsoft.CodeAnalysis.TypedConstant)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTokenList" />
      </Targets>
      <Member MemberName="Add">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTokenList Add (this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.SyntaxToken[] items);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxTokenList Add(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, valuetype Microsoft.CodeAnalysis.SyntaxToken[] items) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Add(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken[])" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTokenList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
          <Parameter Name="items" Type="Microsoft.CodeAnalysis.SyntaxToken[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="list">To be added.</param>
          <param name="items">To be added.</param>
          <summary>
 Add one or more tokens to the end of the list.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Add(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="AliasImports">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IAliasSymbol&gt; AliasImports (this Microsoft.CodeAnalysis.Compilation compilation);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.IAliasSymbol&gt; AliasImports(class Microsoft.CodeAnalysis.Compilation compilation) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AliasImports(Microsoft.CodeAnalysis.Compilation)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IAliasSymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="compilation">A source Compilation object.</param>
          <summary>
 Gets the compilation AliasImports property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AliasImports(Microsoft.CodeAnalysis.Compilation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeControlFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax statement);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax statement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="statement" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="statement">To be added.</param>
          <summary>
 Analyze control-flow within a part of a method body.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeControlFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax lastStatement);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax firstStatement, class Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax lastStatement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax" />
          <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="firstStatement">To be added.</param>
          <param name="lastStatement">To be added.</param>
          <summary>
 Analyze control-flow within a part of a method body.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeDataFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <summary>
 Analyze data-flow within an expression. 
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeDataFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax statement);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax statement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="statement" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="statement">To be added.</param>
          <summary>
 Analyze data-flow within a statement.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeDataFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax lastStatement);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax firstStatement, class Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax lastStatement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax" />
          <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="firstStatement">To be added.</param>
          <param name="lastStatement">To be added.</param>
          <summary>
 Analyze data-flow within a set of contiguous statements.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IEventSymbol" />
      </Targets>
      <Member MemberName="AssociatedField">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IFieldSymbol AssociatedField (this Microsoft.CodeAnalysis.IEventSymbol eventSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IFieldSymbol AssociatedField(class Microsoft.CodeAnalysis.IEventSymbol eventSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AssociatedField(Microsoft.CodeAnalysis.IEventSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IFieldSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="eventSymbol" Type="Microsoft.CodeAnalysis.IEventSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="eventSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AssociatedField(Microsoft.CodeAnalysis.IEventSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="ClassifyConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.Compilation compilation, class Microsoft.CodeAnalysis.ITypeSymbol source, class Microsoft.CodeAnalysis.ITypeSymbol destination) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
          <Parameter Name="source" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
          <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        </Parameters>
        <Docs>
          <param name="compilation">A source Compilation object.</param>
          <param name="source">A source Typesymbol</param>
          <param name="destination">A destination Typesymbol</param>
          <summary>
 Determines what kind of conversion there is between the specified types.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="ClassifyConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, class Microsoft.CodeAnalysis.ITypeSymbol destination) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source semantic model.</param>
          <param name="expression">A source expression syntax.</param>
          <param name="destination">A destination TypeSymbol.</param>
          <summary>
 Determines what kind of conversion there is between the expression syntax and a specified type.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="ClassifyConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, class Microsoft.CodeAnalysis.ITypeSymbol destination) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source semantic model.</param>
          <param name="position">A position within the expression syntax.</param>
          <param name="expression">A source expression syntax.</param>
          <param name="destination">A destination TypeSymbol.</param>
          <summary>
 Determines what kind of conversion there is between the expression syntax and a specified type.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetAggregateClauseSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.AggregateClauseSymbolInfo GetAggregateClauseSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax aggregateSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.AggregateClauseSymbolInfo GetAggregateClauseSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax aggregateSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAggregateClauseSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.AggregateClauseSymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="aggregateSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="aggregateSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Returns information about methods associated with AggregateClauseSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAggregateClauseSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetAliasInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax nameSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax nameSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="nameSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 If "nameSyntax" resolves to an alias name, return the AliasSymbol corresponding
 to A. Otherwise return null.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetAwaitExpressionInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.AwaitExpressionInfo GetAwaitExpressionInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax awaitExpression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.AwaitExpressionInfo GetAwaitExpressionInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax awaitExpression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.AwaitExpressionInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="awaitExpression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="awaitExpression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding AwaitExpressionInfo containing semantic info for a specified AwaitExpressionSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="GetBase">
        <MemberSignature Language="C#" Value="public static Nullable&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralBase&gt; GetBase (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Nullable`1&lt;valuetype Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralBase&gt; GetBase(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetBase(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Nullable&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralBase&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">The source SyntaxToken.</param>
          <summary>
 The source token base for Integer literals.  Base can be Decimal, Hex or Octal.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetBase(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetCollectionInitializerSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetCollectionInitializerSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetCollectionInitializerSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax 
 within <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax.Initializer" />.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetCollectionRangeVariableSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.CollectionRangeVariableSymbolInfo GetCollectionRangeVariableSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax variableSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.CollectionRangeVariableSymbolInfo GetCollectionRangeVariableSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax variableSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCollectionRangeVariableSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.CollectionRangeVariableSymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="variableSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="variableSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Returns information about methods associated with CollectionRangeVariableSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCollectionRangeVariableSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTree" />
      </Targets>
      <Member MemberName="GetCompilationUnitRoot">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax GetCompilationUnitRoot (this Microsoft.CodeAnalysis.SyntaxTree tree);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax GetCompilationUnitRoot(class Microsoft.CodeAnalysis.SyntaxTree tree) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="tree" Type="Microsoft.CodeAnalysis.SyntaxTree" RefType="this" />
        </Parameters>
        <Docs>
          <param name="tree">The source SyntaxTree.</param>
          <summary>
 Gets the root CompilationUnitSyntax for a specified SyntaxTree.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion GetConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion GetConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding TypeInfo containing semantic info for a specified ExpressionSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding MethodSymbol for a specified AccessorStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax rangeVariableSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax rangeVariableSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="rangeVariableSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="rangeVariableSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding RangeVariableSymbol for a specified AggregationRangeVariableSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax anonymousObjectCreationExpressionSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax anonymousObjectCreationExpressionSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="anonymousObjectCreationExpressionSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="anonymousObjectCreationExpressionSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding  NamedTypeSymbol for a specified  AnonymousObjectCreationExpressionSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ILocalSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding LocalSymbol for a specified CatchStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax rangeVariableSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax rangeVariableSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="rangeVariableSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="rangeVariableSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding RangeVariableSymbol for a specified CollectionRangeVariableSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding symbol for a specified  DeclareStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding NamedTypeSymbol for a specified DelegateStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding NamedTypeSymbol for a specified EnumBlockSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IFieldSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IFieldSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IFieldSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding FieldSymbol for a specified EnumMemberDeclarationSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding NamedTypeSymbol for a specified EnumStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IEventSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding EventSymbol for a specified EventBlockSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IEventSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding EventSymbol for a specified EventStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax rangeVariableSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax rangeVariableSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="rangeVariableSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="rangeVariableSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding RangeVariableSymbol for a specified ExpressionRangeVariableSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax fieldInitializerSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax fieldInitializerSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="fieldInitializerSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source semantic model.</param>
          <param name="fieldInitializerSyntax">A FieldInitializerSyntax object.</param>
          <param name="cancellationToken">A cancellation token.</param>
          <summary>
 Gets the corresponding PropertySymbol for a specified FieldInitializerSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ILabelSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding LabelSymbol for a specified LabelStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding MethodSymbol for a specified MethodBlockBaseSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding MethodSymbol for a specified MethodStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifierSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifierSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="identifierSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source semantic model.</param>
          <param name="identifierSyntax">A IdentifierSyntax object.</param>
          <param name="cancellationToken">A cancellation token.</param>
          <summary>
 Gets the corresponding symbol for a specified identifier.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding NamespaceSymbol for a specified NamespaceBlockSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding NamespaceSymbol for a specified NamespaceStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding MethodSymbol for a specified OperatorStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IParameterSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax parameter, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IParameterSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax parameter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IParameterSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="parameter" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="parameter">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding ParameterSymbol for a specified ParameterSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding PropertySymbol for a specified PropertyBlockSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding PropertySymbol for a specified PropertyStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding AliasSymbol for a specified AliasImportsClauseSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding MethodSymbol for a specified SubNewStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax elementSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax elementSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="elementSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source semantic model.</param>
          <param name="elementSyntax">A TupleElementSyntax object.</param>
          <param name="cancellationToken">A cancellation token.</param>
          <summary>
 Gets the corresponding symbol for a specified tuple element.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding NamedTypeSymbol for a specified TypeBlockSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ITypeParameterSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax typeParameter, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.ITypeParameterSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax typeParameter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ITypeParameterSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="typeParameter" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="typeParameter">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding TypeParameterSymbol Symbol for a specified TypeParameterSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding NamedTypeSymbol for a specified TypeStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="GetDirectives">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IList&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax&gt; GetDirectives (this Microsoft.CodeAnalysis.SyntaxNode node, Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,bool&gt; filter = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IList`1&lt;class Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax&gt; GetDirectives(class Microsoft.CodeAnalysis.SyntaxNode node, class System.Func`2&lt;class Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax, bool&gt; filter) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDirectives(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IList&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="filter" Type="System.Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean&gt;" />
        </Parameters>
        <Docs>
          <param name="node">The source SyntaxNode.</param>
          <param name="filter">The optional DirectiveTrivia Syntax filter predicate.</param>
          <summary>
 Gets the DirectiveTriviaSyntax items for a specified SyntaxNode with optional filtering.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDirectives(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IEventSymbol" />
      </Targets>
      <Member MemberName="GetFieldAttributes">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.AttributeData&gt; GetFieldAttributes (this Microsoft.CodeAnalysis.IEventSymbol eventSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.AttributeData&gt; GetFieldAttributes(class Microsoft.CodeAnalysis.IEventSymbol eventSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetFieldAttributes(Microsoft.CodeAnalysis.IEventSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.AttributeData&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="eventSymbol" Type="Microsoft.CodeAnalysis.IEventSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="eventSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetFieldAttributes(Microsoft.CodeAnalysis.IEventSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="GetFirstDirective">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax GetFirstDirective (this Microsoft.CodeAnalysis.SyntaxNode node, Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,bool&gt; predicate = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax GetFirstDirective(class Microsoft.CodeAnalysis.SyntaxNode node, class System.Func`2&lt;class Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax, bool&gt; predicate) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="predicate" Type="System.Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean&gt;" />
        </Parameters>
        <Docs>
          <param name="node">The source SyntaxNode.</param>
          <param name="predicate">The optional DirectiveTriviaSyntax filter predicate.</param>
          <summary>
 Gets the first DirectiveTriviaSyntax item for a specified SyntaxNode.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetForEachStatementInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo GetForEachStatementInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax node);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo GetForEachStatementInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <summary>
 Gets the corresponding ForEachStatementInfo containing semantic info for a specified ForBlockSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetForEachStatementInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo GetForEachStatementInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax node);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo GetForEachStatementInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <summary>
 Gets the corresponding ForEachStatementInfo containing semantic info for a specified ForEachStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="GetIdentifierText">
        <MemberSignature Language="C#" Value="public static string GetIdentifierText (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static string GetIdentifierText(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetIdentifierText(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>
 Returns the Identifiertext for a specified SyntaxToken.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetIdentifierText(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="GetLastDirective">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax GetLastDirective (this Microsoft.CodeAnalysis.SyntaxNode node, Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,bool&gt; predicate = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax GetLastDirective(class Microsoft.CodeAnalysis.SyntaxNode node, class System.Func`2&lt;class Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax, bool&gt; predicate) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="predicate" Type="System.Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean&gt;" />
        </Parameters>
        <Docs>
          <param name="node">The source node</param>
          <param name="predicate">The optional DirectiveTriviaSyntax filter predicate.</param>
          <summary>
 Gets the last DirectiveTriviaSyntax item for a specified SyntaxNode.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetMemberGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="attribute">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding ImmutableArray of Symbols for a specified AttributeSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetMemberGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding ImmutableArray of Symbols for a specified ExpressionSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.INamespaceSymbol" />
      </Targets>
      <Member MemberName="GetModuleMembers">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamedTypeSymbol&gt; GetModuleMembers (this Microsoft.CodeAnalysis.INamespaceSymbol namespace);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.INamedTypeSymbol&gt; GetModuleMembers(class Microsoft.CodeAnalysis.INamespaceSymbol namespace) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetModuleMembers(Microsoft.CodeAnalysis.INamespaceSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamedTypeSymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="namespace" Type="Microsoft.CodeAnalysis.INamespaceSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="namespace">To be added.</param>
          <summary>
 Gets all module members in a namespace.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetModuleMembers(Microsoft.CodeAnalysis.INamespaceSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.INamespaceSymbol" />
      </Targets>
      <Member MemberName="GetModuleMembers">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamedTypeSymbol&gt; GetModuleMembers (this Microsoft.CodeAnalysis.INamespaceSymbol namespace, string name);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.INamedTypeSymbol&gt; GetModuleMembers(class Microsoft.CodeAnalysis.INamespaceSymbol namespace, string name) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetModuleMembers(Microsoft.CodeAnalysis.INamespaceSymbol,System.String)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamedTypeSymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="namespace" Type="Microsoft.CodeAnalysis.INamespaceSymbol" RefType="this" />
          <Parameter Name="name" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="namespace">To be added.</param>
          <param name="name">The name of the namespace.</param>
          <summary>
 Gets all module members in a specified namespace.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetModuleMembers(Microsoft.CodeAnalysis.INamespaceSymbol,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetPreprocessingSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.PreprocessingSymbolInfo GetPreprocessingSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax node);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.PreprocessingSymbolInfo GetPreprocessingSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.PreprocessingSymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <summary>
 If the given node is within a preprocessing directive, gets the preprocessing symbol info for it.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="GetSpecialType">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetSpecialType (this Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.SpecialType typeId);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamedTypeSymbol GetSpecialType(class Microsoft.CodeAnalysis.Compilation compilation, valuetype Microsoft.CodeAnalysis.SpecialType typeId) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpecialType(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.SpecialType)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
          <Parameter Name="typeId" Type="Microsoft.CodeAnalysis.SpecialType" />
        </Parameters>
        <Docs>
          <param name="compilation">A source Compilation object.</param>
          <param name="typeId">The SpecialType to get.</param>
          <summary>
 Gets the special type symbol in current compilation.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpecialType(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.SpecialType)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeAliasInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax nameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax nameSyntax, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="nameSyntax">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
 Binds the name in the context of the specified location and sees if it resolves to an
 alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion GetSpeculativeConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion GetSpeculativeConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeMemberGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetSpeculativeMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetSpeculativeMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeMemberGroup(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <summary>
 Gets the corresponding ImmutableArray of Symbols for a speculating an ExpressionSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeMemberGroup(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="attribute">To be added.</param>
          <summary>
 Gets the corresponding SymbolInfo containing semantic info for specified  AttributeSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
 Gets the corresponding SymbolInfo containing semantic info for a specified AttributeSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
 Gets the corresponding TypeInfo  containing semantic info for a speculating an ExpressionSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="attribute">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding SymbolInfo containing semantic info for a specified AttributeSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax crefReference, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax crefReference, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="crefReference" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="crefReference">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding SymbolInfo containing semantic info for a specified CrefReferenceSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax variableSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax variableSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="variableSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="variableSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Returns Select method associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax" /> within a <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax" />, 
 or <see cref="F:Microsoft.CodeAnalysis.SymbolInfo.None" /> otherwise if none is.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding SymbolInfo containing semantic info for a specified ExpressionSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax functionSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax functionSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="functionSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="functionSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Returns aggregate function associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax" />.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax orderingSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax orderingSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="orderingSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="orderingSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Returns OrderBy/OrderByDescending/ThenBy/ThenByDescending method associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax" />.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax clauseSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax clauseSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="clauseSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="clauseSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Returns symbol information for a query clause.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="GetTypeCharacter">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter GetTypeCharacter (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter GetTypeCharacter(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeCharacter(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">The source SyntaxToken.</param>
          <summary>
 Returns the Type character for a given syntax token.  This returns type character for Identifiers or Integer, Floating Point or Decimal Literals.
 Examples: Dim a$   or Dim l1 = 1L
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeCharacter(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="attribute">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding TypeInfo containing semantic info for a specified AttributeSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IMethodSymbol" />
      </Targets>
      <Member MemberName="HandledEvents">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.VisualBasic.HandledEvent&gt; HandledEvents (this Microsoft.CodeAnalysis.IMethodSymbol methodSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.VisualBasic.HandledEvent&gt; HandledEvents(class Microsoft.CodeAnalysis.IMethodSymbol methodSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.HandledEvents(Microsoft.CodeAnalysis.IMethodSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.VisualBasic.HandledEvent&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="methodSymbol" Type="Microsoft.CodeAnalysis.IMethodSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="methodSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.HandledEvents(Microsoft.CodeAnalysis.IMethodSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IEventSymbol" />
      </Targets>
      <Member MemberName="HasAssociatedField">
        <MemberSignature Language="C#" Value="public static bool HasAssociatedField (this Microsoft.CodeAnalysis.IEventSymbol eventSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool HasAssociatedField(class Microsoft.CodeAnalysis.IEventSymbol eventSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.HasAssociatedField(Microsoft.CodeAnalysis.IEventSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="eventSymbol" Type="Microsoft.CodeAnalysis.IEventSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="eventSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.HasAssociatedField(Microsoft.CodeAnalysis.IEventSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTokenList" />
      </Targets>
      <Member MemberName="Insert">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTokenList Insert (this Microsoft.CodeAnalysis.SyntaxTokenList list, int index, Microsoft.CodeAnalysis.SyntaxToken[] items);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxTokenList Insert(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, int32 index, valuetype Microsoft.CodeAnalysis.SyntaxToken[] items) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTokenList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
          <Parameter Name="index" Type="System.Int32" />
          <Parameter Name="items" Type="Microsoft.CodeAnalysis.SyntaxToken[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="list">To be added.</param>
          <param name="index">To be added.</param>
          <param name="items">To be added.</param>
          <summary>
 Insert one or more tokens in the list at the specified index.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsBracketed">
        <MemberSignature Language="C#" Value="public static bool IsBracketed (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsBracketed(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsBracketed(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">The source SyntaxToken.</param>
          <summary>
 Checks to see if SyntaxToken is a bracketed identifier.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsBracketed(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ILocalSymbol" />
      </Targets>
      <Member MemberName="IsCatch">
        <MemberSignature Language="C#" Value="public static bool IsCatch (this Microsoft.CodeAnalysis.ILocalSymbol localSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsCatch(class Microsoft.CodeAnalysis.ILocalSymbol localSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsCatch(Microsoft.CodeAnalysis.ILocalSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="localSymbol" Type="Microsoft.CodeAnalysis.ILocalSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="localSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsCatch(Microsoft.CodeAnalysis.ILocalSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsContextualKeyword">
        <MemberSignature Language="C#" Value="public static bool IsContextualKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsContextualKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>
 Determines if the token represents a contextual keyword
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IPropertySymbol" />
      </Targets>
      <Member MemberName="IsDefault">
        <MemberSignature Language="C#" Value="public static bool IsDefault (this Microsoft.CodeAnalysis.IPropertySymbol propertySymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsDefault(class Microsoft.CodeAnalysis.IPropertySymbol propertySymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsDefault(Microsoft.CodeAnalysis.IPropertySymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="propertySymbol" Type="Microsoft.CodeAnalysis.IPropertySymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="propertySymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsDefault(Microsoft.CodeAnalysis.IPropertySymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ILocalSymbol" />
      </Targets>
      <Member MemberName="IsFor">
        <MemberSignature Language="C#" Value="public static bool IsFor (this Microsoft.CodeAnalysis.ILocalSymbol localSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsFor(class Microsoft.CodeAnalysis.ILocalSymbol localSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsFor(Microsoft.CodeAnalysis.ILocalSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="localSymbol" Type="Microsoft.CodeAnalysis.ILocalSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="localSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsFor(Microsoft.CodeAnalysis.ILocalSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ILocalSymbol" />
      </Targets>
      <Member MemberName="IsForEach">
        <MemberSignature Language="C#" Value="public static bool IsForEach (this Microsoft.CodeAnalysis.ILocalSymbol localSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsForEach(class Microsoft.CodeAnalysis.ILocalSymbol localSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsForEach(Microsoft.CodeAnalysis.ILocalSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="localSymbol" Type="Microsoft.CodeAnalysis.ILocalSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="localSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsForEach(Microsoft.CodeAnalysis.ILocalSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IEventSymbol" />
      </Targets>
      <Member MemberName="IsImplicitlyDeclared">
        <MemberSignature Language="C#" Value="public static bool IsImplicitlyDeclared (this Microsoft.CodeAnalysis.IEventSymbol eventSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsImplicitlyDeclared(class Microsoft.CodeAnalysis.IEventSymbol eventSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsImplicitlyDeclared(Microsoft.CodeAnalysis.IEventSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="eventSymbol" Type="Microsoft.CodeAnalysis.IEventSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="eventSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsImplicitlyDeclared(Microsoft.CodeAnalysis.IEventSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsKeyword">
        <MemberSignature Language="C#" Value="public static bool IsKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">The source SyntaxToken.</param>
          <summary>
 Determines if the token represents a reserved or contextual keyword
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IParameterSymbol" />
      </Targets>
      <Member MemberName="IsMe">
        <MemberSignature Language="C#" Value="public static bool IsMe (this Microsoft.CodeAnalysis.IParameterSymbol parameterSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsMe(class Microsoft.CodeAnalysis.IParameterSymbol parameterSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsMe(Microsoft.CodeAnalysis.IParameterSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="parameterSymbol" Type="Microsoft.CodeAnalysis.IParameterSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="parameterSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsMe(Microsoft.CodeAnalysis.IParameterSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ISymbol" />
      </Targets>
      <Member MemberName="IsMustOverride">
        <MemberSignature Language="C#" Value="public static bool IsMustOverride (this Microsoft.CodeAnalysis.ISymbol symbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsMustOverride(class Microsoft.CodeAnalysis.ISymbol symbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsMustOverride(Microsoft.CodeAnalysis.ISymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="symbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsMustOverride(Microsoft.CodeAnalysis.ISymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ISymbol" />
      </Targets>
      <Member MemberName="IsNotOverridable">
        <MemberSignature Language="C#" Value="public static bool IsNotOverridable (this Microsoft.CodeAnalysis.ISymbol symbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsNotOverridable(class Microsoft.CodeAnalysis.ISymbol symbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsNotOverridable(Microsoft.CodeAnalysis.ISymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="symbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsNotOverridable(Microsoft.CodeAnalysis.ISymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IMethodSymbol" />
      </Targets>
      <Member MemberName="IsOverloads">
        <MemberSignature Language="C#" Value="public static bool IsOverloads (this Microsoft.CodeAnalysis.IMethodSymbol methodSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsOverloads(class Microsoft.CodeAnalysis.IMethodSymbol methodSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverloads(Microsoft.CodeAnalysis.IMethodSymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="methodSymbol" Type="Microsoft.CodeAnalysis.IMethodSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="methodSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverloads(Microsoft.CodeAnalysis.IMethodSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IPropertySymbol" />
      </Targets>
      <Member MemberName="IsOverloads">
        <MemberSignature Language="C#" Value="public static bool IsOverloads (this Microsoft.CodeAnalysis.IPropertySymbol propertySymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsOverloads(class Microsoft.CodeAnalysis.IPropertySymbol propertySymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverloads(Microsoft.CodeAnalysis.IPropertySymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="propertySymbol" Type="Microsoft.CodeAnalysis.IPropertySymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="propertySymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverloads(Microsoft.CodeAnalysis.IPropertySymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ISymbol" />
      </Targets>
      <Member MemberName="IsOverridable">
        <MemberSignature Language="C#" Value="public static bool IsOverridable (this Microsoft.CodeAnalysis.ISymbol symbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsOverridable(class Microsoft.CodeAnalysis.ISymbol symbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverridable(Microsoft.CodeAnalysis.ISymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="symbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverridable(Microsoft.CodeAnalysis.ISymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ISymbol" />
      </Targets>
      <Member MemberName="IsOverrides">
        <MemberSignature Language="C#" Value="public static bool IsOverrides (this Microsoft.CodeAnalysis.ISymbol symbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsOverrides(class Microsoft.CodeAnalysis.ISymbol symbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverrides(Microsoft.CodeAnalysis.ISymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="symbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverrides(Microsoft.CodeAnalysis.ISymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsPreprocessorKeyword">
        <MemberSignature Language="C#" Value="public static bool IsPreprocessorKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsPreprocessorKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsPreprocessorKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">The source SyntaxToken.</param>
          <summary>
 Determines if the token  represents a preprocessor keyword
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsPreprocessorKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsReservedKeyword">
        <MemberSignature Language="C#" Value="public static bool IsReservedKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsReservedKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">The source SyntaxToken.</param>
          <summary>
 Determines if the token represents a reserved keyword
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ISymbol" />
      </Targets>
      <Member MemberName="IsShared">
        <MemberSignature Language="C#" Value="public static bool IsShared (this Microsoft.CodeAnalysis.ISymbol symbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsShared(class Microsoft.CodeAnalysis.ISymbol symbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsShared(Microsoft.CodeAnalysis.ISymbol)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="symbol">The source symbol.</param>
          <summary>
 Determines if symbol is Shared.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsShared(Microsoft.CodeAnalysis.ISymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxNode node);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind(class Microsoft.CodeAnalysis.SyntaxNode node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
        </Parameters>
        <Docs>
          <param name="node">To be added.</param>
          <summary>
 Returns <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> for <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" /> from <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind" /> property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="nodeOrToken">To be added.</param>
          <summary>
 Returns <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> for <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> from <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind" /> property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>
 Returns <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> for <see cref="T:Microsoft.CodeAnalysis.SyntaxToken" /> from <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind" /> property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTrivia" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxTrivia trivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxTrivia trivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" RefType="this" />
        </Parameters>
        <Docs>
          <param name="trivia">To be added.</param>
          <summary>
 Returns <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> for <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia" /> nodes.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="MemberImports">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamespaceOrTypeSymbol&gt; MemberImports (this Microsoft.CodeAnalysis.Compilation compilation);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol&gt; MemberImports(class Microsoft.CodeAnalysis.Compilation compilation) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.MemberImports(Microsoft.CodeAnalysis.Compilation)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamespaceOrTypeSymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="compilation">A source Compilation object.</param>
          <summary>
  Gets the compilation MemberImports property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.MemberImports(Microsoft.CodeAnalysis.Compilation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="OptionCompareText">
        <MemberSignature Language="C#" Value="public static bool OptionCompareText (this Microsoft.CodeAnalysis.SemanticModel semanticModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool OptionCompareText(class Microsoft.CodeAnalysis.SemanticModel semanticModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionCompareText(Microsoft.CodeAnalysis.SemanticModel)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source Semantic model object.</param>
          <summary>
 Gets the Semantic Model OptionCompareText property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionCompareText(Microsoft.CodeAnalysis.SemanticModel)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="OptionExplicit">
        <MemberSignature Language="C#" Value="public static bool OptionExplicit (this Microsoft.CodeAnalysis.SemanticModel semanticModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool OptionExplicit(class Microsoft.CodeAnalysis.SemanticModel semanticModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionExplicit(Microsoft.CodeAnalysis.SemanticModel)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source Semantic model object.</param>
          <summary>
 Gets the Semantic Model OptionExplicit property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionExplicit(Microsoft.CodeAnalysis.SemanticModel)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="OptionInfer">
        <MemberSignature Language="C#" Value="public static bool OptionInfer (this Microsoft.CodeAnalysis.SemanticModel semanticModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool OptionInfer(class Microsoft.CodeAnalysis.SemanticModel semanticModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionInfer(Microsoft.CodeAnalysis.SemanticModel)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source Semantic model object.</param>
          <summary>
 Gets the Semantic Model OptionInfer property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionInfer(Microsoft.CodeAnalysis.SemanticModel)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="OptionStrict">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.OptionStrict OptionStrict (this Microsoft.CodeAnalysis.SemanticModel semanticModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.OptionStrict OptionStrict(class Microsoft.CodeAnalysis.SemanticModel semanticModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionStrict(Microsoft.CodeAnalysis.SemanticModel)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.OptionStrict</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source Semantic model object.</param>
          <summary>
 Gets the Semantic Model OptionStrict property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionStrict(Microsoft.CodeAnalysis.SemanticModel)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="ReplaceTrivia">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia (this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, Microsoft.CodeAnalysis.SyntaxTrivia newTrivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(valuetype Microsoft.CodeAnalysis.SyntaxToken token, valuetype Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia newTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="oldTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
          <Parameter Name="newTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
        </Parameters>
        <Docs>
          <param name="token">The source SyntaxToken to change trivia on.</param>
          <param name="oldTrivia">The original Trivia.</param>
          <param name="newTrivia">The updated Trivia.</param>
          <summary>
  Replaces trivia on a specified SyntaxToken.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="ReplaceTrivia">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia (this Microsoft.CodeAnalysis.SyntaxToken token, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(valuetype Microsoft.CodeAnalysis.SyntaxToken token, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, class System.Func`3&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="trivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
          <Parameter Name="computeReplacementTrivia" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <param name="trivia">To be added.</param>
          <param name="computeReplacementTrivia">To be added.</param>
          <summary>
  Replaces trivia on a specified SyntaxToken.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="RootNamespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamespaceSymbol RootNamespace (this Microsoft.CodeAnalysis.Compilation compilation);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamespaceSymbol RootNamespace(class Microsoft.CodeAnalysis.Compilation compilation) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.RootNamespace(Microsoft.CodeAnalysis.Compilation)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="compilation">A source Compilation object.</param>
          <summary>
 Gets the compilation RootNamespace property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.RootNamespace(Microsoft.CodeAnalysis.Compilation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, class Microsoft.CodeAnalysis.SemanticModel speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="attribute">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
 Gets the SemanticModel for a AttributeSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax initializer, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax initializer, class Microsoft.CodeAnalysis.SemanticModel speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="initializer" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="initializer">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
 Gets the SemanticModel for a EqualsValueSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax statement, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax statement, class Microsoft.CodeAnalysis.SemanticModel speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="statement" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="statement">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
 Gets the SemanticModel for a ExecutableStatementSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax rangeArgument, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax rangeArgument, class Microsoft.CodeAnalysis.SemanticModel speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="rangeArgument" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="rangeArgument">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
 Gets the SemanticModel for a RangeArgumentSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type, out Microsoft.CodeAnalysis.SemanticModel speculativeModel, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption = Microsoft.CodeAnalysis.SpeculativeBindingOption.BindAsExpression);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type, class Microsoft.CodeAnalysis.SemanticModel speculativeModel, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="type" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="type">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
 Gets the SemanticModel for a TypeSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModelForMethodBody">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModelForMethodBody (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax method, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool TryGetSpeculativeSemanticModelForMethodBody(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax method, class Microsoft.CodeAnalysis.SemanticModel speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="method" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel&amp;" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="method">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
 Gets the SemanticModel for a MethodBlockBaseSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTokenList" />
      </Targets>
      <Member MemberName="Any">
        <MemberSignature Language="C#" Value="public static bool Any (this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool Any(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list">To be added.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to test for.</param>
          <summary>
 Tests whether a list contains token of a particular kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />
      </Targets>
      <Member MemberName="Any">
        <MemberSignature Language="C#" Value="public static bool Any (this Microsoft.CodeAnalysis.SyntaxTriviaList list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool Any(valuetype Microsoft.CodeAnalysis.SyntaxTriviaList list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list">To be added.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to test for.</param>
          <summary>
 Tests whether a list contains trivia of a particular kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />
      </Targets>
      <Member MemberName="Any&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static bool Any&lt;TNode&gt; (this Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static bool Any&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SeparatedSyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">To be added.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to test for.</param>
          <summary>
 Tests whether a list contains node of a particular kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxList`1" />
      </Targets>
      <Member MemberName="Any&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static bool Any&lt;TNode&gt; (this Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static bool Any&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">To be added.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to test for.</param>
          <summary>
 Tests whether a list contains node of a particular kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTokenList" />
      </Targets>
      <Member MemberName="IndexOf">
        <MemberSignature Language="C#" Value="public static int IndexOf (this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static int32 IndexOf(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list">Token list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to find.</param>
          <summary>
 Returns the index of the first token of a specified kind in the token list.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />
      </Targets>
      <Member MemberName="IndexOf">
        <MemberSignature Language="C#" Value="public static int IndexOf (this Microsoft.CodeAnalysis.SyntaxTriviaList list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static int32 IndexOf(valuetype Microsoft.CodeAnalysis.SyntaxTriviaList list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list">Trivia list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to find.</param>
          <summary>
 Returns the index of the first trivia of a specified kind in the trivia list.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />
      </Targets>
      <Member MemberName="IndexOf&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static int IndexOf&lt;TNode&gt; (this Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static int32 IndexOf&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SeparatedSyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">Node list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to find.</param>
          <summary>
 Returns the index of the first node of a specified kind in the node list.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxList`1" />
      </Targets>
      <Member MemberName="IndexOf&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static int IndexOf&lt;TNode&gt; (this Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static int32 IndexOf&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">Node list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to find.</param>
          <summary>
 Returns the index of the first node of a specified kind in the node list.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsKind(class Microsoft.CodeAnalysis.SyntaxNode node, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="node">The Source SyntaxNode.</param>
          <param name="kind">The SyntaxKind to test for.</param>
          <summary>
 Determines if SyntaxNode is a specified kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsKind(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="nodeOrToken">The source SyntaxNodeOrToke.</param>
          <param name="kind">The SyntaxKind to test for.</param>
          <summary>
 Determines if a SyntaxNodeOrToken is a specified kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsKind(valuetype Microsoft.CodeAnalysis.SyntaxToken token, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="token">The Source SyntaxToken.</param>
          <param name="kind">The SyntaxKind to test for.</param>
          <summary>
 Determines if SyntaxToken is a specified kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTrivia" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxTrivia trivia, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsKind(valuetype Microsoft.CodeAnalysis.SyntaxTrivia trivia, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="trivia">The Source SyntaxTrivia.</param>
          <param name="kind">The SyntaxKind to test for.</param>
          <summary>
 Determines if SyntaxTrivia is a specified kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
  </ExtensionMethods>
</Overview>
