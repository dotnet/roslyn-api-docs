<Type Name="CSharpCompilation" FullName="Microsoft.CodeAnalysis.CSharp.CSharpCompilation">
  <TypeSignature Language="C#" Value="public sealed class CSharpCompilation : Microsoft.CodeAnalysis.Compilation" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit CSharpCompilation extends Microsoft.CodeAnalysis.Compilation" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class CSharpCompilation&#xA;Inherits Compilation" />
  <TypeSignature Language="F#" Value="type CSharpCompilation = class&#xA;    inherit Compilation" />
  <TypeSignature Language="C++ CLI" Value="public ref class CSharpCompilation sealed : Microsoft::CodeAnalysis::Compilation" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
    <AssemblyVersion>2.9.0.0</AssemblyVersion>
    <AssemblyVersion>3.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.CodeAnalysis.Compilation</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            The compilation object is an immutable representation of a single invocation of the
            compiler. Although immutable, a compilation is also on-demand, and will realize and cache
            data as necessary. A compilation can produce a new compilation from existing compilation
            with the application of small deltas. In many cases, it is more efficient than creating a
            new compilation from scratch, as the new compilation can reuse information from the old
            compilation.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AddReferences">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddReferences (params Microsoft.CodeAnalysis.MetadataReference[] references);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddReferences(class Microsoft.CodeAnalysis.MetadataReference[] references) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences(Microsoft.CodeAnalysis.MetadataReference[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AddReferences (ParamArray references As MetadataReference()) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.AddReferences : Microsoft.CodeAnalysis.MetadataReference[] -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.AddReferences references" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ AddReferences(... cli::array &lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ references);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="references" Type="Microsoft.CodeAnalysis.MetadataReference[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="references">To be added.</param>
        <summary>
            Creates a new compilation with additional metadata references.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddReferences">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddReferences (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; references);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddReferences(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.MetadataReference&gt; references) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddReferences (references As IEnumerable(Of MetadataReference)) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.AddReferences : seq&lt;Microsoft.CodeAnalysis.MetadataReference&gt; -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.AddReferences references" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ AddReferences(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ references);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="references" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt;" />
      </Parameters>
      <Docs>
        <param name="references">To be added.</param>
        <summary>
            Creates a new compilation with additional metadata references.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSyntaxTrees">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddSyntaxTrees (params Microsoft.CodeAnalysis.SyntaxTree[] trees);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddSyntaxTrees(class Microsoft.CodeAnalysis.SyntaxTree[] trees) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AddSyntaxTrees (ParamArray trees As SyntaxTree()) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.AddSyntaxTrees : Microsoft.CodeAnalysis.SyntaxTree[] -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.AddSyntaxTrees trees" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ AddSyntaxTrees(... cli::array &lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ trees);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trees" Type="Microsoft.CodeAnalysis.SyntaxTree[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trees">To be added.</param>
        <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSyntaxTrees">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddSyntaxTrees (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; trees);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddSyntaxTrees(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxTree&gt; trees) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddSyntaxTrees (trees As IEnumerable(Of SyntaxTree)) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.AddSyntaxTrees : seq&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.AddSyntaxTrees trees" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ AddSyntaxTrees(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ trees);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trees" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;" />
      </Parameters>
      <Docs>
        <param name="trees">To be added.</param>
        <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendDefaultVersionResource">
      <MemberSignature Language="C#" Value="protected override void AppendDefaultVersionResource (System.IO.Stream resourceStream);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void AppendDefaultVersionResource(class System.IO.Stream resourceStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AppendDefaultVersionResource(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub AppendDefaultVersionResource (resourceStream As Stream)" />
      <MemberSignature Language="F#" Value="override this.AppendDefaultVersionResource : System.IO.Stream -&gt; unit" Usage="cSharpCompilation.AppendDefaultVersionResource resourceStream" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void AppendDefaultVersionResource(System::IO::Stream ^ resourceStream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="resourceStream">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassifyCommonConversion">
      <MemberSignature Language="C#" Value="public override Microsoft.CodeAnalysis.Operations.CommonConversion ClassifyCommonConversion (Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype Microsoft.CodeAnalysis.Operations.CommonConversion ClassifyCommonConversion(class Microsoft.CodeAnalysis.ITypeSymbol source, class Microsoft.CodeAnalysis.ITypeSymbol destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ClassifyCommonConversion(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ClassifyCommonConversion (source As ITypeSymbol, destination As ITypeSymbol) As CommonConversion" />
      <MemberSignature Language="F#" Value="override this.ClassifyCommonConversion : Microsoft.CodeAnalysis.ITypeSymbol * Microsoft.CodeAnalysis.ITypeSymbol -&gt; Microsoft.CodeAnalysis.Operations.CommonConversion" Usage="cSharpCompilation.ClassifyCommonConversion (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Microsoft::CodeAnalysis::Operations::CommonConversion ClassifyCommonConversion(Microsoft::CodeAnalysis::ITypeSymbol ^ source, Microsoft::CodeAnalysis::ITypeSymbol ^ destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Operations.CommonConversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
      </Parameters>
      <Docs>
        <param name="source">Source type of value to be converted</param>
        <param name="destination">Destination type of value to be converted</param>
        <summary>
            Classifies a conversion from <paramref name="source" /> to <paramref name="destination" /> according
            to this compilation's programming language.
            </summary>
        <returns>A <see cref="T:Microsoft.CodeAnalysis.Operations.CommonConversion" /> that classifies the conversion from the
            <paramref name="source" /> type to the <paramref name="destination" /> type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassifyConversion">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion (Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.ITypeSymbol source, class Microsoft.CodeAnalysis.ITypeSymbol destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ClassifyConversion(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
      <MemberSignature Language="VB.NET" Value="Public Function ClassifyConversion (source As ITypeSymbol, destination As ITypeSymbol) As Conversion" />
      <MemberSignature Language="F#" Value="member this.ClassifyConversion : Microsoft.CodeAnalysis.ITypeSymbol * Microsoft.CodeAnalysis.ITypeSymbol -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="cSharpCompilation.ClassifyConversion (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::Conversion ClassifyConversion(Microsoft::CodeAnalysis::ITypeSymbol ^ source, Microsoft::CodeAnalysis::ITypeSymbol ^ destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.Clone " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Create a duplicate of this compilation with different symbol instances.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonAddSyntaxTrees">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.Compilation CommonAddSyntaxTrees (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; trees);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.Compilation CommonAddSyntaxTrees(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxTree&gt; trees) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonAddSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonAddSyntaxTrees (trees As IEnumerable(Of SyntaxTree)) As Compilation" />
      <MemberSignature Language="F#" Value="override this.CommonAddSyntaxTrees : seq&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; -&gt; Microsoft.CodeAnalysis.Compilation" Usage="cSharpCompilation.CommonAddSyntaxTrees trees" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::Compilation ^ CommonAddSyntaxTrees(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ trees);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trees" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;" />
      </Parameters>
      <Docs>
        <param name="trees">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonAssembly">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.IAssemblySymbol CommonAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.IAssemblySymbol CommonAssembly" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonAssembly" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CommonAssembly As IAssemblySymbol" />
      <MemberSignature Language="F#" Value="member this.CommonAssembly : Microsoft.CodeAnalysis.IAssemblySymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonAssembly" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property Microsoft::CodeAnalysis::IAssemblySymbol ^ CommonAssembly { Microsoft::CodeAnalysis::IAssemblySymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IAssemblySymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonClone">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.Compilation CommonClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.Compilation CommonClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonClone" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonClone () As Compilation" />
      <MemberSignature Language="F#" Value="override this.CommonClone : unit -&gt; Microsoft.CodeAnalysis.Compilation" Usage="cSharpCompilation.CommonClone " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::Compilation ^ CommonClone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonContainsSyntaxTree">
      <MemberSignature Language="C#" Value="protected override bool CommonContainsSyntaxTree (Microsoft.CodeAnalysis.SyntaxTree syntaxTree);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool CommonContainsSyntaxTree(class Microsoft.CodeAnalysis.SyntaxTree syntaxTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree)" />
      <MemberSignature Language="F#" Value="override this.CommonContainsSyntaxTree : Microsoft.CodeAnalysis.SyntaxTree -&gt; bool" Usage="cSharpCompilation.CommonContainsSyntaxTree syntaxTree" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool CommonContainsSyntaxTree(Microsoft::CodeAnalysis::SyntaxTree ^ syntaxTree);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="syntaxTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
      </Parameters>
      <Docs>
        <param name="syntaxTree">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonCreateAnonymousTypeSymbol">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateAnonymousTypeSymbol (System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; memberTypes, System.Collections.Immutable.ImmutableArray&lt;string&gt; memberNames, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; memberLocations, System.Collections.Immutable.ImmutableArray&lt;bool&gt; memberIsReadOnly);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateAnonymousTypeSymbol(valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ITypeSymbol&gt; memberTypes, valuetype System.Collections.Immutable.ImmutableArray`1&lt;string&gt; memberNames, valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Location&gt; memberLocations, valuetype System.Collections.Immutable.ImmutableArray`1&lt;bool&gt; memberIsReadOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonCreateAnonymousTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableArray{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonCreateAnonymousTypeSymbol (memberTypes As ImmutableArray(Of ITypeSymbol), memberNames As ImmutableArray(Of String), memberLocations As ImmutableArray(Of Location), memberIsReadOnly As ImmutableArray(Of Boolean)) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="override this.CommonCreateAnonymousTypeSymbol : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; * System.Collections.Immutable.ImmutableArray&lt;string&gt; * System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; * System.Collections.Immutable.ImmutableArray&lt;bool&gt; -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="cSharpCompilation.CommonCreateAnonymousTypeSymbol (memberTypes, memberNames, memberLocations, memberIsReadOnly)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonCreateAnonymousTypeSymbol(System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ITypeSymbol ^&gt; memberTypes, System::Collections::Immutable::ImmutableArray&lt;System::String ^&gt; memberNames, System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::Location ^&gt; memberLocations, System::Collections::Immutable::ImmutableArray&lt;bool&gt; memberIsReadOnly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberTypes" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt;" />
        <Parameter Name="memberNames" Type="System.Collections.Immutable.ImmutableArray&lt;System.String&gt;" />
        <Parameter Name="memberLocations" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt;" />
        <Parameter Name="memberIsReadOnly" Type="System.Collections.Immutable.ImmutableArray&lt;System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="memberTypes">To be added.</param>
        <param name="memberNames">To be added.</param>
        <param name="memberLocations">To be added.</param>
        <param name="memberIsReadOnly">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonCreateArrayTypeSymbol">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.IArrayTypeSymbol CommonCreateArrayTypeSymbol (Microsoft.CodeAnalysis.ITypeSymbol elementType, int rank);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.IArrayTypeSymbol CommonCreateArrayTypeSymbol(class Microsoft.CodeAnalysis.ITypeSymbol elementType, int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonCreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonCreateArrayTypeSymbol (elementType As ITypeSymbol, rank As Integer) As IArrayTypeSymbol" />
      <MemberSignature Language="F#" Value="override this.CommonCreateArrayTypeSymbol : Microsoft.CodeAnalysis.ITypeSymbol * int -&gt; Microsoft.CodeAnalysis.IArrayTypeSymbol" Usage="cSharpCompilation.CommonCreateArrayTypeSymbol (elementType, rank)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::IArrayTypeSymbol ^ CommonCreateArrayTypeSymbol(Microsoft::CodeAnalysis::ITypeSymbol ^ elementType, int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IArrayTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">To be added.</param>
        <param name="rank">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonCreateErrorNamespaceSymbol">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.INamespaceSymbol CommonCreateErrorNamespaceSymbol (Microsoft.CodeAnalysis.INamespaceSymbol container, string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.INamespaceSymbol CommonCreateErrorNamespaceSymbol(class Microsoft.CodeAnalysis.INamespaceSymbol container, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonCreateErrorNamespaceSymbol(Microsoft.CodeAnalysis.INamespaceSymbol,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonCreateErrorNamespaceSymbol (container As INamespaceSymbol, name As String) As INamespaceSymbol" />
      <MemberSignature Language="F#" Value="override this.CommonCreateErrorNamespaceSymbol : Microsoft.CodeAnalysis.INamespaceSymbol * string -&gt; Microsoft.CodeAnalysis.INamespaceSymbol" Usage="cSharpCompilation.CommonCreateErrorNamespaceSymbol (container, name)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::INamespaceSymbol ^ CommonCreateErrorNamespaceSymbol(Microsoft::CodeAnalysis::INamespaceSymbol ^ container, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="Microsoft.CodeAnalysis.INamespaceSymbol" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="container">To be added.</param>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonCreateErrorTypeSymbol">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateErrorTypeSymbol (Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name, int arity);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateErrorTypeSymbol(class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name, int32 arity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonCreateErrorTypeSymbol(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonCreateErrorTypeSymbol (container As INamespaceOrTypeSymbol, name As String, arity As Integer) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="override this.CommonCreateErrorTypeSymbol : Microsoft.CodeAnalysis.INamespaceOrTypeSymbol * string * int -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="cSharpCompilation.CommonCreateErrorTypeSymbol (container, name, arity)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonCreateErrorTypeSymbol(Microsoft::CodeAnalysis::INamespaceOrTypeSymbol ^ container, System::String ^ name, int arity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="Microsoft.CodeAnalysis.INamespaceOrTypeSymbol" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="arity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="container">To be added.</param>
        <param name="name">To be added.</param>
        <param name="arity">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonCreatePointerTypeSymbol">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.IPointerTypeSymbol CommonCreatePointerTypeSymbol (Microsoft.CodeAnalysis.ITypeSymbol elementType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.IPointerTypeSymbol CommonCreatePointerTypeSymbol(class Microsoft.CodeAnalysis.ITypeSymbol elementType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonCreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonCreatePointerTypeSymbol (elementType As ITypeSymbol) As IPointerTypeSymbol" />
      <MemberSignature Language="F#" Value="override this.CommonCreatePointerTypeSymbol : Microsoft.CodeAnalysis.ITypeSymbol -&gt; Microsoft.CodeAnalysis.IPointerTypeSymbol" Usage="cSharpCompilation.CommonCreatePointerTypeSymbol elementType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::IPointerTypeSymbol ^ CommonCreatePointerTypeSymbol(Microsoft::CodeAnalysis::ITypeSymbol ^ elementType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IPointerTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
      </Parameters>
      <Docs>
        <param name="elementType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonCreateTupleTypeSymbol">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateTupleTypeSymbol (Microsoft.CodeAnalysis.INamedTypeSymbol underlyingType, System.Collections.Immutable.ImmutableArray&lt;string&gt; elementNames, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; elementLocations);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateTupleTypeSymbol(class Microsoft.CodeAnalysis.INamedTypeSymbol underlyingType, valuetype System.Collections.Immutable.ImmutableArray`1&lt;string&gt; elementNames, valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Location&gt; elementLocations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonCreateTupleTypeSymbol(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonCreateTupleTypeSymbol (underlyingType As INamedTypeSymbol, elementNames As ImmutableArray(Of String), elementLocations As ImmutableArray(Of Location)) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="override this.CommonCreateTupleTypeSymbol : Microsoft.CodeAnalysis.INamedTypeSymbol * System.Collections.Immutable.ImmutableArray&lt;string&gt; * System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="cSharpCompilation.CommonCreateTupleTypeSymbol (underlyingType, elementNames, elementLocations)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonCreateTupleTypeSymbol(Microsoft::CodeAnalysis::INamedTypeSymbol ^ underlyingType, System::Collections::Immutable::ImmutableArray&lt;System::String ^&gt; elementNames, System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::Location ^&gt; elementLocations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="underlyingType" Type="Microsoft.CodeAnalysis.INamedTypeSymbol" />
        <Parameter Name="elementNames" Type="System.Collections.Immutable.ImmutableArray&lt;System.String&gt;" />
        <Parameter Name="elementLocations" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt;" />
      </Parameters>
      <Docs>
        <param name="underlyingType">To be added.</param>
        <param name="elementNames">To be added.</param>
        <param name="elementLocations">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonCreateTupleTypeSymbol">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateTupleTypeSymbol (System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; elementTypes, System.Collections.Immutable.ImmutableArray&lt;string&gt; elementNames, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; elementLocations);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateTupleTypeSymbol(valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ITypeSymbol&gt; elementTypes, valuetype System.Collections.Immutable.ImmutableArray`1&lt;string&gt; elementNames, valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Location&gt; elementLocations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonCreateTupleTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonCreateTupleTypeSymbol (elementTypes As ImmutableArray(Of ITypeSymbol), elementNames As ImmutableArray(Of String), elementLocations As ImmutableArray(Of Location)) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="override this.CommonCreateTupleTypeSymbol : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt; * System.Collections.Immutable.ImmutableArray&lt;string&gt; * System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt; -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="cSharpCompilation.CommonCreateTupleTypeSymbol (elementTypes, elementNames, elementLocations)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonCreateTupleTypeSymbol(System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ITypeSymbol ^&gt; elementTypes, System::Collections::Immutable::ImmutableArray&lt;System::String ^&gt; elementNames, System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::Location ^&gt; elementLocations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementTypes" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ITypeSymbol&gt;" />
        <Parameter Name="elementNames" Type="System.Collections.Immutable.ImmutableArray&lt;System.String&gt;" />
        <Parameter Name="elementLocations" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Location&gt;" />
      </Parameters>
      <Docs>
        <param name="elementTypes">To be added.</param>
        <param name="elementNames">To be added.</param>
        <param name="elementLocations">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonDynamicType">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.ITypeSymbol CommonDynamicType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.ITypeSymbol CommonDynamicType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonDynamicType" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CommonDynamicType As ITypeSymbol" />
      <MemberSignature Language="F#" Value="member this.CommonDynamicType : Microsoft.CodeAnalysis.ITypeSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonDynamicType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property Microsoft::CodeAnalysis::ITypeSymbol ^ CommonDynamicType { Microsoft::CodeAnalysis::ITypeSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ITypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonGetAssemblyOrModuleSymbol">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.ISymbol CommonGetAssemblyOrModuleSymbol (Microsoft.CodeAnalysis.MetadataReference reference);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.ISymbol CommonGetAssemblyOrModuleSymbol(class Microsoft.CodeAnalysis.MetadataReference reference) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonGetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonGetAssemblyOrModuleSymbol (reference As MetadataReference) As ISymbol" />
      <MemberSignature Language="F#" Value="override this.CommonGetAssemblyOrModuleSymbol : Microsoft.CodeAnalysis.MetadataReference -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="cSharpCompilation.CommonGetAssemblyOrModuleSymbol reference" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::ISymbol ^ CommonGetAssemblyOrModuleSymbol(Microsoft::CodeAnalysis::MetadataReference ^ reference);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reference" Type="Microsoft.CodeAnalysis.MetadataReference" />
      </Parameters>
      <Docs>
        <param name="reference">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonGetCompilationNamespace">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.INamespaceSymbol CommonGetCompilationNamespace (Microsoft.CodeAnalysis.INamespaceSymbol namespaceSymbol);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.INamespaceSymbol CommonGetCompilationNamespace(class Microsoft.CodeAnalysis.INamespaceSymbol namespaceSymbol) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonGetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonGetCompilationNamespace (namespaceSymbol As INamespaceSymbol) As INamespaceSymbol" />
      <MemberSignature Language="F#" Value="override this.CommonGetCompilationNamespace : Microsoft.CodeAnalysis.INamespaceSymbol -&gt; Microsoft.CodeAnalysis.INamespaceSymbol" Usage="cSharpCompilation.CommonGetCompilationNamespace namespaceSymbol" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::INamespaceSymbol ^ CommonGetCompilationNamespace(Microsoft::CodeAnalysis::INamespaceSymbol ^ namespaceSymbol);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceSymbol" Type="Microsoft.CodeAnalysis.INamespaceSymbol" />
      </Parameters>
      <Docs>
        <param name="namespaceSymbol">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonGetEntryPoint">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.IMethodSymbol CommonGetEntryPoint (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.IMethodSymbol CommonGetEntryPoint(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonGetEntryPoint(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.CommonGetEntryPoint : System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IMethodSymbol" Usage="cSharpCompilation.CommonGetEntryPoint cancellationToken" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::IMethodSymbol ^ CommonGetEntryPoint(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonGetSemanticModel">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.SemanticModel CommonGetSemanticModel (Microsoft.CodeAnalysis.SyntaxTree syntaxTree, bool ignoreAccessibility);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.SemanticModel CommonGetSemanticModel(class Microsoft.CodeAnalysis.SyntaxTree syntaxTree, bool ignoreAccessibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonGetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)" />
      <MemberSignature Language="F#" Value="override this.CommonGetSemanticModel : Microsoft.CodeAnalysis.SyntaxTree * bool -&gt; Microsoft.CodeAnalysis.SemanticModel" Usage="cSharpCompilation.CommonGetSemanticModel (syntaxTree, ignoreAccessibility)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::SemanticModel ^ CommonGetSemanticModel(Microsoft::CodeAnalysis::SyntaxTree ^ syntaxTree, bool ignoreAccessibility);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SemanticModel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="syntaxTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
        <Parameter Name="ignoreAccessibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="syntaxTree">To be added.</param>
        <param name="ignoreAccessibility">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonGetSpecialType">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonGetSpecialType (Microsoft.CodeAnalysis.SpecialType specialType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonGetSpecialType(valuetype Microsoft.CodeAnalysis.SpecialType specialType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonGetSpecialType(Microsoft.CodeAnalysis.SpecialType)" />
      <MemberSignature Language="F#" Value="override this.CommonGetSpecialType : Microsoft.CodeAnalysis.SpecialType -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="cSharpCompilation.CommonGetSpecialType specialType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonGetSpecialType(Microsoft::CodeAnalysis::SpecialType specialType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="specialType" Type="Microsoft.CodeAnalysis.SpecialType" />
      </Parameters>
      <Docs>
        <param name="specialType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonGetTypeByMetadataName">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonGetTypeByMetadataName (string metadataName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonGetTypeByMetadataName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonGetTypeByMetadataName (metadataName As String) As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="override this.CommonGetTypeByMetadataName : string -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="cSharpCompilation.CommonGetTypeByMetadataName metadataName" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonGetTypeByMetadataName(System::String ^ metadataName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="metadataName">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonGlobalNamespace">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.INamespaceSymbol CommonGlobalNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamespaceSymbol CommonGlobalNamespace" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonGlobalNamespace" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CommonGlobalNamespace As INamespaceSymbol" />
      <MemberSignature Language="F#" Value="member this.CommonGlobalNamespace : Microsoft.CodeAnalysis.INamespaceSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonGlobalNamespace" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property Microsoft::CodeAnalysis::INamespaceSymbol ^ CommonGlobalNamespace { Microsoft::CodeAnalysis::INamespaceSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonObjectType">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonObjectType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonObjectType" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CommonObjectType As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.CommonObjectType : Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonObjectType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonObjectType { Microsoft::CodeAnalysis::INamedTypeSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonOptions">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.CompilationOptions CommonOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.CompilationOptions CommonOptions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonOptions" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CommonOptions As CompilationOptions" />
      <MemberSignature Language="F#" Value="member this.CommonOptions : Microsoft.CodeAnalysis.CompilationOptions" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonOptions" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property Microsoft::CodeAnalysis::CompilationOptions ^ CommonOptions { Microsoft::CodeAnalysis::CompilationOptions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CompilationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonRemoveAllSyntaxTrees">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.Compilation CommonRemoveAllSyntaxTrees ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.Compilation CommonRemoveAllSyntaxTrees() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonRemoveAllSyntaxTrees" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonRemoveAllSyntaxTrees () As Compilation" />
      <MemberSignature Language="F#" Value="override this.CommonRemoveAllSyntaxTrees : unit -&gt; Microsoft.CodeAnalysis.Compilation" Usage="cSharpCompilation.CommonRemoveAllSyntaxTrees " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::Compilation ^ CommonRemoveAllSyntaxTrees();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonRemoveSyntaxTrees">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.Compilation CommonRemoveSyntaxTrees (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; trees);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.Compilation CommonRemoveSyntaxTrees(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxTree&gt; trees) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonRemoveSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonRemoveSyntaxTrees (trees As IEnumerable(Of SyntaxTree)) As Compilation" />
      <MemberSignature Language="F#" Value="override this.CommonRemoveSyntaxTrees : seq&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; -&gt; Microsoft.CodeAnalysis.Compilation" Usage="cSharpCompilation.CommonRemoveSyntaxTrees trees" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::Compilation ^ CommonRemoveSyntaxTrees(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ trees);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trees" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;" />
      </Parameters>
      <Docs>
        <param name="trees">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonReplaceSyntaxTree">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.Compilation CommonReplaceSyntaxTree (Microsoft.CodeAnalysis.SyntaxTree oldTree, Microsoft.CodeAnalysis.SyntaxTree newTree);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.Compilation CommonReplaceSyntaxTree(class Microsoft.CodeAnalysis.SyntaxTree oldTree, class Microsoft.CodeAnalysis.SyntaxTree newTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonReplaceSyntaxTree (oldTree As SyntaxTree, newTree As SyntaxTree) As Compilation" />
      <MemberSignature Language="F#" Value="override this.CommonReplaceSyntaxTree : Microsoft.CodeAnalysis.SyntaxTree * Microsoft.CodeAnalysis.SyntaxTree -&gt; Microsoft.CodeAnalysis.Compilation" Usage="cSharpCompilation.CommonReplaceSyntaxTree (oldTree, newTree)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::Compilation ^ CommonReplaceSyntaxTree(Microsoft::CodeAnalysis::SyntaxTree ^ oldTree, Microsoft::CodeAnalysis::SyntaxTree ^ newTree);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
        <Parameter Name="newTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
      </Parameters>
      <Docs>
        <param name="oldTree">To be added.</param>
        <param name="newTree">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonScriptClass">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonScriptClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.INamedTypeSymbol CommonScriptClass" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonScriptClass" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CommonScriptClass As INamedTypeSymbol" />
      <MemberSignature Language="F#" Value="member this.CommonScriptClass : Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonScriptClass" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property Microsoft::CodeAnalysis::INamedTypeSymbol ^ CommonScriptClass { Microsoft::CodeAnalysis::INamedTypeSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonSourceModule">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.IModuleSymbol CommonSourceModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.IModuleSymbol CommonSourceModule" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonSourceModule" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CommonSourceModule As IModuleSymbol" />
      <MemberSignature Language="F#" Value="member this.CommonSourceModule : Microsoft.CodeAnalysis.IModuleSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonSourceModule" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property Microsoft::CodeAnalysis::IModuleSymbol ^ CommonSourceModule { Microsoft::CodeAnalysis::IModuleSymbol ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.IModuleSymbol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonSyntaxTrees">
      <MemberSignature Language="C#" Value="protected override System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; CommonSyntaxTrees { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxTree&gt; CommonSyntaxTrees" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonSyntaxTrees" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CommonSyntaxTrees As IEnumerable(Of SyntaxTree)" />
      <MemberSignature Language="F#" Value="member this.CommonSyntaxTrees : seq&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonSyntaxTrees" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ CommonSyntaxTrees { System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonWithAssemblyName">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.Compilation CommonWithAssemblyName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.Compilation CommonWithAssemblyName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonWithAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonWithAssemblyName (assemblyName As String) As Compilation" />
      <MemberSignature Language="F#" Value="override this.CommonWithAssemblyName : string -&gt; Microsoft.CodeAnalysis.Compilation" Usage="cSharpCompilation.CommonWithAssemblyName assemblyName" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::Compilation ^ CommonWithAssemblyName(System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonWithOptions">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.Compilation CommonWithOptions (Microsoft.CodeAnalysis.CompilationOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.Compilation CommonWithOptions(class Microsoft.CodeAnalysis.CompilationOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonWithOptions(Microsoft.CodeAnalysis.CompilationOptions)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonWithOptions (options As CompilationOptions) As Compilation" />
      <MemberSignature Language="F#" Value="override this.CommonWithOptions : Microsoft.CodeAnalysis.CompilationOptions -&gt; Microsoft.CodeAnalysis.Compilation" Usage="cSharpCompilation.CommonWithOptions options" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::Compilation ^ CommonWithOptions(Microsoft::CodeAnalysis::CompilationOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="Microsoft.CodeAnalysis.CompilationOptions" />
      </Parameters>
      <Docs>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonWithReferences">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.Compilation CommonWithReferences (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; newReferences);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.Compilation CommonWithReferences(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.MetadataReference&gt; newReferences) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonWithReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonWithReferences (newReferences As IEnumerable(Of MetadataReference)) As Compilation" />
      <MemberSignature Language="F#" Value="override this.CommonWithReferences : seq&lt;Microsoft.CodeAnalysis.MetadataReference&gt; -&gt; Microsoft.CodeAnalysis.Compilation" Usage="cSharpCompilation.CommonWithReferences newReferences" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::Compilation ^ CommonWithReferences(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ newReferences);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newReferences" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt;" />
      </Parameters>
      <Docs>
        <param name="newReferences">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommonWithScriptCompilationInfo">
      <MemberSignature Language="C#" Value="protected override Microsoft.CodeAnalysis.Compilation CommonWithScriptCompilationInfo (Microsoft.CodeAnalysis.ScriptCompilationInfo info);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class Microsoft.CodeAnalysis.Compilation CommonWithScriptCompilationInfo(class Microsoft.CodeAnalysis.ScriptCompilationInfo info) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CommonWithScriptCompilationInfo(Microsoft.CodeAnalysis.ScriptCompilationInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CommonWithScriptCompilationInfo (info As ScriptCompilationInfo) As Compilation" />
      <MemberSignature Language="F#" Value="override this.CommonWithScriptCompilationInfo : Microsoft.CodeAnalysis.ScriptCompilationInfo -&gt; Microsoft.CodeAnalysis.Compilation" Usage="cSharpCompilation.CommonWithScriptCompilationInfo info" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Microsoft::CodeAnalysis::Compilation ^ CommonWithScriptCompilationInfo(Microsoft::CodeAnalysis::ScriptCompilationInfo ^ info);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Compilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="Microsoft.CodeAnalysis.ScriptCompilationInfo" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsSymbolsWithName">
      <MemberSignature Language="C#" Value="public override bool ContainsSymbolsWithName (Func&lt;string,bool&gt; predicate, Microsoft.CodeAnalysis.SymbolFilter filter = Microsoft.CodeAnalysis.SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ContainsSymbolsWithName(class System.Func`2&lt;string, bool&gt; predicate, valuetype Microsoft.CodeAnalysis.SymbolFilter filter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ContainsSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ContainsSymbolsWithName : Func&lt;string, bool&gt; * Microsoft.CodeAnalysis.SymbolFilter * System.Threading.CancellationToken -&gt; bool" Usage="cSharpCompilation.ContainsSymbolsWithName (predicate, filter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="predicate" Type="System.Func&lt;System.String,System.Boolean&gt;" />
        <Parameter Name="filter" Type="Microsoft.CodeAnalysis.SymbolFilter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="predicate">To be added.</param>
        <param name="filter">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Return true if there is a source declaration symbol name that meets given predicate.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsSymbolsWithName">
      <MemberSignature Language="C#" Value="public override bool ContainsSymbolsWithName (string name, Microsoft.CodeAnalysis.SymbolFilter filter = Microsoft.CodeAnalysis.SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ContainsSymbolsWithName(string name, valuetype Microsoft.CodeAnalysis.SymbolFilter filter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ContainsSymbolsWithName(System.String,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ContainsSymbolsWithName : string * Microsoft.CodeAnalysis.SymbolFilter * System.Threading.CancellationToken -&gt; bool" Usage="cSharpCompilation.ContainsSymbolsWithName (name, filter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="filter" Type="Microsoft.CodeAnalysis.SymbolFilter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="filter">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Return true if there is a source declaration symbol name that matches the provided name.
            This will be faster than <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ContainsSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)" />
            when predicate is just a simple string check.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsSyntaxTree">
      <MemberSignature Language="C#" Value="public bool ContainsSyntaxTree (Microsoft.CodeAnalysis.SyntaxTree syntaxTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsSyntaxTree(class Microsoft.CodeAnalysis.SyntaxTree syntaxTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree)" />
      <MemberSignature Language="F#" Value="override this.ContainsSyntaxTree : Microsoft.CodeAnalysis.SyntaxTree -&gt; bool" Usage="cSharpCompilation.ContainsSyntaxTree syntaxTree" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsSyntaxTree(Microsoft::CodeAnalysis::SyntaxTree ^ syntaxTree);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="syntaxTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
      </Parameters>
      <Docs>
        <param name="syntaxTree">To be added.</param>
        <summary>
            Returns true if this compilation contains the specified tree.  False otherwise.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.CSharpCompilation Create (string assemblyName, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; syntaxTrees = null, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; references = null, Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions options = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.CSharpCompilation Create(string assemblyName, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxTree&gt; syntaxTrees, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.MetadataReference&gt; references, class Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference},Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (assemblyName As String, Optional syntaxTrees As IEnumerable(Of SyntaxTree) = null, Optional references As IEnumerable(Of MetadataReference) = null, Optional options As CSharpCompilationOptions = null) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="static member Create : string * seq&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; * seq&lt;Microsoft.CodeAnalysis.MetadataReference&gt; * Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create (assemblyName, syntaxTrees, references, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="syntaxTrees" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;" />
        <Parameter Name="references" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt;" />
        <Parameter Name="options" Type="Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Simple assembly name.</param>
        <param name="syntaxTrees">The syntax trees with the source code for the new compilation.</param>
        <param name="references">The references for the new compilation.</param>
        <param name="options">The compiler options to use.</param>
        <summary>
            Creates a new compilation from scratch. Methods such as AddSyntaxTrees or AddReferences
            on the returned object will allow to continue building up the Compilation incrementally.
            </summary>
        <returns>A new compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateScriptCompilation">
      <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.CSharpCompilation CreateScriptCompilation (string assemblyName, Microsoft.CodeAnalysis.SyntaxTree syntaxTree = null, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; references = null, Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions options = null, Microsoft.CodeAnalysis.CSharp.CSharpCompilation previousScriptCompilation = null, Type returnType = null, Type globalsType = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.CSharpCompilation CreateScriptCompilation(string assemblyName, class Microsoft.CodeAnalysis.SyntaxTree syntaxTree, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.MetadataReference&gt; references, class Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions options, class Microsoft.CodeAnalysis.CSharp.CSharpCompilation previousScriptCompilation, class System.Type returnType, class System.Type globalsType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CreateScriptCompilation(System.String,Microsoft.CodeAnalysis.SyntaxTree,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference},Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.Type,System.Type)" />
      <MemberSignature Language="F#" Value="static member CreateScriptCompilation : string * Microsoft.CodeAnalysis.SyntaxTree * seq&lt;Microsoft.CodeAnalysis.MetadataReference&gt; * Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions * Microsoft.CodeAnalysis.CSharp.CSharpCompilation * Type * Type -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CreateScriptCompilation (assemblyName, syntaxTree, references, options, previousScriptCompilation, returnType, globalsType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="syntaxTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
        <Parameter Name="references" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt;" />
        <Parameter Name="options" Type="Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions" />
        <Parameter Name="previousScriptCompilation" Type="Microsoft.CodeAnalysis.CSharp.CSharpCompilation" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="globalsType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="assemblyName">To be added.</param>
        <param name="syntaxTree">To be added.</param>
        <param name="references">To be added.</param>
        <param name="options">To be added.</param>
        <param name="previousScriptCompilation">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="globalsType">To be added.</param>
        <summary>
            Creates a new compilation that can be used in scripting.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectiveReferences">
      <MemberSignature Language="C#" Value="public override System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.MetadataReference&gt; DirectiveReferences { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.MetadataReference&gt; DirectiveReferences" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.DirectiveReferences" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DirectiveReferences As ImmutableArray(Of MetadataReference)" />
      <MemberSignature Language="F#" Value="member this.DirectiveReferences : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.MetadataReference&gt;" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.DirectiveReferences" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; DirectiveReferences { System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.MetadataReference&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeclarationDiagnostics">
      <MemberSignature Language="C#" Value="public override System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetDeclarationDiagnostics (System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetDeclarationDiagnostics(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDeclarationDiagnostics(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.GetDeclarationDiagnostics : System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="cSharpCompilation.GetDeclarationDiagnostics cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the diagnostics produced during symbol declaration headers.  There are no diagnostics for accessor or
            method bodies, for example.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDiagnostics">
      <MemberSignature Language="C#" Value="public override System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics (System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.GetDiagnostics : System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="cSharpCompilation.GetDiagnostics cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the all the diagnostics for the compilation, including syntax, declaration, and binding. Does not
            include any diagnostics that might be produced during emit.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectiveReference">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.MetadataReference GetDirectiveReference (Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax directive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.MetadataReference GetDirectiveReference(class Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDirectiveReference(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectiveReference (directive As ReferenceDirectiveTriviaSyntax) As MetadataReference" />
      <MemberSignature Language="F#" Value="member this.GetDirectiveReference : Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax -&gt; Microsoft.CodeAnalysis.MetadataReference" Usage="cSharpCompilation.GetDirectiveReference directive" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::MetadataReference ^ GetDirectiveReference(Microsoft::CodeAnalysis::CSharp::Syntax::ReferenceDirectiveTriviaSyntax ^ directive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.MetadataReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax" />
      </Parameters>
      <Docs>
        <param name="directive">#r directive.</param>
        <summary>
            Returns a metadata reference that a given #r resolves to.
            </summary>
        <returns>Metadata reference the specified directive resolves to, or null if the <paramref name="directive" /> doesn't match any #r directive in the compilation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadataReference">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.MetadataReference GetMetadataReference (Microsoft.CodeAnalysis.IAssemblySymbol assemblySymbol);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.MetadataReference GetMetadataReference(class Microsoft.CodeAnalysis.IAssemblySymbol assemblySymbol) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetMetadataReference(Microsoft.CodeAnalysis.IAssemblySymbol)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadataReference (assemblySymbol As IAssemblySymbol) As MetadataReference" />
      <MemberSignature Language="F#" Value="override this.GetMetadataReference : Microsoft.CodeAnalysis.IAssemblySymbol -&gt; Microsoft.CodeAnalysis.MetadataReference" Usage="cSharpCompilation.GetMetadataReference assemblySymbol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::MetadataReference ^ GetMetadataReference(Microsoft::CodeAnalysis::IAssemblySymbol ^ assemblySymbol);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.MetadataReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblySymbol" Type="Microsoft.CodeAnalysis.IAssemblySymbol" />
      </Parameters>
      <Docs>
        <param name="assemblySymbol">To be added.</param>
        <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.MetadataReference" /> that corresponds to the assembly symbol.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBodyDiagnostics">
      <MemberSignature Language="C#" Value="public override System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetMethodBodyDiagnostics (System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetMethodBodyDiagnostics(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetMethodBodyDiagnostics(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.GetMethodBodyDiagnostics : System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="cSharpCompilation.GetMethodBodyDiagnostics cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the diagnostics produced during the analysis of method bodies and field initializers.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParseDiagnostics">
      <MemberSignature Language="C#" Value="public override System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetParseDiagnostics (System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetParseDiagnostics(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetParseDiagnostics(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.GetParseDiagnostics : System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="cSharpCompilation.GetParseDiagnostics cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the diagnostics produced during the parsing stage of a compilation. There are no diagnostics for declarations or accessor or
            method bodies, for example.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSemanticModel">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SemanticModel GetSemanticModel (Microsoft.CodeAnalysis.SyntaxTree syntaxTree, bool ignoreAccessibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.SemanticModel GetSemanticModel(class Microsoft.CodeAnalysis.SyntaxTree syntaxTree, bool ignoreAccessibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)" />
      <MemberSignature Language="F#" Value="override this.GetSemanticModel : Microsoft.CodeAnalysis.SyntaxTree * bool -&gt; Microsoft.CodeAnalysis.SemanticModel" Usage="cSharpCompilation.GetSemanticModel (syntaxTree, ignoreAccessibility)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SemanticModel ^ GetSemanticModel(Microsoft::CodeAnalysis::SyntaxTree ^ syntaxTree, bool ignoreAccessibility);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SemanticModel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="syntaxTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
        <Parameter Name="ignoreAccessibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="syntaxTree">To be added.</param>
        <param name="ignoreAccessibility">To be added.</param>
        <summary>
            Gets a new SyntaxTreeSemanticModel for the specified syntax tree.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolsWithName">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetSymbolsWithName (Func&lt;string,bool&gt; predicate, Microsoft.CodeAnalysis.SymbolFilter filter = Microsoft.CodeAnalysis.SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetSymbolsWithName(class System.Func`2&lt;string, bool&gt; predicate, valuetype Microsoft.CodeAnalysis.SymbolFilter filter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.GetSymbolsWithName : Func&lt;string, bool&gt; * Microsoft.CodeAnalysis.SymbolFilter * System.Threading.CancellationToken -&gt; seq&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="cSharpCompilation.GetSymbolsWithName (predicate, filter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="predicate" Type="System.Func&lt;System.String,System.Boolean&gt;" />
        <Parameter Name="filter" Type="Microsoft.CodeAnalysis.SymbolFilter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="predicate">To be added.</param>
        <param name="filter">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Return source declaration symbols whose name meets given predicate.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSymbolsWithName">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetSymbolsWithName (string name, Microsoft.CodeAnalysis.SymbolFilter filter = Microsoft.CodeAnalysis.SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetSymbolsWithName(string name, valuetype Microsoft.CodeAnalysis.SymbolFilter filter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSymbolsWithName(System.String,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.GetSymbolsWithName : string * Microsoft.CodeAnalysis.SymbolFilter * System.Threading.CancellationToken -&gt; seq&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="cSharpCompilation.GetSymbolsWithName (name, filter, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="filter" Type="Microsoft.CodeAnalysis.SymbolFilter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="filter">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Return source declaration symbols whose name matches the provided name.  This will be
            faster than <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)" /> when predicate is just a simple string check.  <paramref name="name" /> is case sensitive.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCaseSensitive">
      <MemberSignature Language="C#" Value="public override bool IsCaseSensitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCaseSensitive" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.IsCaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsCaseSensitive As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsCaseSensitive : bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.IsCaseSensitive" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCaseSensitive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public override string Language { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Language" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Language" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Language As String" />
      <MemberSignature Language="F#" Value="member this.Language : string" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Language" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Language { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageVersion">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.LanguageVersion LanguageVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.CSharp.LanguageVersion LanguageVersion" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.LanguageVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LanguageVersion As LanguageVersion" />
      <MemberSignature Language="F#" Value="member this.LanguageVersion : Microsoft.CodeAnalysis.CSharp.LanguageVersion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.LanguageVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::CSharp::LanguageVersion LanguageVersion { Microsoft::CodeAnalysis::CSharp::LanguageVersion get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.LanguageVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The language version that was used to parse the syntax trees of this compilation.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions Options" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As CSharpCompilationOptions" />
      <MemberSignature Language="F#" Value="member this.Options : Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Options" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::CSharp::CSharpCompilationOptions ^ Options { Microsoft::CodeAnalysis::CSharp::CSharpCompilationOptions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The options the compilation was created with.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferencedAssemblyNames">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.AssemblyIdentity&gt; ReferencedAssemblyNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.AssemblyIdentity&gt; ReferencedAssemblyNames" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferencedAssemblyNames" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReferencedAssemblyNames As IEnumerable(Of AssemblyIdentity)" />
      <MemberSignature Language="F#" Value="member this.ReferencedAssemblyNames : seq&lt;Microsoft.CodeAnalysis.AssemblyIdentity&gt;" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferencedAssemblyNames" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::AssemblyIdentity ^&gt; ^ ReferencedAssemblyNames { System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::AssemblyIdentity ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.AssemblyIdentity&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAllReferences">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveAllReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveAllReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveAllReferences" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAllReferences () As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.RemoveAllReferences : unit -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.RemoveAllReferences " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ RemoveAllReferences();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Creates a new compilation without any metadata references
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAllSyntaxTrees">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveAllSyntaxTrees ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveAllSyntaxTrees() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveAllSyntaxTrees" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAllSyntaxTrees () As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.RemoveAllSyntaxTrees : unit -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.RemoveAllSyntaxTrees " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ RemoveAllSyntaxTrees();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Creates a new compilation without any syntax trees. Preserves metadata info
            from this compilation for use with trees added later.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveReferences">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveReferences (params Microsoft.CodeAnalysis.MetadataReference[] references);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveReferences(class Microsoft.CodeAnalysis.MetadataReference[] references) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveReferences(Microsoft.CodeAnalysis.MetadataReference[])" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveReferences (ParamArray references As MetadataReference()) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.RemoveReferences : Microsoft.CodeAnalysis.MetadataReference[] -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.RemoveReferences references" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ RemoveReferences(... cli::array &lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ references);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="references" Type="Microsoft.CodeAnalysis.MetadataReference[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="references">To be added.</param>
        <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveReferences">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveReferences (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; references);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveReferences(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.MetadataReference&gt; references) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveReferences (references As IEnumerable(Of MetadataReference)) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.RemoveReferences : seq&lt;Microsoft.CodeAnalysis.MetadataReference&gt; -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.RemoveReferences references" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ RemoveReferences(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ references);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="references" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt;" />
      </Parameters>
      <Docs>
        <param name="references">To be added.</param>
        <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveSyntaxTrees">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveSyntaxTrees (params Microsoft.CodeAnalysis.SyntaxTree[] trees);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveSyntaxTrees(class Microsoft.CodeAnalysis.SyntaxTree[] trees) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveSyntaxTrees (ParamArray trees As SyntaxTree()) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.RemoveSyntaxTrees : Microsoft.CodeAnalysis.SyntaxTree[] -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.RemoveSyntaxTrees trees" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ RemoveSyntaxTrees(... cli::array &lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ trees);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trees" Type="Microsoft.CodeAnalysis.SyntaxTree[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trees">To be added.</param>
        <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveSyntaxTrees">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveSyntaxTrees (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; trees);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveSyntaxTrees(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxTree&gt; trees) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveSyntaxTrees (trees As IEnumerable(Of SyntaxTree)) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.RemoveSyntaxTrees : seq&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.RemoveSyntaxTrees trees" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ RemoveSyntaxTrees(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; ^ trees);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trees" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;" />
      </Parameters>
      <Docs>
        <param name="trees">To be added.</param>
        <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceReference">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation ReplaceReference (Microsoft.CodeAnalysis.MetadataReference oldReference, Microsoft.CodeAnalysis.MetadataReference newReference);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation ReplaceReference(class Microsoft.CodeAnalysis.MetadataReference oldReference, class Microsoft.CodeAnalysis.MetadataReference newReference) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReplaceReference(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReplaceReference (oldReference As MetadataReference, newReference As MetadataReference) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.ReplaceReference : Microsoft.CodeAnalysis.MetadataReference * Microsoft.CodeAnalysis.MetadataReference -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.ReplaceReference (oldReference, newReference)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ ReplaceReference(Microsoft::CodeAnalysis::MetadataReference ^ oldReference, Microsoft::CodeAnalysis::MetadataReference ^ newReference);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldReference" Type="Microsoft.CodeAnalysis.MetadataReference" />
        <Parameter Name="newReference" Type="Microsoft.CodeAnalysis.MetadataReference" />
      </Parameters>
      <Docs>
        <param name="oldReference">To be added.</param>
        <param name="newReference">To be added.</param>
        <summary>
            Creates a new compilation with an old metadata reference replaced with a new metadata reference.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceSyntaxTree">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation ReplaceSyntaxTree (Microsoft.CodeAnalysis.SyntaxTree oldTree, Microsoft.CodeAnalysis.SyntaxTree newTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation ReplaceSyntaxTree(class Microsoft.CodeAnalysis.SyntaxTree oldTree, class Microsoft.CodeAnalysis.SyntaxTree newTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReplaceSyntaxTree (oldTree As SyntaxTree, newTree As SyntaxTree) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.ReplaceSyntaxTree : Microsoft.CodeAnalysis.SyntaxTree * Microsoft.CodeAnalysis.SyntaxTree -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.ReplaceSyntaxTree (oldTree, newTree)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ ReplaceSyntaxTree(Microsoft::CodeAnalysis::SyntaxTree ^ oldTree, Microsoft::CodeAnalysis::SyntaxTree ^ newTree);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
        <Parameter Name="newTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
      </Parameters>
      <Docs>
        <param name="oldTree">To be added.</param>
        <param name="newTree">To be added.</param>
        <summary>
            Creates a new compilation without the old tree but with the new tree.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptCompilationInfo">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo ScriptCompilationInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo ScriptCompilationInfo" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ScriptCompilationInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScriptCompilationInfo As CSharpScriptCompilationInfo" />
      <MemberSignature Language="F#" Value="member this.ScriptCompilationInfo : Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ScriptCompilationInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::CSharp::CSharpScriptCompilationInfo ^ ScriptCompilationInfo { Microsoft::CodeAnalysis::CSharp::CSharpScriptCompilationInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SyntaxTrees">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.SyntaxTree&gt; SyntaxTrees { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.SyntaxTree&gt; SyntaxTrees" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.SyntaxTrees" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyntaxTrees As ImmutableArray(Of SyntaxTree)" />
      <MemberSignature Language="F#" Value="member this.SyntaxTrees : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;" Usage="Microsoft.CodeAnalysis.CSharp.CSharpCompilation.SyntaxTrees" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; SyntaxTrees { System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::SyntaxTree ^&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.SyntaxTree&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The syntax trees (parsed from source code) that this compilation was created with.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToMetadataReference">
      <MemberSignature Language="C#" Value="public override Microsoft.CodeAnalysis.CompilationReference ToMetadataReference (System.Collections.Immutable.ImmutableArray&lt;string&gt; aliases = null, bool embedInteropTypes = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class Microsoft.CodeAnalysis.CompilationReference ToMetadataReference(valuetype System.Collections.Immutable.ImmutableArray`1&lt;string&gt; aliases, bool embedInteropTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ToMetadataReference(System.Collections.Immutable.ImmutableArray{System.String},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToMetadataReference (Optional aliases As ImmutableArray(Of String) = null, Optional embedInteropTypes As Boolean = false) As CompilationReference" />
      <MemberSignature Language="F#" Value="override this.ToMetadataReference : System.Collections.Immutable.ImmutableArray&lt;string&gt; * bool -&gt; Microsoft.CodeAnalysis.CompilationReference" Usage="cSharpCompilation.ToMetadataReference (aliases, embedInteropTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CompilationReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aliases" Type="System.Collections.Immutable.ImmutableArray&lt;System.String&gt;" />
        <Parameter Name="embedInteropTypes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="aliases">To be added.</param>
        <param name="embedInteropTypes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithAssemblyName">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithAssemblyName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithAssemblyName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WithAssemblyName (assemblyName As String) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.WithAssemblyName : string -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.WithAssemblyName assemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ WithAssemblyName(System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">To be added.</param>
        <summary>
            Creates a new compilation with the specified name.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithOptions">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithOptions (Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithOptions(class Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithOptions(Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function WithOptions (options As CSharpCompilationOptions) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.WithOptions : Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.WithOptions options" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ WithOptions(Microsoft::CodeAnalysis::CSharp::CSharpCompilationOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions" />
      </Parameters>
      <Docs>
        <param name="options">To be added.</param>
        <summary>
            Creates a new compilation with the specified compilation options.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithReferences">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithReferences (params Microsoft.CodeAnalysis.MetadataReference[] references);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithReferences(class Microsoft.CodeAnalysis.MetadataReference[] references) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithReferences(Microsoft.CodeAnalysis.MetadataReference[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WithReferences (ParamArray references As MetadataReference()) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.WithReferences : Microsoft.CodeAnalysis.MetadataReference[] -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.WithReferences references" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ WithReferences(... cli::array &lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ references);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="references" Type="Microsoft.CodeAnalysis.MetadataReference[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="references">To be added.</param>
        <summary>
            Creates a new compilation with the specified references.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithReferences">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithReferences (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt; references);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithReferences(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.MetadataReference&gt; references) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})" />
      <MemberSignature Language="VB.NET" Value="Public Function WithReferences (references As IEnumerable(Of MetadataReference)) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.WithReferences : seq&lt;Microsoft.CodeAnalysis.MetadataReference&gt; -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.WithReferences references" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ WithReferences(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::MetadataReference ^&gt; ^ references);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="references" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.MetadataReference&gt;" />
      </Parameters>
      <Docs>
        <param name="references">To be added.</param>
        <summary>
             Creates a new compilation with the specified references.
             </summary>
        <returns>To be added.</returns>
        <remarks>
             The new <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation" /> will query the given <see cref="T:Microsoft.CodeAnalysis.MetadataReference" /> for the underlying
             metadata as soon as the are needed.
            
             The new compilation uses whatever metadata is currently being provided by the <see cref="T:Microsoft.CodeAnalysis.MetadataReference" />.
             E.g. if the current compilation references a metadata file that has changed since the creation of the compilation
             the new compilation is going to use the updated version, while the current compilation will be using the previous (it doesn't change).
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="WithScriptCompilationInfo">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithScriptCompilationInfo (Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo info);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithScriptCompilationInfo(class Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo info) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithScriptCompilationInfo(Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function WithScriptCompilationInfo (info As CSharpScriptCompilationInfo) As CSharpCompilation" />
      <MemberSignature Language="F#" Value="override this.WithScriptCompilationInfo : Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo -&gt; Microsoft.CodeAnalysis.CSharp.CSharpCompilation" Usage="cSharpCompilation.WithScriptCompilationInfo info" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::CSharp::CSharpCompilation ^ WithScriptCompilationInfo(Microsoft::CodeAnalysis::CSharp::CSharpScriptCompilationInfo ^ info);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis.CSharp</AssemblyName>
        <AssemblyVersion>2.9.0.0</AssemblyVersion>
        <AssemblyVersion>3.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.CSharp.CSharpCompilation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <summary>
            Returns a new compilation with the given compilation set as the previous submission.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>