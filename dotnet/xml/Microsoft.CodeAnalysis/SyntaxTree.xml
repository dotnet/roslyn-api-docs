<Type Name="SyntaxTree" FullName="Microsoft.CodeAnalysis.SyntaxTree">
  <TypeSignature Language="C#" Value="public abstract class SyntaxTree" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SyntaxTree extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.SyntaxTree" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SyntaxTree" />
  <TypeSignature Language="F#" Value="type SyntaxTree = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class SyntaxTree abstract" />
  <TypeSignature Language="C++ CX" Value="[Windows::Foundation::Metadata::WebHostHidden]&#xA;public ref class SyntaxTree abstract" />
  <TypeSignature Language="C++ WINRT" Value="[Windows::Foundation::Metadata::WebHostHidden]&#xA;class SyntaxTree abstract" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
    <AssemblyVersion>2.6.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            The parsed representation of a source document.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SyntaxTree ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SyntaxTree();" />
      <MemberSignature Language="C++ CX" Value="protected:&#xA; SyntaxTree();" />
      <MemberSignature Language="C++ WINRT" Value=" SyntaxTree();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public abstract System.Text.Encoding Encoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxTree.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Encoding As Encoding" />
      <MemberSignature Language="F#" Value="member this.Encoding : System.Text.Encoding" Usage="Microsoft.CodeAnalysis.SyntaxTree.Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The text encoding of the source document.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilePath">
      <MemberSignature Language="C#" Value="public abstract string FilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FilePath" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxTree.FilePath" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FilePath As String" />
      <MemberSignature Language="F#" Value="member this.FilePath : string" Usage="Microsoft.CodeAnalysis.SyntaxTree.FilePath" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FilePath { System::String ^ get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; abstract property Platform::String ^ FilePath { Platform::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The path of the source document file.
            </summary>
        <value>To be added.</value>
        <remarks>
            If this syntax tree is not associated with a file, this value can be empty.
            The path shall not be null.
            
            The file doesn't need to exist on disk. The path is opaque to the compiler.
            The only requirement on the path format is that the implementations of 
            <see cref="T:Microsoft.CodeAnalysis.SourceReferenceResolver" />, <see cref="T:Microsoft.CodeAnalysis.XmlReferenceResolver" /> and <see cref="T:Microsoft.CodeAnalysis.MetadataReferenceResolver" /> 
            passed to the compilation that contains the tree understand it.
            
            Clients must also not assume that the values of this property are unique
            within a Compilation.
            
            The path is used as follows:
               - When debug information is emitted, this path is embedded in the debug information.
               - When resolving and normalizing relative paths in #r, #load, #line/#ExternalSource, 
                 #pragma checksum, #ExternalChecksum directives, XML doc comment include elements, etc.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangedSpans">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IList&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt; GetChangedSpans (Microsoft.CodeAnalysis.SyntaxTree syntaxTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;valuetype Microsoft.CodeAnalysis.Text.TextSpan&gt; GetChangedSpans(class Microsoft.CodeAnalysis.SyntaxTree syntaxTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetChangedSpans(Microsoft.CodeAnalysis.SyntaxTree)" />
      <MemberSignature Language="F#" Value="abstract member GetChangedSpans : Microsoft.CodeAnalysis.SyntaxTree -&gt; System.Collections.Generic.IList&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt;" Usage="syntaxTree.GetChangedSpans syntaxTree" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Collections::Generic::IList&lt;Microsoft::CodeAnalysis::Text::TextSpan&gt; ^ GetChangedSpans(Microsoft::CodeAnalysis::SyntaxTree ^ syntaxTree);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.CodeAnalysis.Text.TextSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="syntaxTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
      </Parameters>
      <Docs>
        <param name="syntaxTree">To be added.</param>
        <summary>
            Returns a list of the changed regions between this tree and the specified tree. The list is conservative for
            performance reasons. It may return larger regions than what has actually changed.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IList&lt;Microsoft.CodeAnalysis.Text.TextChange&gt; GetChanges (Microsoft.CodeAnalysis.SyntaxTree oldTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;valuetype Microsoft.CodeAnalysis.Text.TextChange&gt; GetChanges(class Microsoft.CodeAnalysis.SyntaxTree oldTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetChanges(Microsoft.CodeAnalysis.SyntaxTree)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChanges (oldTree As SyntaxTree) As IList(Of TextChange)" />
      <MemberSignature Language="F#" Value="abstract member GetChanges : Microsoft.CodeAnalysis.SyntaxTree -&gt; System.Collections.Generic.IList&lt;Microsoft.CodeAnalysis.Text.TextChange&gt;" Usage="syntaxTree.GetChanges oldTree" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Collections::Generic::IList&lt;Microsoft::CodeAnalysis::Text::TextChange&gt; ^ GetChanges(Microsoft::CodeAnalysis::SyntaxTree ^ oldTree);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.CodeAnalysis.Text.TextChange&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
      </Parameters>
      <Docs>
        <param name="oldTree">The old tree.</param>
        <summary>
            Gets a list of text changes that when applied to the old tree produce this tree.
            </summary>
        <returns>To be added.</returns>
        <remarks>The list of changes may be different than the original changes that produced
            this tree.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDiagnostics">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics (Microsoft.CodeAnalysis.SyntaxNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics(class Microsoft.CodeAnalysis.SyntaxNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNode)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetDiagnostics (node As SyntaxNode) As IEnumerable(Of Diagnostic)" />
      <MemberSignature Language="F#" Value="abstract member GetDiagnostics : Microsoft.CodeAnalysis.SyntaxNode -&gt; seq&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="syntaxTree.GetDiagnostics node" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::Diagnostic ^&gt; ^ GetDiagnostics(Microsoft::CodeAnalysis::SyntaxNode ^ node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <summary>
            Gets a list of all the diagnostics in the sub tree that has the specified node as its root.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDiagnostics">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics (Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetDiagnostics (nodeOrToken As SyntaxNodeOrToken) As IEnumerable(Of Diagnostic)" />
      <MemberSignature Language="F#" Value="abstract member GetDiagnostics : Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; seq&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="syntaxTree.GetDiagnostics nodeOrToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::Diagnostic ^&gt; ^ GetDiagnostics(Microsoft::CodeAnalysis::SyntaxNodeOrToken nodeOrToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Parameters>
      <Docs>
        <param name="nodeOrToken">To be added.</param>
        <summary>
            Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or
            associated with the token and its related trivia. 
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDiagnostics">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics (Microsoft.CodeAnalysis.SyntaxToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxToken)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetDiagnostics (token As SyntaxToken) As IEnumerable(Of Diagnostic)" />
      <MemberSignature Language="F#" Value="abstract member GetDiagnostics : Microsoft.CodeAnalysis.SyntaxToken -&gt; seq&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="syntaxTree.GetDiagnostics token" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::Diagnostic ^&gt; ^ GetDiagnostics(Microsoft::CodeAnalysis::SyntaxToken token);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" />
      </Parameters>
      <Docs>
        <param name="token">To be added.</param>
        <summary>
            Gets a list of all the diagnostics associated with the token and any related trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDiagnostics">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics (Microsoft.CodeAnalysis.SyntaxTrivia trivia);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics(valuetype Microsoft.CodeAnalysis.SyntaxTrivia trivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxTrivia)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetDiagnostics (trivia As SyntaxTrivia) As IEnumerable(Of Diagnostic)" />
      <MemberSignature Language="F#" Value="abstract member GetDiagnostics : Microsoft.CodeAnalysis.SyntaxTrivia -&gt; seq&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="syntaxTree.GetDiagnostics trivia" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::Diagnostic ^&gt; ^ GetDiagnostics(Microsoft::CodeAnalysis::SyntaxTrivia trivia);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
      </Parameters>
      <Docs>
        <param name="trivia">To be added.</param>
        <summary>
            Gets a list of all the diagnostics associated with the trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDiagnostics">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics (System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetDiagnostics : System.Threading.CancellationToken -&gt; seq&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="syntaxTree.GetDiagnostics cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets a list of all the diagnostics in the syntax tree.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineSpan">
      <MemberSignature Language="C#" Value="public abstract Microsoft.CodeAnalysis.FileLinePositionSpan GetLineSpan (Microsoft.CodeAnalysis.Text.TextSpan span, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.CodeAnalysis.FileLinePositionSpan GetLineSpan(valuetype Microsoft.CodeAnalysis.Text.TextSpan span, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetLineSpan : Microsoft.CodeAnalysis.Text.TextSpan * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.FileLinePositionSpan" Usage="syntaxTree.GetLineSpan (span, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.FileLinePositionSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="Microsoft.CodeAnalysis.Text.TextSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="span">Span within the tree.</param>
        <param name="cancellationToken">Cancellation token.</param>
        <summary>
            Gets the location in terms of path, line and column for a given span.
            </summary>
        <returns>
            A valid <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan" /> that contains path, line and column information.
            The values are not affected by line mapping directives (<code>#line</code>).
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineVisibility">
      <MemberSignature Language="C#" Value="public virtual Microsoft.CodeAnalysis.LineVisibility GetLineVisibility (int position, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.CodeAnalysis.LineVisibility GetLineVisibility(int32 position, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetLineVisibility(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetLineVisibility : int * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.LineVisibility&#xA;override this.GetLineVisibility : int * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.LineVisibility" Usage="syntaxTree.GetLineVisibility (position, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.LineVisibility</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="position">The position to check.</param>
        <param name="cancellationToken">The cancellation token.</param>
        <summary>
            Returns the visibility for the line at the given position.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLocation">
      <MemberSignature Language="C#" Value="public abstract Microsoft.CodeAnalysis.Location GetLocation (Microsoft.CodeAnalysis.Text.TextSpan span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.CodeAnalysis.Location GetLocation(valuetype Microsoft.CodeAnalysis.Text.TextSpan span) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetLocation(Microsoft.CodeAnalysis.Text.TextSpan)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetLocation (span As TextSpan) As Location" />
      <MemberSignature Language="F#" Value="abstract member GetLocation : Microsoft.CodeAnalysis.Text.TextSpan -&gt; Microsoft.CodeAnalysis.Location" Usage="syntaxTree.GetLocation span" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Microsoft::CodeAnalysis::Location ^ GetLocation(Microsoft::CodeAnalysis::Text::TextSpan span);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Location</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="Microsoft.CodeAnalysis.Text.TextSpan" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <summary>
            Gets a location for the specified text span.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMappedLineSpan">
      <MemberSignature Language="C#" Value="public abstract Microsoft.CodeAnalysis.FileLinePositionSpan GetMappedLineSpan (Microsoft.CodeAnalysis.Text.TextSpan span, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Microsoft.CodeAnalysis.FileLinePositionSpan GetMappedLineSpan(valuetype Microsoft.CodeAnalysis.Text.TextSpan span, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetMappedLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetMappedLineSpan : Microsoft.CodeAnalysis.Text.TextSpan * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.FileLinePositionSpan" Usage="syntaxTree.GetMappedLineSpan (span, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.FileLinePositionSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="Microsoft.CodeAnalysis.Text.TextSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="span">Span within the tree.</param>
        <param name="cancellationToken">Cancellation token.</param>
        <summary>
            Gets the location in terms of path, line and column after applying source line mapping directives 
            (<code>#line</code> in C# or <code>#ExternalSource</code> in VB). 
            </summary>
        <returns>
            A valid <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan" /> that contains path, line and column information.
            
            If the location path is mapped the resulting path is the path specified in the corresponding <code>#line</code>,
            otherwise it's <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.FilePath" />.
            
            A location path is considered mapped if the first <code>#line</code> directive that precedes it and that 
            either specifies an explicit file path or is <code>#line default</code> exists and specifies an explicit path.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReference">
      <MemberSignature Language="C#" Value="public abstract Microsoft.CodeAnalysis.SyntaxReference GetReference (Microsoft.CodeAnalysis.SyntaxNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxReference GetReference(class Microsoft.CodeAnalysis.SyntaxNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetReference(Microsoft.CodeAnalysis.SyntaxNode)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetReference (node As SyntaxNode) As SyntaxReference" />
      <MemberSignature Language="F#" Value="abstract member GetReference : Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.SyntaxReference" Usage="syntaxTree.GetReference node" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxReference ^ GetReference(Microsoft::CodeAnalysis::SyntaxNode ^ node);" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxReference ^ GetReference(Microsoft::CodeAnalysis::SyntaxNode ^ node);" />
      <MemberSignature Language="C++ WINRT" Value=" abstract Microsoft::CodeAnalysis::SyntaxReference GetReference(Microsoft::CodeAnalysis::SyntaxNode const &amp; node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <summary>
            Gets a SyntaxReference for a specified syntax node. SyntaxReferences can be used to
            regain access to a syntax node without keeping the entire tree and source text in
            memory.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRoot">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNode GetRoot (System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.SyntaxNode GetRoot(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetRoot(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="member this.GetRoot : System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SyntaxNode" Usage="syntaxTree.GetRoot cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the root node of the syntax tree, causing computation if necessary.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRootAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; GetRootAsync (System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; GetRootAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetRootAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="member this.GetRootAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" Usage="syntaxTree.GetRootAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the root node of the syntax tree asynchronously.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRootAsyncCore">
      <MemberSignature Language="C#" Value="protected abstract System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; GetRootAsyncCore (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; GetRootAsyncCore(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetRootAsyncCore(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetRootAsyncCore : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" Usage="syntaxTree.GetRootAsyncCore cancellationToken" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Threading::Tasks::Task&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ GetRootAsyncCore(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the root node of the syntax tree asynchronously.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRootCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.SyntaxNode GetRootCore (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxNode GetRootCore(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetRootCore(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetRootCore : System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SyntaxNode" Usage="syntaxTree.GetRootCore cancellationToken" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract Microsoft::CodeAnalysis::SyntaxNode ^ GetRootCore(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the root node of the syntax tree, causing computation if necessary.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public abstract Microsoft.CodeAnalysis.Text.SourceText GetText (System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.CodeAnalysis.Text.SourceText GetText(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetText(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetText : System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.Text.SourceText" Usage="syntaxTree.GetText cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Text.SourceText</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the text of the source document.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTextAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.Text.SourceText&gt; GetTextAsync (System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Microsoft.CodeAnalysis.Text.SourceText&gt; GetTextAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.GetTextAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member GetTextAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.Text.SourceText&gt;&#xA;override this.GetTextAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.Text.SourceText&gt;" Usage="syntaxTree.GetTextAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.Text.SourceText&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>
            Gets the text of the source document asynchronously.
            </summary>
        <returns>To be added.</returns>
        <remarks>
            By default, the work associated with this method will be executed immediately on the current thread.
            Implementations that wish to schedule this work differently should override <see cref="M:Microsoft.CodeAnalysis.SyntaxTree.GetTextAsync(System.Threading.CancellationToken)" />.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasCompilationUnitRoot">
      <MemberSignature Language="C#" Value="public abstract bool HasCompilationUnitRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasCompilationUnitRoot" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxTree.HasCompilationUnitRoot" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property HasCompilationUnitRoot As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasCompilationUnitRoot : bool" Usage="Microsoft.CodeAnalysis.SyntaxTree.HasCompilationUnitRoot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool HasCompilationUnitRoot { bool get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; abstract property bool HasCompilationUnitRoot { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns true if this syntax tree has a root with SyntaxKind "CompilationUnit".
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasHiddenRegions">
      <MemberSignature Language="C#" Value="public abstract bool HasHiddenRegions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasHiddenRegions() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.HasHiddenRegions" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function HasHiddenRegions () As Boolean" />
      <MemberSignature Language="F#" Value="abstract member HasHiddenRegions : unit -&gt; bool" Usage="syntaxTree.HasHiddenRegions " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool HasHiddenRegions();" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; abstract bool HasHiddenRegions();" />
      <MemberSignature Language="C++ WINRT" Value=" abstract bool HasHiddenRegions();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Are there any hidden regions in the tree?
            </summary>
        <returns>True if there is at least one hidden region.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public abstract bool IsEquivalentTo (Microsoft.CodeAnalysis.SyntaxTree tree, bool topLevel = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class Microsoft.CodeAnalysis.SyntaxTree tree, bool topLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsEquivalentTo (tree As SyntaxTree, Optional topLevel As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Microsoft.CodeAnalysis.SyntaxTree * bool -&gt; bool" Usage="syntaxTree.IsEquivalentTo (tree, topLevel)" />
      <MemberSignature Language="C++ WINRT" Value=" abstract bool IsEquivalentTo(Microsoft::CodeAnalysis::SyntaxTree const &amp; tree, bool topLevel = false);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tree" Type="Microsoft.CodeAnalysis.SyntaxTree" />
        <Parameter Name="topLevel" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="tree">The tree to compare against.</param>
        <param name="topLevel"> If true then the trees are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        <summary>
            Determines if two trees are the same, disregarding trivia differences.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public abstract int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxTree.Length" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Length As Integer" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="Microsoft.CodeAnalysis.SyntaxTree.Length" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int Length { int get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; abstract property int Length { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The length of the text of the syntax tree.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.ParseOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.ParseOptions Options" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxTree.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As ParseOptions" />
      <MemberSignature Language="F#" Value="member this.Options : Microsoft.CodeAnalysis.ParseOptions" Usage="Microsoft.CodeAnalysis.SyntaxTree.Options" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::ParseOptions ^ Options { Microsoft::CodeAnalysis::ParseOptions ^ get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property Microsoft::CodeAnalysis::ParseOptions ^ Options { Microsoft::CodeAnalysis::ParseOptions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ParseOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The options used by the parser to produce the syntax tree.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OptionsCore">
      <MemberSignature Language="C#" Value="protected abstract Microsoft.CodeAnalysis.ParseOptions OptionsCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.ParseOptions OptionsCore" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxTree.OptionsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property OptionsCore As ParseOptions" />
      <MemberSignature Language="F#" Value="member this.OptionsCore : Microsoft.CodeAnalysis.ParseOptions" Usage="Microsoft.CodeAnalysis.SyntaxTree.OptionsCore" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property Microsoft::CodeAnalysis::ParseOptions ^ OptionsCore { Microsoft::CodeAnalysis::ParseOptions ^ get(); };" />
      <MemberSignature Language="C++ CX" Value="protected:&#xA; abstract property Microsoft::CodeAnalysis::ParseOptions ^ OptionsCore { Microsoft::CodeAnalysis::ParseOptions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ParseOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The options used by the parser to produce the syntax tree.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="syntaxTree.ToString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; override Platform::String ^ ToString();" />
      <MemberSignature Language="C++ WINRT" Value=" override std::wstring ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns a <see cref="T:System.String" /> that represents the entire source text of this <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetRoot">
      <MemberSignature Language="C#" Value="public bool TryGetRoot (out Microsoft.CodeAnalysis.SyntaxNode root);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetRoot([out] class Microsoft.CodeAnalysis.SyntaxNode&amp; root) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.TryGetRoot(Microsoft.CodeAnalysis.SyntaxNode@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetRoot (ByRef root As SyntaxNode) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryGetRoot :  -&gt; bool" Usage="syntaxTree.TryGetRoot root" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetRoot([Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SyntaxNode ^ % root);" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; bool TryGetRoot([Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SyntaxNode ^ &amp;  root);" />
      <MemberSignature Language="C++ WINRT" Value="bool TryGetRoot([Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SyntaxNode const &amp; &amp; root);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="Microsoft.CodeAnalysis.SyntaxNode&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="root">To be added.</param>
        <summary>
            Gets the root of the syntax tree if it is available.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetRootCore">
      <MemberSignature Language="C#" Value="protected abstract bool TryGetRootCore (out Microsoft.CodeAnalysis.SyntaxNode root);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryGetRootCore([out] class Microsoft.CodeAnalysis.SyntaxNode&amp; root) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.TryGetRootCore(Microsoft.CodeAnalysis.SyntaxNode@)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function TryGetRootCore (ByRef root As SyntaxNode) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryGetRootCore :  -&gt; bool" Usage="syntaxTree.TryGetRootCore root" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryGetRootCore([Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SyntaxNode ^ % root);" />
      <MemberSignature Language="C++ CX" Value="protected:&#xA; abstract bool TryGetRootCore([Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SyntaxNode ^ &amp;  root);" />
      <MemberSignature Language="C++ WINRT" Value=" abstract bool TryGetRootCore([Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SyntaxNode const &amp; &amp; root);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="Microsoft.CodeAnalysis.SyntaxNode&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="root">To be added.</param>
        <summary>
            Gets the root of the syntax tree if it is available.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetText">
      <MemberSignature Language="C#" Value="public abstract bool TryGetText (out Microsoft.CodeAnalysis.Text.SourceText text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetText([out] class Microsoft.CodeAnalysis.Text.SourceText&amp; text) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.TryGetText(Microsoft.CodeAnalysis.Text.SourceText@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function TryGetText (ByRef text As SourceText) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryGetText :  -&gt; bool" Usage="syntaxTree.TryGetText text" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool TryGetText([Runtime::InteropServices::Out] Microsoft::CodeAnalysis::Text::SourceText ^ % text);" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; abstract bool TryGetText([Runtime::InteropServices::Out] Microsoft::CodeAnalysis::Text::SourceText ^ &amp;  text);" />
      <MemberSignature Language="C++ WINRT" Value=" abstract bool TryGetText([Runtime::InteropServices::Out] Microsoft::CodeAnalysis::Text::SourceText const &amp; &amp; text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="Microsoft.CodeAnalysis.Text.SourceText&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="text">To be added.</param>
        <summary>
            Gets the syntax tree's text if it is available.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithChangedText">
      <MemberSignature Language="C#" Value="public abstract Microsoft.CodeAnalysis.SyntaxTree WithChangedText (Microsoft.CodeAnalysis.Text.SourceText newText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxTree WithChangedText(class Microsoft.CodeAnalysis.Text.SourceText newText) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function WithChangedText (newText As SourceText) As SyntaxTree" />
      <MemberSignature Language="F#" Value="abstract member WithChangedText : Microsoft.CodeAnalysis.Text.SourceText -&gt; Microsoft.CodeAnalysis.SyntaxTree" Usage="syntaxTree.WithChangedText newText" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxTree ^ WithChangedText(Microsoft::CodeAnalysis::Text::SourceText ^ newText);" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxTree ^ WithChangedText(Microsoft::CodeAnalysis::Text::SourceText ^ newText);" />
      <MemberSignature Language="C++ WINRT" Value=" abstract Microsoft::CodeAnalysis::SyntaxTree WithChangedText(Microsoft::CodeAnalysis::Text::SourceText const &amp; newText);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTree</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newText" Type="Microsoft.CodeAnalysis.Text.SourceText" />
      </Parameters>
      <Docs>
        <param name="newText">To be added.</param>
        <summary>
            Create a new syntax tree based off this tree using a new source text.
            
            If the new source text is a minor change from the current source text an incremental
            parse will occur reusing most of the current syntax tree internal data.  Otherwise, a
            full parse will occur using the new source text.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithFilePath">
      <MemberSignature Language="C#" Value="public abstract Microsoft.CodeAnalysis.SyntaxTree WithFilePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxTree WithFilePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.WithFilePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function WithFilePath (path As String) As SyntaxTree" />
      <MemberSignature Language="F#" Value="abstract member WithFilePath : string -&gt; Microsoft.CodeAnalysis.SyntaxTree" Usage="syntaxTree.WithFilePath path" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxTree ^ WithFilePath(System::String ^ path);" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxTree ^ WithFilePath(Platform::String ^ path);" />
      <MemberSignature Language="C++ WINRT" Value=" abstract Microsoft::CodeAnalysis::SyntaxTree WithFilePath(std::wstring const &amp; path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTree</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>
            Returns a new tree whose <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.FilePath" /> is the specified node and other properties are copied from the current tree.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithRootAndOptions">
      <MemberSignature Language="C#" Value="public abstract Microsoft.CodeAnalysis.SyntaxTree WithRootAndOptions (Microsoft.CodeAnalysis.SyntaxNode root, Microsoft.CodeAnalysis.ParseOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.CodeAnalysis.SyntaxTree WithRootAndOptions(class Microsoft.CodeAnalysis.SyntaxNode root, class Microsoft.CodeAnalysis.ParseOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxTree.WithRootAndOptions(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ParseOptions)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function WithRootAndOptions (root As SyntaxNode, options As ParseOptions) As SyntaxTree" />
      <MemberSignature Language="F#" Value="abstract member WithRootAndOptions : Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.ParseOptions -&gt; Microsoft.CodeAnalysis.SyntaxTree" Usage="syntaxTree.WithRootAndOptions (root, options)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxTree ^ WithRootAndOptions(Microsoft::CodeAnalysis::SyntaxNode ^ root, Microsoft::CodeAnalysis::ParseOptions ^ options);" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; abstract Microsoft::CodeAnalysis::SyntaxTree ^ WithRootAndOptions(Microsoft::CodeAnalysis::SyntaxNode ^ root, Microsoft::CodeAnalysis::ParseOptions ^ options);" />
      <MemberSignature Language="C++ WINRT" Value=" abstract Microsoft::CodeAnalysis::SyntaxTree WithRootAndOptions(Microsoft::CodeAnalysis::SyntaxNode const &amp; root, Microsoft::CodeAnalysis::ParseOptions const &amp; options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTree</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="options" Type="Microsoft.CodeAnalysis.ParseOptions" />
      </Parameters>
      <Docs>
        <param name="root">To be added.</param>
        <param name="options">To be added.</param>
        <summary>
            Returns a new tree whose root and options are as specified and other properties are copied from the current tree.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>