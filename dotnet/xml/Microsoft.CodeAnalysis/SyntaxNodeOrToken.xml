<Type Name="SyntaxNodeOrToken" FullName="Microsoft.CodeAnalysis.SyntaxNodeOrToken">
  <TypeSignature Language="C#" Value="public struct SyntaxNodeOrToken : IEquatable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SyntaxNodeOrToken extends System.ValueType implements class System.IEquatable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;" />
  <TypeSignature Language="DocId" Value="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
  <TypeSignature Language="VB.NET" Value="Public Structure SyntaxNodeOrToken&#xA;Implements IEquatable(Of SyntaxNodeOrToken)" />
  <TypeSignature Language="F#" Value="type SyntaxNodeOrToken = struct" />
  <TypeSignature Language="C++ CLI" Value="public value class SyntaxNodeOrToken : IEquatable&lt;Microsoft::CodeAnalysis::SyntaxNodeOrToken&gt;" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
    <AssemblyVersion>2.6.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;Microsoft.CodeAnalysis.SyntaxNodeOrToken&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{GetDebuggerDisplay(), nq}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            A wrapper for either a syntax node (<see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />) or a syntax token (<see cref="T:Microsoft.CodeAnalysis.SyntaxToken" />).
            </summary>
    <remarks>
            Note that we do not store the token directly, we just store enough information to reconstruct it.
            This allows us to reuse nodeOrToken as a token's parent.
            </remarks>
  </Docs>
  <Members>
    <Member MemberName="AsNode">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNode AsNode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.SyntaxNode AsNode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.AsNode" />
      <MemberSignature Language="VB.NET" Value="Public Function AsNode () As SyntaxNode" />
      <MemberSignature Language="F#" Value="member this.AsNode : unit -&gt; Microsoft.CodeAnalysis.SyntaxNode" Usage="syntaxNodeOrToken.AsNode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNode ^ AsNode();" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNode ^ AsNode();" />
      <MemberSignature Language="C++ WINRT" Value="Microsoft::CodeAnalysis::SyntaxNode AsNode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns the underlying node if this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> is wrapping a
            node.
            </summary>
        <returns>
            The underlying node if this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> is wrapping a node.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsToken">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxToken AsToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxToken AsToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.AsToken" />
      <MemberSignature Language="VB.NET" Value="Public Function AsToken () As SyntaxToken" />
      <MemberSignature Language="F#" Value="member this.AsToken : unit -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="syntaxNodeOrToken.AsToken " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxToken AsToken();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns the underlying token if this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> is wrapping a
            token.
            </summary>
        <returns>
            The underlying token if this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> is wrapping a token.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildNodesAndTokens">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.ChildSyntaxList ChildNodesAndTokens ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.ChildSyntaxList ChildNodesAndTokens() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ChildNodesAndTokens" />
      <MemberSignature Language="VB.NET" Value="Public Function ChildNodesAndTokens () As ChildSyntaxList" />
      <MemberSignature Language="F#" Value="member this.ChildNodesAndTokens : unit -&gt; Microsoft.CodeAnalysis.ChildSyntaxList" Usage="syntaxNodeOrToken.ChildNodesAndTokens " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::ChildSyntaxList ChildNodesAndTokens();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.ChildSyntaxList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            The list of child nodes and tokens of the underlying node or token.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsAnnotations">
      <MemberSignature Language="C#" Value="public bool ContainsAnnotations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsAnnotations" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ContainsAnnotations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsAnnotations As Boolean" />
      <MemberSignature Language="F#" Value="member this.ContainsAnnotations : bool" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.ContainsAnnotations" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsAnnotations { bool get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property bool ContainsAnnotations { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether this node or token (or any sub node, token or trivia) as annotations.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsDiagnostics">
      <MemberSignature Language="C#" Value="public bool ContainsDiagnostics { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsDiagnostics" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ContainsDiagnostics" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsDiagnostics As Boolean" />
      <MemberSignature Language="F#" Value="member this.ContainsDiagnostics : bool" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.ContainsDiagnostics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsDiagnostics { bool get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property bool ContainsDiagnostics { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether the underlying node or token or any of its descendant nodes, tokens or trivia have any
            diagnostics on them. 
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsDirectives">
      <MemberSignature Language="C#" Value="public bool ContainsDirectives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsDirectives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ContainsDirectives" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsDirectives As Boolean" />
      <MemberSignature Language="F#" Value="member this.ContainsDirectives : bool" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.ContainsDirectives" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsDirectives { bool get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property bool ContainsDirectives { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether the underlying node or token has any descendant preprocessor directives.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (Microsoft.CodeAnalysis.SyntaxNodeOrToken other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken other) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Equals(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As SyntaxNodeOrToken) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; bool" Usage="syntaxNodeOrToken.Equals other" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Microsoft::CodeAnalysis::SyntaxNodeOrToken other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>
            Determines whether the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> is equal to this
            <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="syntaxNodeOrToken.Equals obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; override bool Equals(Platform::Object ^ obj);" />
      <MemberSignature Language="C++ WINRT" Value=" override bool Equals(winrt::Windows::Foundation::IInspectable const &amp; obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>
            Determines whether the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> is equal to this
            <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullSpan">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Text.TextSpan FullSpan { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.Text.TextSpan FullSpan" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.FullSpan" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FullSpan As TextSpan" />
      <MemberSignature Language="F#" Value="member this.FullSpan : Microsoft.CodeAnalysis.Text.TextSpan" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.FullSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::Text::TextSpan FullSpan { Microsoft::CodeAnalysis::Text::TextSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Text.TextSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The absolute span of the underlying node or token in characters, including its leading and trailing trivia.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnnotations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt; GetAnnotations (System.Collections.Generic.IEnumerable&lt;string&gt; annotationKinds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxAnnotation&gt; GetAnnotations(class System.Collections.Generic.IEnumerable`1&lt;string&gt; annotationKinds) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetAnnotations(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnnotations (annotationKinds As IEnumerable(Of String)) As IEnumerable(Of SyntaxAnnotation)" />
      <MemberSignature Language="F#" Value="member this.GetAnnotations : seq&lt;string&gt; -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt;" Usage="syntaxNodeOrToken.GetAnnotations annotationKinds" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxAnnotation ^&gt; ^ GetAnnotations(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ annotationKinds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKinds" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="annotationKinds">To be added.</param>
        <summary>
            Gets all annotations of the specified annotation kind.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnnotations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt; GetAnnotations (string annotationKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxAnnotation&gt; GetAnnotations(string annotationKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetAnnotations(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnnotations (annotationKind As String) As IEnumerable(Of SyntaxAnnotation)" />
      <MemberSignature Language="F#" Value="member this.GetAnnotations : string -&gt; seq&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt;" Usage="syntaxNodeOrToken.GetAnnotations annotationKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxAnnotation ^&gt; ^ GetAnnotations(System::String ^ annotationKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKind" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="annotationKind">To be added.</param>
        <summary>
            Gets all annotations of the specified annotation kind.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDiagnostics">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.Diagnostic&gt; GetDiagnostics() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetDiagnostics" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDiagnostics () As IEnumerable(Of Diagnostic)" />
      <MemberSignature Language="F#" Value="member this.GetDiagnostics : unit -&gt; seq&lt;Microsoft.CodeAnalysis.Diagnostic&gt;" Usage="syntaxNodeOrToken.GetDiagnostics " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::Diagnostic ^&gt; ^ GetDiagnostics();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.Diagnostic&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets a list of all the diagnostics in either the sub tree that has this node as its root or
            associated with this token and its related trivia. 
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFirstChildIndexSpanningPosition">
      <MemberSignature Language="C#" Value="public static int GetFirstChildIndexSpanningPosition (Microsoft.CodeAnalysis.SyntaxNode node, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetFirstChildIndexSpanningPosition(class Microsoft.CodeAnalysis.SyntaxNode node, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetFirstChildIndexSpanningPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFirstChildIndexSpanningPosition (node As SyntaxNode, position As Integer) As Integer" />
      <MemberSignature Language="F#" Value="static member GetFirstChildIndexSpanningPosition : Microsoft.CodeAnalysis.SyntaxNode * int -&gt; int" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetFirstChildIndexSpanningPosition (node, position)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetFirstChildIndexSpanningPosition(Microsoft::CodeAnalysis::SyntaxNode ^ node, int position);" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; static int GetFirstChildIndexSpanningPosition(Microsoft::CodeAnalysis::SyntaxNode ^ node, int position);" />
      <MemberSignature Language="C++ WINRT" Value=" static int GetFirstChildIndexSpanningPosition(Microsoft::CodeAnalysis::SyntaxNode const &amp; node, int position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="node">To be added.</param>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="syntaxNodeOrToken.GetHashCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="C++ WINRT" Value=" override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Serves as hash function for <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeadingTrivia">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxTriviaList GetLeadingTrivia ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxTriviaList GetLeadingTrivia() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetLeadingTrivia" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeadingTrivia () As SyntaxTriviaList" />
      <MemberSignature Language="F#" Value="member this.GetLeadingTrivia : unit -&gt; Microsoft.CodeAnalysis.SyntaxTriviaList" Usage="syntaxNodeOrToken.GetLeadingTrivia " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxTriviaList GetLeadingTrivia();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTriviaList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            The list of trivia that appear before the underlying node or token in the source code and are attached to a
            token that is a descendant of the underlying node or token.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLocation">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Location GetLocation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.CodeAnalysis.Location GetLocation() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetLocation" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocation () As Location" />
      <MemberSignature Language="F#" Value="member this.GetLocation : unit -&gt; Microsoft.CodeAnalysis.Location" Usage="syntaxNodeOrToken.GetLocation " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::Location ^ GetLocation();" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; Microsoft::CodeAnalysis::Location ^ GetLocation();" />
      <MemberSignature Language="C++ WINRT" Value="Microsoft::CodeAnalysis::Location GetLocation();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Location</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Get the location of this node or token.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextSibling">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken GetNextSibling ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken GetNextSibling() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetNextSibling" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextSibling () As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.GetNextSibling : unit -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrToken.GetNextSibling " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken GetNextSibling();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPreviousSibling">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken GetPreviousSibling ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken GetPreviousSibling() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetPreviousSibling" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPreviousSibling () As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.GetPreviousSibling : unit -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrToken.GetPreviousSibling " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken GetPreviousSibling();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTrailingTrivia">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxTriviaList GetTrailingTrivia ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxTriviaList GetTrailingTrivia() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.GetTrailingTrivia" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTrailingTrivia () As SyntaxTriviaList" />
      <MemberSignature Language="F#" Value="member this.GetTrailingTrivia : unit -&gt; Microsoft.CodeAnalysis.SyntaxTriviaList" Usage="syntaxNodeOrToken.GetTrailingTrivia " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxTriviaList GetTrailingTrivia();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTriviaList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            The list of trivia that appear after the underlying node or token in the source code and are attached to a
            token that is a descendant of the underlying node or token.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnnotation">
      <MemberSignature Language="C#" Value="public bool HasAnnotation (Microsoft.CodeAnalysis.SyntaxAnnotation annotation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasAnnotation(class Microsoft.CodeAnalysis.SyntaxAnnotation annotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasAnnotation (annotation As SyntaxAnnotation) As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasAnnotation : Microsoft.CodeAnalysis.SyntaxAnnotation -&gt; bool" Usage="syntaxNodeOrToken.HasAnnotation annotation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasAnnotation(Microsoft::CodeAnalysis::SyntaxAnnotation ^ annotation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotation" Type="Microsoft.CodeAnalysis.SyntaxAnnotation" />
      </Parameters>
      <Docs>
        <param name="annotation">To be added.</param>
        <summary>
            Determines if this node or token has the specific annotation.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnnotations">
      <MemberSignature Language="C#" Value="public bool HasAnnotations (System.Collections.Generic.IEnumerable&lt;string&gt; annotationKinds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasAnnotations(class System.Collections.Generic.IEnumerable`1&lt;string&gt; annotationKinds) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasAnnotations(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function HasAnnotations (annotationKinds As IEnumerable(Of String)) As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasAnnotations : seq&lt;string&gt; -&gt; bool" Usage="syntaxNodeOrToken.HasAnnotations annotationKinds" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasAnnotations(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ annotationKinds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKinds" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="annotationKinds">To be added.</param>
        <summary>
            Determines whether this node or token has annotations of the specified kind.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnnotations">
      <MemberSignature Language="C#" Value="public bool HasAnnotations (string annotationKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasAnnotations(string annotationKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasAnnotations(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasAnnotations (annotationKind As String) As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasAnnotations : string -&gt; bool" Usage="syntaxNodeOrToken.HasAnnotations annotationKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasAnnotations(System::String ^ annotationKind);" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; bool HasAnnotations(Platform::String ^ annotationKind);" />
      <MemberSignature Language="C++ WINRT" Value="bool HasAnnotations(std::wstring const &amp; annotationKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKind" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="annotationKind">To be added.</param>
        <summary>
            Determines whether this node or token has annotations of the specified kind.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasLeadingTrivia">
      <MemberSignature Language="C#" Value="public bool HasLeadingTrivia { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasLeadingTrivia" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasLeadingTrivia" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasLeadingTrivia As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasLeadingTrivia : bool" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasLeadingTrivia" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasLeadingTrivia { bool get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property bool HasLeadingTrivia { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether the underlying node or token has any leading trivia.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasTrailingTrivia">
      <MemberSignature Language="C#" Value="public bool HasTrailingTrivia { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasTrailingTrivia" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasTrailingTrivia" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasTrailingTrivia As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasTrailingTrivia : bool" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.HasTrailingTrivia" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasTrailingTrivia { bool get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property bool HasTrailingTrivia { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether the underlying node or token has any trailing trivia.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public bool IsEquivalentTo (Microsoft.CodeAnalysis.SyntaxNodeOrToken other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEquivalentTo(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken other) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEquivalentTo (other As SyntaxNodeOrToken) As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsEquivalentTo : Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; bool" Usage="syntaxNodeOrToken.IsEquivalentTo other" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEquivalentTo(Microsoft::CodeAnalysis::SyntaxNodeOrToken other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>
            Determines if the two nodes or tokens are equivalent.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMissing">
      <MemberSignature Language="C#" Value="public bool IsMissing { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMissing" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsMissing" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMissing As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsMissing : bool" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsMissing" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMissing { bool get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property bool IsMissing { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether the underlying node or token represents a language construct that was actually parsed
            from source code. Missing nodes and tokens are typically generated by the parser in error scenarios to
            represent constructs that should have been present in the source code for the source code to compile
            successfully but were actually missing.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNode">
      <MemberSignature Language="C#" Value="public bool IsNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNode" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNode As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsNode : bool" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNode { bool get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property bool IsNode { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> is wrapping a node.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsToken">
      <MemberSignature Language="C#" Value="public bool IsToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsToken" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsToken As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsToken : bool" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.IsToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsToken { bool get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property bool IsToken { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines whether this <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> is wrapping a token.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public string Language { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Language" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Language" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Language As String" />
      <MemberSignature Language="F#" Value="member this.Language : string" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.Language" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Language { System::String ^ get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property Platform::String ^ Language { Platform::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The language name that this node or token is syntax of.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Microsoft.CodeAnalysis.SyntaxNodeOrToken left, Microsoft.CodeAnalysis.SyntaxNodeOrToken right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken left, valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken right) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Equality(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As SyntaxNodeOrToken, right As SyntaxNodeOrToken) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( = ) : Microsoft.CodeAnalysis.SyntaxNodeOrToken * Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; bool" Usage="left = right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Microsoft::CodeAnalysis::SyntaxNodeOrToken left, Microsoft::CodeAnalysis::SyntaxNodeOrToken right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
        <Parameter Name="right" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />s are equal.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Microsoft.CodeAnalysis.SyntaxNode (Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class Microsoft.CodeAnalysis.SyntaxNode op_Explicit(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Explicit(Microsoft.CodeAnalysis.SyntaxNodeOrToken)~Microsoft.CodeAnalysis.SyntaxNode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (nodeOrToken As SyntaxNodeOrToken) As SyntaxNode" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; Microsoft.CodeAnalysis.SyntaxNode" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Explicit nodeOrToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Microsoft::CodeAnalysis::SyntaxNode ^(Microsoft::CodeAnalysis::SyntaxNodeOrToken nodeOrToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Parameters>
      <Docs>
        <param name="nodeOrToken">
            The input <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />.
            </param>
        <summary>
            Returns the underlying node wrapped by the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />.
            </summary>
        <returns>
            The underlying node wrapped by the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Microsoft.CodeAnalysis.SyntaxToken (Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype Microsoft.CodeAnalysis.SyntaxToken op_Explicit(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Explicit(Microsoft.CodeAnalysis.SyntaxNodeOrToken)~Microsoft.CodeAnalysis.SyntaxToken" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (nodeOrToken As SyntaxNodeOrToken) As SyntaxToken" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Explicit nodeOrToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Microsoft::CodeAnalysis::SyntaxToken(Microsoft::CodeAnalysis::SyntaxNodeOrToken nodeOrToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Parameters>
      <Docs>
        <param name="nodeOrToken">
            The input <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />.
            </param>
        <summary>
            Returns the underlying token wrapped by the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />.
            </summary>
        <returns>
            The underlying token wrapped by the supplied <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Microsoft.CodeAnalysis.SyntaxNodeOrToken (Microsoft.CodeAnalysis.SyntaxNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken op_Implicit(class Microsoft.CodeAnalysis.SyntaxNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Implicit(Microsoft.CodeAnalysis.SyntaxNode)~Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (node As SyntaxNode) As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="static member op_Implicit : Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Implicit node" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Microsoft::CodeAnalysis::SyntaxNodeOrToken(Microsoft::CodeAnalysis::SyntaxNode ^ node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
      </Parameters>
      <Docs>
        <param name="node">The input node.</param>
        <summary>
            Returns a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> that wraps the supplied node.
            </summary>
        <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> that wraps the supplied node.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Microsoft.CodeAnalysis.SyntaxNodeOrToken (Microsoft.CodeAnalysis.SyntaxToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken op_Implicit(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Implicit(Microsoft.CodeAnalysis.SyntaxToken)~Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (token As SyntaxToken) As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="static member op_Implicit : Microsoft.CodeAnalysis.SyntaxToken -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Implicit token" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Microsoft::CodeAnalysis::SyntaxNodeOrToken(Microsoft::CodeAnalysis::SyntaxToken token);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" />
      </Parameters>
      <Docs>
        <param name="token">The input token.</param>
        <summary>
            Returns a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> that wraps the supplied token.
            </summary>
        <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> that wraps the supplied token.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Microsoft.CodeAnalysis.SyntaxNodeOrToken left, Microsoft.CodeAnalysis.SyntaxNodeOrToken right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken left, valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken right) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Inequality(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As SyntaxNodeOrToken, right As SyntaxNodeOrToken) As Boolean" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Microsoft.CodeAnalysis.SyntaxNodeOrToken * Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; bool" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.op_Inequality (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Microsoft::CodeAnalysis::SyntaxNodeOrToken left, Microsoft::CodeAnalysis::SyntaxNodeOrToken right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
        <Parameter Name="right" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>
            Determines whether two <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />s are unequal.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNode Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.SyntaxNode Parent" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As SyntaxNode" />
      <MemberSignature Language="F#" Value="member this.Parent : Microsoft.CodeAnalysis.SyntaxNode" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.Parent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::SyntaxNode ^ Parent { Microsoft::CodeAnalysis::SyntaxNode ^ get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property Microsoft::CodeAnalysis::SyntaxNode ^ Parent { Microsoft::CodeAnalysis::SyntaxNode ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The node that contains the underlying node or token in its Children collection.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RawKind">
      <MemberSignature Language="C#" Value="public int RawKind { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RawKind" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.RawKind" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawKind As Integer" />
      <MemberSignature Language="F#" Value="member this.RawKind : int" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.RawKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RawKind { int get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property int RawKind { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            An integer representing the language specific kind of the underlying node or token.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Span">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.Text.TextSpan Span { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.CodeAnalysis.Text.TextSpan Span" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Span" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Span As TextSpan" />
      <MemberSignature Language="F#" Value="member this.Span : Microsoft.CodeAnalysis.Text.TextSpan" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.Span" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::Text::TextSpan Span { Microsoft::CodeAnalysis::Text::TextSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.Text.TextSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The absolute span of the underlying node or token in characters, not including its leading and trailing
            trivia.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SpanStart">
      <MemberSignature Language="C#" Value="public int SpanStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SpanStart" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.SpanStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SpanStart As Integer" />
      <MemberSignature Language="F#" Value="member this.SpanStart : int" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.SpanStart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SpanStart { int get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property int SpanStart { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Same as accessing <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.Start" /> on <see cref="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.Span" />.
            </summary>
        <value>To be added.</value>
        <remarks>
            Slight performance improvement.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyntaxTree">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxTree SyntaxTree { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.CodeAnalysis.SyntaxTree SyntaxTree" />
      <MemberSignature Language="DocId" Value="P:Microsoft.CodeAnalysis.SyntaxNodeOrToken.SyntaxTree" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyntaxTree As SyntaxTree" />
      <MemberSignature Language="F#" Value="member this.SyntaxTree : Microsoft.CodeAnalysis.SyntaxTree" Usage="Microsoft.CodeAnalysis.SyntaxNodeOrToken.SyntaxTree" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::CodeAnalysis::SyntaxTree ^ SyntaxTree { Microsoft::CodeAnalysis::SyntaxTree ^ get(); };" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; property Microsoft::CodeAnalysis::SyntaxTree ^ SyntaxTree { Microsoft::CodeAnalysis::SyntaxTree ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxTree</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            SyntaxTree which contains current SyntaxNodeOrToken.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToFullString">
      <MemberSignature Language="C#" Value="public string ToFullString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToFullString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ToFullString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToFullString () As String" />
      <MemberSignature Language="F#" Value="member this.ToFullString : unit -&gt; string" Usage="syntaxNodeOrToken.ToFullString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToFullString();" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; Platform::String ^ ToFullString();" />
      <MemberSignature Language="C++ WINRT" Value="std::wstring ToFullString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns the full string representation of this node or token including its leading and trailing trivia.
            </summary>
        <returns>The full string representation of this node or token including its leading and trailing
            trivia.</returns>
        <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="syntaxNodeOrToken.ToString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="C++ CX" Value="public:&#xA; override Platform::String ^ ToString();" />
      <MemberSignature Language="C++ WINRT" Value=" override std::wstring ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns the string representation of this node or token, not including its leading and trailing
            trivia.
            </summary>
        <returns>
            The string representation of this node or token, not including its leading and trailing trivia.
            </returns>
        <remarks>The length of the returned string is always the same as Span.Length</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithAdditionalAnnotations">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithAdditionalAnnotations (params Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken WithAdditionalAnnotations(class Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithAdditionalAnnotations(Microsoft.CodeAnalysis.SyntaxAnnotation[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WithAdditionalAnnotations (ParamArray annotations As SyntaxAnnotation()) As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.WithAdditionalAnnotations : Microsoft.CodeAnalysis.SyntaxAnnotation[] -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrToken.WithAdditionalAnnotations annotations" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken WithAdditionalAnnotations(... cli::array &lt;Microsoft::CodeAnalysis::SyntaxAnnotation ^&gt; ^ annotations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotations" Type="Microsoft.CodeAnalysis.SyntaxAnnotation[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="annotations">To be added.</param>
        <summary>
            Creates a new node or token identical to this one with the specified annotations.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithAdditionalAnnotations">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithAdditionalAnnotations (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt; annotations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken WithAdditionalAnnotations(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxAnnotation&gt; annotations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithAdditionalAnnotations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})" />
      <MemberSignature Language="VB.NET" Value="Public Function WithAdditionalAnnotations (annotations As IEnumerable(Of SyntaxAnnotation)) As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.WithAdditionalAnnotations : seq&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt; -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrToken.WithAdditionalAnnotations annotations" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken WithAdditionalAnnotations(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxAnnotation ^&gt; ^ annotations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotations" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt;" />
      </Parameters>
      <Docs>
        <param name="annotations">To be added.</param>
        <summary>
            Creates a new node or token identical to this one with the specified annotations.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithLeadingTrivia">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithLeadingTrivia (params Microsoft.CodeAnalysis.SyntaxTrivia[] trivia);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken WithLeadingTrivia(valuetype Microsoft.CodeAnalysis.SyntaxTrivia[] trivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithLeadingTrivia(Microsoft.CodeAnalysis.SyntaxTrivia[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WithLeadingTrivia (ParamArray trivia As SyntaxTrivia()) As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.WithLeadingTrivia : Microsoft.CodeAnalysis.SyntaxTrivia[] -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrToken.WithLeadingTrivia trivia" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken WithLeadingTrivia(... cli::array &lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ trivia);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trivia">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithLeadingTrivia">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithLeadingTrivia (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken WithLeadingTrivia(class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithLeadingTrivia(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
      <MemberSignature Language="VB.NET" Value="Public Function WithLeadingTrivia (trivia As IEnumerable(Of SyntaxTrivia)) As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.WithLeadingTrivia : seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrToken.WithLeadingTrivia trivia" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken WithLeadingTrivia(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ trivia);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
      </Parameters>
      <Docs>
        <param name="trivia">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithoutAnnotations">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithoutAnnotations (params Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken WithoutAnnotations(class Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithoutAnnotations(Microsoft.CodeAnalysis.SyntaxAnnotation[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WithoutAnnotations (ParamArray annotations As SyntaxAnnotation()) As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.WithoutAnnotations : Microsoft.CodeAnalysis.SyntaxAnnotation[] -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrToken.WithoutAnnotations annotations" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken WithoutAnnotations(... cli::array &lt;Microsoft::CodeAnalysis::SyntaxAnnotation ^&gt; ^ annotations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotations" Type="Microsoft.CodeAnalysis.SyntaxAnnotation[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="annotations">To be added.</param>
        <summary>
            Creates a new node or token identical to this one without the specified annotations.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithoutAnnotations">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithoutAnnotations (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt; annotations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken WithoutAnnotations(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxAnnotation&gt; annotations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithoutAnnotations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})" />
      <MemberSignature Language="VB.NET" Value="Public Function WithoutAnnotations (annotations As IEnumerable(Of SyntaxAnnotation)) As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.WithoutAnnotations : seq&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt; -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrToken.WithoutAnnotations annotations" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken WithoutAnnotations(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxAnnotation ^&gt; ^ annotations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotations" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt;" />
      </Parameters>
      <Docs>
        <param name="annotations">To be added.</param>
        <summary>
            Creates a new node or token identical to this one without the specified annotations.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithoutAnnotations">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithoutAnnotations (string annotationKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken WithoutAnnotations(string annotationKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithoutAnnotations(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WithoutAnnotations (annotationKind As String) As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.WithoutAnnotations : string -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrToken.WithoutAnnotations annotationKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken WithoutAnnotations(System::String ^ annotationKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationKind" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="annotationKind">To be added.</param>
        <summary>
            Creates a new node or token identical to this one without annotations of the specified kind.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithTrailingTrivia">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithTrailingTrivia (params Microsoft.CodeAnalysis.SyntaxTrivia[] trivia);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken WithTrailingTrivia(valuetype Microsoft.CodeAnalysis.SyntaxTrivia[] trivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithTrailingTrivia(Microsoft.CodeAnalysis.SyntaxTrivia[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WithTrailingTrivia (ParamArray trivia As SyntaxTrivia()) As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.WithTrailingTrivia : Microsoft.CodeAnalysis.SyntaxTrivia[] -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrToken.WithTrailingTrivia trivia" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken WithTrailingTrivia(... cli::array &lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ trivia);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trivia">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithTrailingTrivia">
      <MemberSignature Language="C#" Value="public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithTrailingTrivia (System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken WithTrailingTrivia(class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WithTrailingTrivia(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
      <MemberSignature Language="VB.NET" Value="Public Function WithTrailingTrivia (trivia As IEnumerable(Of SyntaxTrivia)) As SyntaxNodeOrToken" />
      <MemberSignature Language="F#" Value="member this.WithTrailingTrivia : seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; Microsoft.CodeAnalysis.SyntaxNodeOrToken" Usage="syntaxNodeOrToken.WithTrailingTrivia trivia" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::CodeAnalysis::SyntaxNodeOrToken WithTrailingTrivia(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ trivia);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.CodeAnalysis.SyntaxNodeOrToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
      </Parameters>
      <Docs>
        <param name="trivia">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public void WriteTo (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteTo(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeOrToken.WriteTo(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteTo (writer As TextWriter)" />
      <MemberSignature Language="F#" Value="member this.WriteTo : System.IO.TextWriter -&gt; unit" Usage="syntaxNodeOrToken.WriteTo writer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteTo(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.CodeAnalysis</AssemblyName>
        <AssemblyVersion>2.6.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <summary>
            Writes the full text of this node or token to the specified TextWriter.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>