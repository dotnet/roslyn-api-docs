<Overview>
  <Assemblies>
    <Assembly Name="Microsoft.CodeAnalysis.CSharp" Version="2.9.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 b5 fc 90 e7 02 7f 67 87 1e 77 3a 8f de 89 38 c8 1d d4 02 ba 65 b9 20 1d 60 59 3e 96 c4 92 65 1e 88 9c c1 3f 14 15 eb b5 3f ac 11 31 ae 0b d3 33 c5 ee 60 21 67 2d 97 18 ea 31 a8 ae bd 0d a0 07 2f 25 d8 7d ba 6f c9 0f fd 59 8e d4 da 35 e4 4c 39 8c 45 43 07 e8 e3 3b 84 26 14 3d ae c9 f5 96 83 6f 97 c8 f7 47 50 e5 97 5c 64 e2 18 9f 45 de f4 6b 2a 2b 12 47 ad c3 65 2b f5 c3 08 05 5d a9 ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.CodeAnalysis.CommitHash("958f2354c4d83dbb0e7723d0a8079a0dfbc33f25")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("Â© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("2.9.0.63208")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("2.9.0-beta8-63208-01")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyMetadata("Serviceable", "True")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.ExpressionEvaluator.ExpressionCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("csc, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("csi, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Scripting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.InteractiveEditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CompilerServer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("VBCSCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("VBCSCompilerPortable, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CompilerServer.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Emit.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.WinRT.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.EnC.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Semantic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Symbol.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Syntax.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Test.Utilities.Desktop, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.ExpressionEvaluator.CSharp.ExpressionCompiler.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities.Desktop, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities.FX45, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Scripting.Destkop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Scripting.Desktop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.InteractiveHost.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.CSharp.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor2.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.CodeAnalysis.CSharp.Workspaces" Version="2.9.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 b5 fc 90 e7 02 7f 67 87 1e 77 3a 8f de 89 38 c8 1d d4 02 ba 65 b9 20 1d 60 59 3e 96 c4 92 65 1e 88 9c c1 3f 14 15 eb b5 3f ac 11 31 ae 0b d3 33 c5 ee 60 21 67 2d 97 18 ea 31 a8 ae bd 0d a0 07 2f 25 d8 7d ba 6f c9 0f fd 59 8e d4 da 35 e4 4c 39 8c 45 43 07 e8 e3 3b 84 26 14 3d ae c9 f5 96 83 6f 97 c8 f7 47 50 e5 97 5c 64 e2 18 9f 45 de f4 6b 2a 2b 12 47 ad c3 65 2b f5 c3 08 05 5d a9 ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("Â© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("2.9.0.63208")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("2.9.0-beta8-63208-01")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyMetadata("Serviceable", "True")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.EditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Features, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.CSharp, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.InteractiveEditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.CSharp.Repl, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Hosting.Diagnostics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.InteractiveWindow.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.CSharp.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.CSharp2.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor2.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.CSharp.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.CSharp.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Services.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Test.Utilities2, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Next.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.CSharpBinding, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.CSharpBinding.Tests, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.Completion.Tests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.CodeAnalysis" Version="2.9.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 b5 fc 90 e7 02 7f 67 87 1e 77 3a 8f de 89 38 c8 1d d4 02 ba 65 b9 20 1d 60 59 3e 96 c4 92 65 1e 88 9c c1 3f 14 15 eb b5 3f ac 11 31 ae 0b d3 33 c5 ee 60 21 67 2d 97 18 ea 31 a8 ae bd 0d a0 07 2f 25 d8 7d ba 6f c9 0f fd 59 8e d4 da 35 e4 4c 39 8c 45 43 07 e8 e3 3b 84 26 14 3d ae c9 f5 96 83 6f 97 c8 f7 47 50 e5 97 5c 64 e2 18 9f 45 de f4 6b 2a 2b 12 47 ad c3 65 2b f5 c3 08 05 5d a9 ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("Â© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("2.9.0.63208")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("2.9.0-beta8-63208-01")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyMetadata("Serviceable", "True")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.ExpressionEvaluator.ExpressionCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.ExpressionEvaluator.ExpressionCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.ExpressionEvaluator.ExpressionCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("csc, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("csi, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Scripting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Scripting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.Scripting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("vbc, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("vbi, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CompilerServer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.Build.Tasks.CodeAnalysis, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("VBCSCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("VBCSCompilerPortable, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Emit.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.WinRT.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.EnC.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Semantic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Symbol.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Syntax.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CSharp.Test.Utilities.Desktop, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Emit.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.EnC.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.IOperation.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Semantic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Symbol.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Syntax.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.DebuggerVisualizers, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Diagnostics.Analyzers.FxCop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Diagnostics.Analyzers.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Diagnostics.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.ExpressionEvaluator.CSharp.ExpressionCompiler.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.ExpressionEvaluator.VisualBasic.ExpressionCompiler.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.ExpressionEvaluator.ExpressionCompiler.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.InteractiveHost.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Scripting.Desktop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Scripting.Desktop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.Scripting.Desktop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities.CoreClr, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities.Desktop, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities.FX45, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.PdbUtilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.CompilerServer.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("DynamicProxyGenAssembly2, PublicKey=0024000004800000940000000602000000240000525341310004000001000100c547cac37abd99c8db225ef2f6c8a3602f3b3606cc9891605d02baa56104f4cfc0734aa39b93bf7852f7d9266654753cc297e7d2edfe0bac1cdcf9f717241550e0a7b191195b7667bb4f64bcb8e2121380fd1d9d46ad2d92d2d15605093924cceaf74c4861eff62abf69b9291ed0a340e113be11e6a7d3113e92484cf7045cc7")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.CodeAnalysis.VisualBasic" Version="2.9.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 b5 fc 90 e7 02 7f 67 87 1e 77 3a 8f de 89 38 c8 1d d4 02 ba 65 b9 20 1d 60 59 3e 96 c4 92 65 1e 88 9c c1 3f 14 15 eb b5 3f ac 11 31 ae 0b d3 33 c5 ee 60 21 67 2d 97 18 ea 31 a8 ae bd 0d a0 07 2f 25 d8 7d ba 6f c9 0f fd 59 8e d4 da 35 e4 4c 39 8c 45 43 07 e8 e3 3b 84 26 14 3d ae c9 f5 96 83 6f 97 c8 f7 47 50 e5 97 5c 64 e2 18 9f 45 de f4 6b 2a 2b 12 47 ad c3 65 2b f5 c3 08 05 5d a9 ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.CodeAnalysis.CommitHash("958f2354c4d83dbb0e7723d0a8079a0dfbc33f25")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("Â© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("2.9.0.63208")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("2.9.0-beta8-63208-01")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyMetadata("Serviceable", "True")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.ExpressionEvaluator.ExpressionCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.Scripting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.InteractiveEditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("vbc, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("vbi, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CompilerServer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("VBCSCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("VBCSCompilerPortable, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Emit.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.IOperation.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Semantic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Symbol.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Syntax.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Compilers.VisualBasic.Test.Utilities.Desktop, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.ExpressionEvaluator.VisualBasic.ExpressionCompiler.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.ExpressionEvaluator.ExpressionCompiler.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities.Desktop, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities.FX45, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Scripting.Desktop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.Scripting.Desktop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Services.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.VisualBasic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor2.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.CodeAnalysis.VisualBasic.Workspaces" Version="2.9.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 b5 fc 90 e7 02 7f 67 87 1e 77 3a 8f de 89 38 c8 1d d4 02 ba 65 b9 20 1d 60 59 3e 96 c4 92 65 1e 88 9c c1 3f 14 15 eb b5 3f ac 11 31 ae 0b d3 33 c5 ee 60 21 67 2d 97 18 ea 31 a8 ae bd 0d a0 07 2f 25 d8 7d ba 6f c9 0f fd 59 8e d4 da 35 e4 4c 39 8c 45 43 07 e8 e3 3b 84 26 14 3d ae c9 f5 96 83 6f 97 c8 f7 47 50 e5 97 5c 64 e2 18 9f 45 de f4 6b 2a 2b 12 47 ad c3 65 2b f5 c3 08 05 5d a9 ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("Â© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("2.9.0.63208")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("2.9.0-beta8-63208-01")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyMetadata("Serviceable", "True")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.EditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.Features, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.VisualBasic, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.InteractiveEditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.VisualBasic.Repl, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Hosting.Diagnostics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Test.Utilities2, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor2.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.VisualBasic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.VisualBasic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Services.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Test.Utilities2, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.VBNetBinding.Tests, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.CodeAnalysis.Workspaces.Desktop" Version="2.9.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 b5 fc 90 e7 02 7f 67 87 1e 77 3a 8f de 89 38 c8 1d d4 02 ba 65 b9 20 1d 60 59 3e 96 c4 92 65 1e 88 9c c1 3f 14 15 eb b5 3f ac 11 31 ae 0b d3 33 c5 ee 60 21 67 2d 97 18 ea 31 a8 ae bd 0d a0 07 2f 25 d8 7d ba 6f c9 0f fd 59 8e d4 da 35 e4 4c 39 8c 45 43 07 e8 e3 3b 84 26 14 3d ae c9 f5 96 83 6f 97 c8 f7 47 50 e5 97 5c 64 e2 18 9f 45 de f4 6b 2a 2b 12 47 ad c3 65 2b f5 c3 08 05 5d a9 ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("Â© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("2.9.0.63208")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("2.9.0-beta8-63208-01")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.EditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Features, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.EditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.CSharp, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.Implementation, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.Razor.RemoteClient, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.SolutionExplorer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.VisualBasic, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.InteractiveServices, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.InteractiveFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.InteractiveEditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Remote.Workspaces, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Remote.Razor.ServiceHub, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Remote.ServiceHub, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Hosting.Diagnostics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Setup, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.DiagnosticsWindow, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.RemoteHostClientMock, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor2.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.CSharp.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.VisualBasic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Test.Utilities2, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.UnitTests.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.CSharp.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Services.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Test.Utilities2, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RoslynETAHost, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RoslynTaoActions, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("DynamicProxyGenAssembly2, PublicKey=0024000004800000940000000602000000240000525341310004000001000100c547cac37abd99c8db225ef2f6c8a3602f3b3606cc9891605d02baa56104f4cfc0734aa39b93bf7852f7d9266654753cc297e7d2edfe0bac1cdcf9f717241550e0a7b191195b7667bb4f64bcb8e2121380fd1d9d46ad2d92d2d15605093924cceaf74c4861eff62abf69b9291ed0a340e113be11e6a7d3113e92484cf7045cc7")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.Ide, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.Refactoring, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.CSharpBinding, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.VBNetBinding, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.Ide.Tests, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.Refactoring.Tests, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.CSharpBinding.Tests, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.VBNetBinding.Tests, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETFramework,Version=v4.6", FrameworkDisplayName=".NET Framework 4.6")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
    <Assembly Name="Microsoft.CodeAnalysis.Workspaces" Version="2.9.0.0">
      <AssemblyPublicKey>[00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00 b5 fc 90 e7 02 7f 67 87 1e 77 3a 8f de 89 38 c8 1d d4 02 ba 65 b9 20 1d 60 59 3e 96 c4 92 65 1e 88 9c c1 3f 14 15 eb b5 3f ac 11 31 ae 0b d3 33 c5 ee 60 21 67 2d 97 18 ea 31 a8 ae bd 0d a0 07 2f 25 d8 7d ba 6f c9 0f fd 59 8e d4 da 35 e4 4c 39 8c 45 43 07 e8 e3 3b 84 26 14 3d ae c9 f5 96 83 6f 97 c8 f7 47 50 e5 97 5c 64 e2 18 9f 45 de f4 6b 2a 2b 12 47 ad c3 65 2b f5 c3 08 05 5d a9 ]</AssemblyPublicKey>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute+DebuggingModes.IgnoreSymbolStoreSequencePoints)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCompany("Microsoft Corporation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyCopyright("Â© Microsoft Corporation. All rights reserved.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyFileVersion("2.9.0.63208")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyInformationalVersion("2.9.0-beta8-63208-01")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Reflection.AssemblyMetadata("Serviceable", "True")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.CompilationRelaxations(8)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("csi, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.EditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Features, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.InteractiveEditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Workspaces, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.EditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.EditorFeatures.Text, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.EditorFeatures.Wpf, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Features, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.InteractiveEditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.InteractiveFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.LiveUnitTesting.BuildManager, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.LiveUnitTesting.BuildManager.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.LiveUnitTesting.Orchestrator, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.LiveUnitTesting.Orchestrator.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.LiveUnitTesting.Test.Utilities, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Remote.Razor.ServiceHub, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Remote.ServiceHub, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Remote.Workspaces, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.UnitTesting.SourceBasedTestDiscovery, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.UnitTesting.SourceBasedTestDiscovery.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.InteractiveEditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.EditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.Features, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.VisualBasic.Workspaces, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Workspaces.Desktop, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Workspaces.MSBuild, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.CSharp.Repl, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.InteractiveServices, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.CSharp, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.Implementation, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.Razor.RemoteClient, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.SolutionExplorer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.VisualBasic, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.Xaml, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.VisualBasic.Repl, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Hosting.Diagnostics, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Setup, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.DiagnosticsWindow, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.RemoteHostClientMock, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Editor.UI.Wpf, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Workspaces.MSBuild.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.CSharp.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor2.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.VisualBasic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Test.Utilities2, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.UnitTests.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.CSharp.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.VisualBasic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.CSharp.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Closed.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.IntegrationTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.IntegrationTest.Setup, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.IntegrationTest.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Next.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Services.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.VisualStudio.Test.Utilities2, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RoslynETAHost, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("RoslynTaoActions, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.TypeScript.EditorFeatures, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.TypeScript, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Roslyn.Services.Editor.TypeScript.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.Remote, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.Remote.15.7, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.Remote.15.8, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.Remote.CSharp, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.Remote.CSharp.15.7, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.LanguageServices.Remote.CSharp.15.8, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.Test.Apex.VisualStudio, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("DynamicProxyGenAssembly2, PublicKey=0024000004800000940000000602000000240000525341310004000001000100c547cac37abd99c8db225ef2f6c8a3602f3b3606cc9891605d02baa56104f4cfc0734aa39b93bf7852f7d9266654753cc297e7d2edfe0bac1cdcf9f717241550e0a7b191195b7667bb4f64bcb8e2121380fd1d9d46ad2d92d2d15605093924cceaf74c4861eff62abf69b9291ed0a340e113be11e6a7d3113e92484cf7045cc7")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.Ide, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.Refactoring, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.CSharpBinding, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.VBNetBinding, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.Ide.Tests, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.Refactoring.Tests, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.CSharpBinding.Tests, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("MonoDevelop.VBNetBinding.Tests, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Xamarin.Ide, PublicKey=002400000c800000940000000602000000240000525341310004000001000100e1290d741888d13312c0cd1f72bb843236573c80158a286f11bb98de5ee8acc3142c9c97b472684e521ae45125d7414558f2e70ac56504f3e8fe80830da2cdb1cda8504e8d196150d05a214609234694ec0ebf4b37fc7537e09d877c3e65000f7467fa3adb6e62c82b10ada1af4a83651556c7d949959817fed97480839dd39b")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.VisualStudio.Completion.Tests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName="")</AttributeName>
        </Attribute>
      </Attributes>
    </Assembly>
  </Assemblies>
  <Remarks>To be added.</Remarks>
  <Copyright>To be added.</Copyright>
  <Types>
    <Namespace Name="Microsoft.CodeAnalysis">
      <Type Name="Accessibility" Kind="Enumeration" />
      <Type Name="AdditionalText" Kind="Class" />
      <Type Name="AdhocWorkspace" Kind="Class" />
      <Type Name="AnnotationExtensions" Kind="Class" />
      <Type Name="ApplyChangesKind" Kind="Enumeration" />
      <Type Name="AssemblyIdentity" Kind="Class" />
      <Type Name="AssemblyIdentityComparer" Kind="Class" />
      <Type Name="AssemblyIdentityComparer+ComparisonResult" Kind="Enumeration" />
      <Type Name="AssemblyIdentityParts" Kind="Enumeration" />
      <Type Name="AssemblyMetadata" Kind="Class" />
      <Type Name="AttributeData" Kind="Class" />
      <Type Name="CandidateReason" Kind="Enumeration" />
      <Type Name="CaseInsensitiveComparison" Kind="Class" />
      <Type Name="ChildSyntaxList" Kind="Structure" />
      <Type Name="ChildSyntaxList+Enumerator" Kind="Structure" />
      <Type Name="ChildSyntaxList+Reversed" Kind="Structure" />
      <Type Name="ChildSyntaxList+Reversed+Enumerator" Kind="Structure" />
      <Type Name="CommandLineAnalyzerReference" Kind="Structure" />
      <Type Name="CommandLineArguments" Kind="Class" />
      <Type Name="CommandLineParser" Kind="Class" />
      <Type Name="CommandLineProject" Kind="Class" />
      <Type Name="CommandLineReference" Kind="Structure" />
      <Type Name="CommandLineSourceFile" Kind="Structure" />
      <Type Name="Compilation" Kind="Class" />
      <Type Name="CompilationOptions" Kind="Class" />
      <Type Name="CompilationReference" Kind="Class" />
      <Type Name="ControlFlowAnalysis" Kind="Class" />
      <Type Name="CSharpExtensions" Kind="Class" />
      <Type Name="CustomModifier" Kind="Class" />
      <Type Name="DataFlowAnalysis" Kind="Class" />
      <Type Name="DesktopAssemblyIdentityComparer" Kind="Class" />
      <Type Name="DesktopStrongNameProvider" Kind="Class" />
      <Type Name="Diagnostic" Kind="Class" />
      <Type Name="DiagnosticDescriptor" Kind="Class" />
      <Type Name="DiagnosticFormatter" Kind="Class" />
      <Type Name="DiagnosticSeverity" Kind="Enumeration" />
      <Type Name="DllImportData" Kind="Class" />
      <Type Name="Document" Kind="Class" />
      <Type Name="DocumentActiveContextChangedEventArgs" Kind="Class" />
      <Type Name="DocumentationCommentId" Kind="Class" />
      <Type Name="DocumentationMode" Kind="Enumeration" />
      <Type Name="DocumentationProvider" Kind="Class" />
      <Type Name="DocumentDiagnostic" Kind="Class" />
      <Type Name="DocumentEventArgs" Kind="Class" />
      <Type Name="DocumentId" Kind="Class" />
      <Type Name="DocumentInfo" Kind="Class" />
      <Type Name="EmbeddedText" Kind="Class" />
      <Type Name="ExtensionOrderAttribute" Kind="Class" />
      <Type Name="FileLinePositionSpan" Kind="Structure" />
      <Type Name="FileSystemExtensions" Kind="Class" />
      <Type Name="FileTextLoader" Kind="Class" />
      <Type Name="IAliasSymbol" Kind="Interface" />
      <Type Name="IAnalyzerAssemblyLoader" Kind="Interface" />
      <Type Name="IArrayTypeSymbol" Kind="Interface" />
      <Type Name="IAssemblySymbol" Kind="Interface" />
      <Type Name="ICompilationUnitSyntax" Kind="Interface" />
      <Type Name="IDiscardSymbol" Kind="Interface" />
      <Type Name="IDynamicTypeSymbol" Kind="Interface" />
      <Type Name="IErrorTypeSymbol" Kind="Interface" />
      <Type Name="IEventSymbol" Kind="Interface" />
      <Type Name="IFieldSymbol" Kind="Interface" />
      <Type Name="ILabelSymbol" Kind="Interface" />
      <Type Name="ILocalSymbol" Kind="Interface" />
      <Type Name="IMethodSymbol" Kind="Interface" />
      <Type Name="IModuleSymbol" Kind="Interface" />
      <Type Name="INamedTypeSymbol" Kind="Interface" />
      <Type Name="INamespaceOrTypeSymbol" Kind="Interface" />
      <Type Name="INamespaceSymbol" Kind="Interface" />
      <Type Name="IOperation" Kind="Interface" />
      <Type Name="IParameterSymbol" Kind="Interface" />
      <Type Name="IPointerTypeSymbol" Kind="Interface" />
      <Type Name="IPreprocessingSymbol" Kind="Interface" />
      <Type Name="IPropertySymbol" Kind="Interface" />
      <Type Name="IRangeVariableSymbol" Kind="Interface" />
      <Type Name="ISkippedTokensTriviaSyntax" Kind="Interface" />
      <Type Name="ISourceAssemblySymbol" Kind="Interface" />
      <Type Name="IStructuredTriviaSyntax" Kind="Interface" />
      <Type Name="ISymbol" Kind="Interface" />
      <Type Name="ISymbolExtensions" Kind="Class" />
      <Type Name="ITypeParameterSymbol" Kind="Interface" />
      <Type Name="ITypeSymbol" Kind="Interface" />
      <Type Name="LanguageNames" Kind="Class" />
      <Type Name="LineVisibility" Kind="Enumeration" />
      <Type Name="LocalizableResourceString" Kind="Class" />
      <Type Name="LocalizableString" Kind="Class" />
      <Type Name="Location" Kind="Class" />
      <Type Name="LocationKind" Kind="Enumeration" />
      <Type Name="Metadata" Kind="Class" />
      <Type Name="MetadataId" Kind="Class" />
      <Type Name="MetadataImageKind" Kind="Enumeration" />
      <Type Name="MetadataImportOptions" Kind="Enumeration" />
      <Type Name="MetadataReference" Kind="Class" />
      <Type Name="MetadataReferenceProperties" Kind="Structure" />
      <Type Name="MetadataReferenceResolver" Kind="Class" />
      <Type Name="MethodKind" Kind="Enumeration" />
      <Type Name="ModelExtensions" Kind="Class" />
      <Type Name="ModuleMetadata" Kind="Class" />
      <Type Name="NamespaceKind" Kind="Enumeration" />
      <Type Name="OperationKind" Kind="Enumeration" />
      <Type Name="OptimizationLevel" Kind="Enumeration" />
      <Type Name="Optional`1" DisplayName="Optional&lt;T&gt;" Kind="Structure" />
      <Type Name="OutputKind" Kind="Enumeration" />
      <Type Name="ParseOptions" Kind="Class" />
      <Type Name="Platform" Kind="Enumeration" />
      <Type Name="PortableExecutableReference" Kind="Class" />
      <Type Name="PreprocessingSymbolInfo" Kind="Structure" />
      <Type Name="PreservationMode" Kind="Enumeration" />
      <Type Name="Project" Kind="Class" />
      <Type Name="ProjectChanges" Kind="Structure" />
      <Type Name="ProjectDependencyGraph" Kind="Class" />
      <Type Name="ProjectDiagnostic" Kind="Class" />
      <Type Name="ProjectId" Kind="Class" />
      <Type Name="ProjectInfo" Kind="Class" />
      <Type Name="ProjectReference" Kind="Class" />
      <Type Name="RefKind" Kind="Enumeration" />
      <Type Name="ReportDiagnostic" Kind="Enumeration" />
      <Type Name="ResourceDescription" Kind="Class" />
      <Type Name="RuleSet" Kind="Class" />
      <Type Name="RuleSetInclude" Kind="Class" />
      <Type Name="ScriptCompilationInfo" Kind="Class" />
      <Type Name="SemanticModel" Kind="Class" />
      <Type Name="SeparatedSyntaxList`1" DisplayName="SeparatedSyntaxList&lt;TNode&gt;" Kind="Structure" />
      <Type Name="SeparatedSyntaxList`1+Enumerator" DisplayName="SeparatedSyntaxList&lt;TNode&gt;+Enumerator" Kind="Structure" />
      <Type Name="Solution" Kind="Class" />
      <Type Name="SolutionChanges" Kind="Structure" />
      <Type Name="SolutionId" Kind="Class" />
      <Type Name="SolutionInfo" Kind="Class" />
      <Type Name="SourceCodeKind" Kind="Enumeration" />
      <Type Name="SourceFileResolver" Kind="Class" />
      <Type Name="SourceReferenceResolver" Kind="Class" />
      <Type Name="SpecialType" Kind="Enumeration" />
      <Type Name="SpeculativeBindingOption" Kind="Enumeration" />
      <Type Name="StrongNameProvider" Kind="Class" />
      <Type Name="SubsystemVersion" Kind="Structure" />
      <Type Name="SymbolDisplayDelegateStyle" Kind="Enumeration" />
      <Type Name="SymbolDisplayExtensionMethodStyle" Kind="Enumeration" />
      <Type Name="SymbolDisplayExtensions" Kind="Class" />
      <Type Name="SymbolDisplayFormat" Kind="Class" />
      <Type Name="SymbolDisplayGenericsOptions" Kind="Enumeration" />
      <Type Name="SymbolDisplayGlobalNamespaceStyle" Kind="Enumeration" />
      <Type Name="SymbolDisplayKindOptions" Kind="Enumeration" />
      <Type Name="SymbolDisplayLocalOptions" Kind="Enumeration" />
      <Type Name="SymbolDisplayMemberOptions" Kind="Enumeration" />
      <Type Name="SymbolDisplayMiscellaneousOptions" Kind="Enumeration" />
      <Type Name="SymbolDisplayParameterOptions" Kind="Enumeration" />
      <Type Name="SymbolDisplayPart" Kind="Structure" />
      <Type Name="SymbolDisplayPartKind" Kind="Enumeration" />
      <Type Name="SymbolDisplayPropertyStyle" Kind="Enumeration" />
      <Type Name="SymbolDisplayTypeQualificationStyle" Kind="Enumeration" />
      <Type Name="SymbolFilter" Kind="Enumeration" />
      <Type Name="SymbolInfo" Kind="Structure" />
      <Type Name="SymbolKind" Kind="Enumeration" />
      <Type Name="SymbolVisitor" Kind="Class" />
      <Type Name="SymbolVisitor`1" DisplayName="SymbolVisitor&lt;TResult&gt;" Kind="Class" />
      <Type Name="SyntaxAnnotation" Kind="Class" />
      <Type Name="SyntaxList`1" DisplayName="SyntaxList&lt;TNode&gt;" Kind="Structure" />
      <Type Name="SyntaxList`1+Enumerator" DisplayName="SyntaxList&lt;TNode&gt;+Enumerator" Kind="Structure" />
      <Type Name="SyntaxNode" Kind="Class" />
      <Type Name="SyntaxNodeExtensions" Kind="Class" />
      <Type Name="SyntaxNodeOrToken" Kind="Structure" />
      <Type Name="SyntaxNodeOrTokenList" Kind="Structure" />
      <Type Name="SyntaxNodeOrTokenList+Enumerator" Kind="Structure" />
      <Type Name="SyntaxReference" Kind="Class" />
      <Type Name="SyntaxRemoveOptions" Kind="Enumeration" />
      <Type Name="SyntaxToken" Kind="Structure" />
      <Type Name="SyntaxTokenList" Kind="Structure" />
      <Type Name="SyntaxTokenList+Enumerator" Kind="Structure" />
      <Type Name="SyntaxTokenList+Reversed" Kind="Structure" />
      <Type Name="SyntaxTokenList+Reversed+Enumerator" Kind="Structure" />
      <Type Name="SyntaxTree" Kind="Class" />
      <Type Name="SyntaxTrivia" Kind="Structure" />
      <Type Name="SyntaxTriviaList" Kind="Structure" />
      <Type Name="SyntaxTriviaList+Enumerator" Kind="Structure" />
      <Type Name="SyntaxTriviaList+Reversed" Kind="Structure" />
      <Type Name="SyntaxTriviaList+Reversed+Enumerator" Kind="Structure" />
      <Type Name="SyntaxWalker" Kind="Class" />
      <Type Name="SyntaxWalkerDepth" Kind="Enumeration" />
      <Type Name="TextAndVersion" Kind="Class" />
      <Type Name="TextDocument" Kind="Class" />
      <Type Name="TextLoader" Kind="Class" />
      <Type Name="TypedConstant" Kind="Structure" />
      <Type Name="TypedConstantKind" Kind="Enumeration" />
      <Type Name="TypeInfo" Kind="Structure" />
      <Type Name="TypeKind" Kind="Enumeration" />
      <Type Name="TypeParameterKind" Kind="Enumeration" />
      <Type Name="UnresolvedMetadataReference" Kind="Class" />
      <Type Name="VarianceKind" Kind="Enumeration" />
      <Type Name="VersionStamp" Kind="Structure" />
      <Type Name="VisualBasicExtensions" Kind="Class" />
      <Type Name="WellKnownDiagnosticTags" Kind="Class" />
      <Type Name="WellKnownMemberNames" Kind="Class" />
      <Type Name="Workspace" Kind="Class" />
      <Type Name="WorkspaceChangeEventArgs" Kind="Class" />
      <Type Name="WorkspaceChangeKind" Kind="Enumeration" />
      <Type Name="WorkspaceDiagnostic" Kind="Class" />
      <Type Name="WorkspaceDiagnosticEventArgs" Kind="Class" />
      <Type Name="WorkspaceDiagnosticKind" Kind="Enumeration" />
      <Type Name="WorkspaceKind" Kind="Class" />
      <Type Name="WorkspaceRegistration" Kind="Class" />
      <Type Name="XmlDocumentationProvider" Kind="Class" />
      <Type Name="XmlFileResolver" Kind="Class" />
      <Type Name="XmlReferenceResolver" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Classification">
      <Type Name="ClassificationTypeNames" Kind="Class" />
      <Type Name="ClassifiedSpan" Kind="Structure" />
      <Type Name="Classifier" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.CodeActions">
      <Type Name="ApplyChangesOperation" Kind="Class" />
      <Type Name="CodeAction" Kind="Class" />
      <Type Name="CodeActionOperation" Kind="Class" />
      <Type Name="CodeActionWithOptions" Kind="Class" />
      <Type Name="ConflictAnnotation" Kind="Class" />
      <Type Name="OpenDocumentOperation" Kind="Class" />
      <Type Name="PreviewOperation" Kind="Class" />
      <Type Name="RenameAnnotation" Kind="Class" />
      <Type Name="WarningAnnotation" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.CodeFixes">
      <Type Name="CodeFixContext" Kind="Structure" />
      <Type Name="CodeFixProvider" Kind="Class" />
      <Type Name="ExportCodeFixProviderAttribute" Kind="Class" />
      <Type Name="FixAllContext" Kind="Class" />
      <Type Name="FixAllContext+DiagnosticProvider" Kind="Class" />
      <Type Name="FixAllProvider" Kind="Class" />
      <Type Name="FixAllScope" Kind="Enumeration" />
      <Type Name="WellKnownFixAllProviders" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.CodeRefactorings">
      <Type Name="CodeRefactoringContext" Kind="Structure" />
      <Type Name="CodeRefactoringProvider" Kind="Class" />
      <Type Name="ExportCodeRefactoringProviderAttribute" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.CodeStyle">
      <Type Name="CodeStyleOption`1" DisplayName="CodeStyleOption&lt;T&gt;" Kind="Class" />
      <Type Name="CodeStyleOptions" Kind="Class" />
      <Type Name="NotificationOption" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.CSharp">
      <Type Name="AwaitExpressionInfo" Kind="Structure" />
      <Type Name="Conversion" Kind="Structure" />
      <Type Name="CSharpCommandLineArguments" Kind="Class" />
      <Type Name="CSharpCommandLineParser" Kind="Class" />
      <Type Name="CSharpCompilation" Kind="Class" />
      <Type Name="CSharpCompilationOptions" Kind="Class" />
      <Type Name="CSharpDiagnosticFormatter" Kind="Class" />
      <Type Name="CSharpExtensions" Kind="Class" />
      <Type Name="CSharpFileSystemExtensions" Kind="Class" />
      <Type Name="CSharpParseOptions" Kind="Class" />
      <Type Name="CSharpScriptCompilationInfo" Kind="Class" />
      <Type Name="CSharpSyntaxNode" Kind="Class" />
      <Type Name="CSharpSyntaxRewriter" Kind="Class" />
      <Type Name="CSharpSyntaxTree" Kind="Class" />
      <Type Name="CSharpSyntaxVisitor" Kind="Class" />
      <Type Name="CSharpSyntaxVisitor`1" DisplayName="CSharpSyntaxVisitor&lt;TResult&gt;" Kind="Class" />
      <Type Name="CSharpSyntaxWalker" Kind="Class" />
      <Type Name="DeconstructionInfo" Kind="Structure" />
      <Type Name="ForEachStatementInfo" Kind="Structure" />
      <Type Name="LanguageVersion" Kind="Enumeration" />
      <Type Name="LanguageVersionFacts" Kind="Class" />
      <Type Name="QueryClauseInfo" Kind="Structure" />
      <Type Name="SymbolDisplay" Kind="Class" />
      <Type Name="SyntaxExtensions" Kind="Class" />
      <Type Name="SyntaxFactory" Kind="Class" />
      <Type Name="SyntaxFacts" Kind="Class" />
      <Type Name="SyntaxKind" Kind="Enumeration" />
      <Type Name="TypedConstantExtensions" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.CSharp.Formatting">
      <Type Name="BinaryOperatorSpacingOptions" Kind="Enumeration" />
      <Type Name="CSharpFormattingOptions" Kind="Class" />
      <Type Name="LabelPositionOptions" Kind="Enumeration" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.CSharp.Syntax">
      <Type Name="AccessorDeclarationSyntax" Kind="Class" />
      <Type Name="AccessorListSyntax" Kind="Class" />
      <Type Name="AliasQualifiedNameSyntax" Kind="Class" />
      <Type Name="AnonymousFunctionExpressionSyntax" Kind="Class" />
      <Type Name="AnonymousMethodExpressionSyntax" Kind="Class" />
      <Type Name="AnonymousObjectCreationExpressionSyntax" Kind="Class" />
      <Type Name="AnonymousObjectMemberDeclaratorSyntax" Kind="Class" />
      <Type Name="ArgumentListSyntax" Kind="Class" />
      <Type Name="ArgumentSyntax" Kind="Class" />
      <Type Name="ArrayCreationExpressionSyntax" Kind="Class" />
      <Type Name="ArrayRankSpecifierSyntax" Kind="Class" />
      <Type Name="ArrayTypeSyntax" Kind="Class" />
      <Type Name="ArrowExpressionClauseSyntax" Kind="Class" />
      <Type Name="AssignmentExpressionSyntax" Kind="Class" />
      <Type Name="AttributeArgumentListSyntax" Kind="Class" />
      <Type Name="AttributeArgumentSyntax" Kind="Class" />
      <Type Name="AttributeListSyntax" Kind="Class" />
      <Type Name="AttributeSyntax" Kind="Class" />
      <Type Name="AttributeTargetSpecifierSyntax" Kind="Class" />
      <Type Name="AwaitExpressionSyntax" Kind="Class" />
      <Type Name="BadDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="BaseArgumentListSyntax" Kind="Class" />
      <Type Name="BaseCrefParameterListSyntax" Kind="Class" />
      <Type Name="BaseExpressionSyntax" Kind="Class" />
      <Type Name="BaseFieldDeclarationSyntax" Kind="Class" />
      <Type Name="BaseListSyntax" Kind="Class" />
      <Type Name="BaseMethodDeclarationSyntax" Kind="Class" />
      <Type Name="BaseParameterListSyntax" Kind="Class" />
      <Type Name="BasePropertyDeclarationSyntax" Kind="Class" />
      <Type Name="BaseTypeDeclarationSyntax" Kind="Class" />
      <Type Name="BaseTypeSyntax" Kind="Class" />
      <Type Name="BinaryExpressionSyntax" Kind="Class" />
      <Type Name="BlockSyntax" Kind="Class" />
      <Type Name="BracketedArgumentListSyntax" Kind="Class" />
      <Type Name="BracketedParameterListSyntax" Kind="Class" />
      <Type Name="BranchingDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="BreakStatementSyntax" Kind="Class" />
      <Type Name="CasePatternSwitchLabelSyntax" Kind="Class" />
      <Type Name="CaseSwitchLabelSyntax" Kind="Class" />
      <Type Name="CastExpressionSyntax" Kind="Class" />
      <Type Name="CatchClauseSyntax" Kind="Class" />
      <Type Name="CatchDeclarationSyntax" Kind="Class" />
      <Type Name="CatchFilterClauseSyntax" Kind="Class" />
      <Type Name="CheckedExpressionSyntax" Kind="Class" />
      <Type Name="CheckedStatementSyntax" Kind="Class" />
      <Type Name="ClassDeclarationSyntax" Kind="Class" />
      <Type Name="ClassOrStructConstraintSyntax" Kind="Class" />
      <Type Name="CommonForEachStatementSyntax" Kind="Class" />
      <Type Name="CompilationUnitSyntax" Kind="Class" />
      <Type Name="ConditionalAccessExpressionSyntax" Kind="Class" />
      <Type Name="ConditionalDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="ConditionalExpressionSyntax" Kind="Class" />
      <Type Name="ConstantPatternSyntax" Kind="Class" />
      <Type Name="ConstructorConstraintSyntax" Kind="Class" />
      <Type Name="ConstructorDeclarationSyntax" Kind="Class" />
      <Type Name="ConstructorInitializerSyntax" Kind="Class" />
      <Type Name="ContinueStatementSyntax" Kind="Class" />
      <Type Name="ConversionOperatorDeclarationSyntax" Kind="Class" />
      <Type Name="ConversionOperatorMemberCrefSyntax" Kind="Class" />
      <Type Name="CrefBracketedParameterListSyntax" Kind="Class" />
      <Type Name="CrefParameterListSyntax" Kind="Class" />
      <Type Name="CrefParameterSyntax" Kind="Class" />
      <Type Name="CrefSyntax" Kind="Class" />
      <Type Name="DeclarationExpressionSyntax" Kind="Class" />
      <Type Name="DeclarationPatternSyntax" Kind="Class" />
      <Type Name="DefaultExpressionSyntax" Kind="Class" />
      <Type Name="DefaultSwitchLabelSyntax" Kind="Class" />
      <Type Name="DefineDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="DelegateDeclarationSyntax" Kind="Class" />
      <Type Name="DestructorDeclarationSyntax" Kind="Class" />
      <Type Name="DirectiveTriviaSyntax" Kind="Class" />
      <Type Name="DiscardDesignationSyntax" Kind="Class" />
      <Type Name="DocumentationCommentTriviaSyntax" Kind="Class" />
      <Type Name="DoStatementSyntax" Kind="Class" />
      <Type Name="ElementAccessExpressionSyntax" Kind="Class" />
      <Type Name="ElementBindingExpressionSyntax" Kind="Class" />
      <Type Name="ElifDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="ElseClauseSyntax" Kind="Class" />
      <Type Name="ElseDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EmptyStatementSyntax" Kind="Class" />
      <Type Name="EndIfDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EndRegionDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EnumDeclarationSyntax" Kind="Class" />
      <Type Name="EnumMemberDeclarationSyntax" Kind="Class" />
      <Type Name="EqualsValueClauseSyntax" Kind="Class" />
      <Type Name="ErrorDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EventDeclarationSyntax" Kind="Class" />
      <Type Name="EventFieldDeclarationSyntax" Kind="Class" />
      <Type Name="ExplicitInterfaceSpecifierSyntax" Kind="Class" />
      <Type Name="ExpressionStatementSyntax" Kind="Class" />
      <Type Name="ExpressionSyntax" Kind="Class" />
      <Type Name="ExternAliasDirectiveSyntax" Kind="Class" />
      <Type Name="FieldDeclarationSyntax" Kind="Class" />
      <Type Name="FinallyClauseSyntax" Kind="Class" />
      <Type Name="FixedStatementSyntax" Kind="Class" />
      <Type Name="ForEachStatementSyntax" Kind="Class" />
      <Type Name="ForEachVariableStatementSyntax" Kind="Class" />
      <Type Name="ForStatementSyntax" Kind="Class" />
      <Type Name="FromClauseSyntax" Kind="Class" />
      <Type Name="GenericNameSyntax" Kind="Class" />
      <Type Name="GlobalStatementSyntax" Kind="Class" />
      <Type Name="GotoStatementSyntax" Kind="Class" />
      <Type Name="GroupClauseSyntax" Kind="Class" />
      <Type Name="IdentifierNameSyntax" Kind="Class" />
      <Type Name="IfDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="IfStatementSyntax" Kind="Class" />
      <Type Name="ImplicitArrayCreationExpressionSyntax" Kind="Class" />
      <Type Name="ImplicitElementAccessSyntax" Kind="Class" />
      <Type Name="ImplicitStackAllocArrayCreationExpressionSyntax" Kind="Class" />
      <Type Name="IncompleteMemberSyntax" Kind="Class" />
      <Type Name="IndexerDeclarationSyntax" Kind="Class" />
      <Type Name="IndexerMemberCrefSyntax" Kind="Class" />
      <Type Name="InitializerExpressionSyntax" Kind="Class" />
      <Type Name="InstanceExpressionSyntax" Kind="Class" />
      <Type Name="InterfaceDeclarationSyntax" Kind="Class" />
      <Type Name="InterpolatedStringContentSyntax" Kind="Class" />
      <Type Name="InterpolatedStringExpressionSyntax" Kind="Class" />
      <Type Name="InterpolatedStringTextSyntax" Kind="Class" />
      <Type Name="InterpolationAlignmentClauseSyntax" Kind="Class" />
      <Type Name="InterpolationFormatClauseSyntax" Kind="Class" />
      <Type Name="InterpolationSyntax" Kind="Class" />
      <Type Name="InvocationExpressionSyntax" Kind="Class" />
      <Type Name="IsPatternExpressionSyntax" Kind="Class" />
      <Type Name="JoinClauseSyntax" Kind="Class" />
      <Type Name="JoinIntoClauseSyntax" Kind="Class" />
      <Type Name="LabeledStatementSyntax" Kind="Class" />
      <Type Name="LambdaExpressionSyntax" Kind="Class" />
      <Type Name="LetClauseSyntax" Kind="Class" />
      <Type Name="LineDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="LiteralExpressionSyntax" Kind="Class" />
      <Type Name="LoadDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="LocalDeclarationStatementSyntax" Kind="Class" />
      <Type Name="LocalFunctionStatementSyntax" Kind="Class" />
      <Type Name="LockStatementSyntax" Kind="Class" />
      <Type Name="MakeRefExpressionSyntax" Kind="Class" />
      <Type Name="MemberAccessExpressionSyntax" Kind="Class" />
      <Type Name="MemberBindingExpressionSyntax" Kind="Class" />
      <Type Name="MemberCrefSyntax" Kind="Class" />
      <Type Name="MemberDeclarationSyntax" Kind="Class" />
      <Type Name="MethodDeclarationSyntax" Kind="Class" />
      <Type Name="NameColonSyntax" Kind="Class" />
      <Type Name="NameEqualsSyntax" Kind="Class" />
      <Type Name="NameMemberCrefSyntax" Kind="Class" />
      <Type Name="NamespaceDeclarationSyntax" Kind="Class" />
      <Type Name="NameSyntax" Kind="Class" />
      <Type Name="NullableTypeSyntax" Kind="Class" />
      <Type Name="ObjectCreationExpressionSyntax" Kind="Class" />
      <Type Name="OmittedArraySizeExpressionSyntax" Kind="Class" />
      <Type Name="OmittedTypeArgumentSyntax" Kind="Class" />
      <Type Name="OperatorDeclarationSyntax" Kind="Class" />
      <Type Name="OperatorMemberCrefSyntax" Kind="Class" />
      <Type Name="OrderByClauseSyntax" Kind="Class" />
      <Type Name="OrderingSyntax" Kind="Class" />
      <Type Name="ParameterListSyntax" Kind="Class" />
      <Type Name="ParameterSyntax" Kind="Class" />
      <Type Name="ParenthesizedExpressionSyntax" Kind="Class" />
      <Type Name="ParenthesizedLambdaExpressionSyntax" Kind="Class" />
      <Type Name="ParenthesizedVariableDesignationSyntax" Kind="Class" />
      <Type Name="PatternSyntax" Kind="Class" />
      <Type Name="PointerTypeSyntax" Kind="Class" />
      <Type Name="PostfixUnaryExpressionSyntax" Kind="Class" />
      <Type Name="PragmaChecksumDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="PragmaWarningDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="PredefinedTypeSyntax" Kind="Class" />
      <Type Name="PrefixUnaryExpressionSyntax" Kind="Class" />
      <Type Name="PropertyDeclarationSyntax" Kind="Class" />
      <Type Name="QualifiedCrefSyntax" Kind="Class" />
      <Type Name="QualifiedNameSyntax" Kind="Class" />
      <Type Name="QueryBodySyntax" Kind="Class" />
      <Type Name="QueryClauseSyntax" Kind="Class" />
      <Type Name="QueryContinuationSyntax" Kind="Class" />
      <Type Name="QueryExpressionSyntax" Kind="Class" />
      <Type Name="ReferenceDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="RefExpressionSyntax" Kind="Class" />
      <Type Name="RefTypeExpressionSyntax" Kind="Class" />
      <Type Name="RefTypeSyntax" Kind="Class" />
      <Type Name="RefValueExpressionSyntax" Kind="Class" />
      <Type Name="RegionDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="ReturnStatementSyntax" Kind="Class" />
      <Type Name="SelectClauseSyntax" Kind="Class" />
      <Type Name="SelectOrGroupClauseSyntax" Kind="Class" />
      <Type Name="ShebangDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="SimpleBaseTypeSyntax" Kind="Class" />
      <Type Name="SimpleLambdaExpressionSyntax" Kind="Class" />
      <Type Name="SimpleNameSyntax" Kind="Class" />
      <Type Name="SingleVariableDesignationSyntax" Kind="Class" />
      <Type Name="SizeOfExpressionSyntax" Kind="Class" />
      <Type Name="SkippedTokensTriviaSyntax" Kind="Class" />
      <Type Name="StackAllocArrayCreationExpressionSyntax" Kind="Class" />
      <Type Name="StatementSyntax" Kind="Class" />
      <Type Name="StructDeclarationSyntax" Kind="Class" />
      <Type Name="StructuredTriviaSyntax" Kind="Class" />
      <Type Name="SwitchLabelSyntax" Kind="Class" />
      <Type Name="SwitchSectionSyntax" Kind="Class" />
      <Type Name="SwitchStatementSyntax" Kind="Class" />
      <Type Name="ThisExpressionSyntax" Kind="Class" />
      <Type Name="ThrowExpressionSyntax" Kind="Class" />
      <Type Name="ThrowStatementSyntax" Kind="Class" />
      <Type Name="TryStatementSyntax" Kind="Class" />
      <Type Name="TupleElementSyntax" Kind="Class" />
      <Type Name="TupleExpressionSyntax" Kind="Class" />
      <Type Name="TupleTypeSyntax" Kind="Class" />
      <Type Name="TypeArgumentListSyntax" Kind="Class" />
      <Type Name="TypeConstraintSyntax" Kind="Class" />
      <Type Name="TypeCrefSyntax" Kind="Class" />
      <Type Name="TypeDeclarationSyntax" Kind="Class" />
      <Type Name="TypeOfExpressionSyntax" Kind="Class" />
      <Type Name="TypeParameterConstraintClauseSyntax" Kind="Class" />
      <Type Name="TypeParameterConstraintSyntax" Kind="Class" />
      <Type Name="TypeParameterListSyntax" Kind="Class" />
      <Type Name="TypeParameterSyntax" Kind="Class" />
      <Type Name="TypeSyntax" Kind="Class" />
      <Type Name="UndefDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="UnsafeStatementSyntax" Kind="Class" />
      <Type Name="UsingDirectiveSyntax" Kind="Class" />
      <Type Name="UsingStatementSyntax" Kind="Class" />
      <Type Name="VariableDeclarationSyntax" Kind="Class" />
      <Type Name="VariableDeclaratorSyntax" Kind="Class" />
      <Type Name="VariableDesignationSyntax" Kind="Class" />
      <Type Name="WarningDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="WhenClauseSyntax" Kind="Class" />
      <Type Name="WhereClauseSyntax" Kind="Class" />
      <Type Name="WhileStatementSyntax" Kind="Class" />
      <Type Name="XmlAttributeSyntax" Kind="Class" />
      <Type Name="XmlCDataSectionSyntax" Kind="Class" />
      <Type Name="XmlCommentSyntax" Kind="Class" />
      <Type Name="XmlCrefAttributeSyntax" Kind="Class" />
      <Type Name="XmlElementEndTagSyntax" Kind="Class" />
      <Type Name="XmlElementStartTagSyntax" Kind="Class" />
      <Type Name="XmlElementSyntax" Kind="Class" />
      <Type Name="XmlEmptyElementSyntax" Kind="Class" />
      <Type Name="XmlNameAttributeElementKind" Kind="Enumeration" />
      <Type Name="XmlNameAttributeSyntax" Kind="Class" />
      <Type Name="XmlNameSyntax" Kind="Class" />
      <Type Name="XmlNodeSyntax" Kind="Class" />
      <Type Name="XmlPrefixSyntax" Kind="Class" />
      <Type Name="XmlProcessingInstructionSyntax" Kind="Class" />
      <Type Name="XmlTextAttributeSyntax" Kind="Class" />
      <Type Name="XmlTextSyntax" Kind="Class" />
      <Type Name="YieldStatementSyntax" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Diagnostics">
      <Type Name="AnalysisContext" Kind="Class" />
      <Type Name="AnalysisResult" Kind="Class" />
      <Type Name="AnalyzerFileReference" Kind="Class" />
      <Type Name="AnalyzerImageReference" Kind="Class" />
      <Type Name="AnalyzerLoadFailureEventArgs" Kind="Class" />
      <Type Name="AnalyzerLoadFailureEventArgs+FailureErrorCode" Kind="Enumeration" />
      <Type Name="AnalyzerOptions" Kind="Class" />
      <Type Name="AnalyzerReference" Kind="Class" />
      <Type Name="CodeBlockAnalysisContext" Kind="Structure" />
      <Type Name="CodeBlockStartAnalysisContext`1" DisplayName="CodeBlockStartAnalysisContext&lt;TLanguageKindEnum&gt;" Kind="Class" />
      <Type Name="CompilationAnalysisContext" Kind="Structure" />
      <Type Name="CompilationStartAnalysisContext" Kind="Class" />
      <Type Name="CompilationWithAnalyzers" Kind="Class" />
      <Type Name="CompilationWithAnalyzersOptions" Kind="Class" />
      <Type Name="DiagnosticAnalyzer" Kind="Class" />
      <Type Name="DiagnosticAnalyzerAttribute" Kind="Class" />
      <Type Name="DiagnosticAnalyzerExtensions" Kind="Class" />
      <Type Name="GeneratedCodeAnalysisFlags" Kind="Enumeration" />
      <Type Name="OperationAnalysisContext" Kind="Structure" />
      <Type Name="OperationBlockAnalysisContext" Kind="Structure" />
      <Type Name="OperationBlockStartAnalysisContext" Kind="Class" />
      <Type Name="SemanticModelAnalysisContext" Kind="Structure" />
      <Type Name="SourceTextValueProvider`1" DisplayName="SourceTextValueProvider&lt;TValue&gt;" Kind="Class" />
      <Type Name="SuppressionInfo" Kind="Class" />
      <Type Name="SymbolAnalysisContext" Kind="Structure" />
      <Type Name="SyntaxNodeAnalysisContext" Kind="Structure" />
      <Type Name="SyntaxTreeAnalysisContext" Kind="Structure" />
      <Type Name="SyntaxTreeValueProvider`1" DisplayName="SyntaxTreeValueProvider&lt;TValue&gt;" Kind="Class" />
      <Type Name="UnresolvedAnalyzerReference" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Diagnostics.Telemetry">
      <Type Name="AnalyzerTelemetryInfo" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Differencing">
      <Type Name="Edit`1" DisplayName="Edit&lt;TNode&gt;" Kind="Structure" />
      <Type Name="EditKind" Kind="Enumeration" />
      <Type Name="EditScript`1" DisplayName="EditScript&lt;TNode&gt;" Kind="Class" />
      <Type Name="Match`1" DisplayName="Match&lt;TNode&gt;" Kind="Class" />
      <Type Name="TreeComparer`1" DisplayName="TreeComparer&lt;TNode&gt;" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Editing">
      <Type Name="DeclarationKind" Kind="Enumeration" />
      <Type Name="DeclarationModifiers" Kind="Structure" />
      <Type Name="DocumentEditor" Kind="Class" />
      <Type Name="ImportAdder" Kind="Class" />
      <Type Name="OperatorKind" Kind="Enumeration" />
      <Type Name="SolutionEditor" Kind="Class" />
      <Type Name="SpecialTypeConstraintKind" Kind="Enumeration" />
      <Type Name="SymbolEditor" Kind="Class" />
      <Type Name="SymbolEditor+AsyncDeclarationEditAction" Kind="Delegate" />
      <Type Name="SymbolEditor+DeclarationEditAction" Kind="Delegate" />
      <Type Name="SymbolEditorExtensions" Kind="Class" />
      <Type Name="SyntaxEditor" Kind="Class" />
      <Type Name="SyntaxEditorExtensions" Kind="Class" />
      <Type Name="SyntaxGenerator" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Emit">
      <Type Name="DebugInformationFormat" Kind="Enumeration" />
      <Type Name="EditAndContinueMethodDebugInformation" Kind="Structure" />
      <Type Name="EmitBaseline" Kind="Class" />
      <Type Name="EmitDifferenceResult" Kind="Class" />
      <Type Name="EmitOptions" Kind="Class" />
      <Type Name="EmitResult" Kind="Class" />
      <Type Name="InstrumentationKind" Kind="Enumeration" />
      <Type Name="SemanticEdit" Kind="Structure" />
      <Type Name="SemanticEditKind" Kind="Enumeration" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.FindSymbols">
      <Type Name="IFindReferencesProgress" Kind="Interface" />
      <Type Name="ReferencedSymbol" Kind="Class" />
      <Type Name="ReferenceLocation" Kind="Structure" />
      <Type Name="SymbolCallerInfo" Kind="Structure" />
      <Type Name="SymbolFinder" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.FlowAnalysis">
      <Type Name="BasicBlock" Kind="Class" />
      <Type Name="BasicBlockKind" Kind="Enumeration" />
      <Type Name="CaptureId" Kind="Structure" />
      <Type Name="ControlFlowBranch" Kind="Class" />
      <Type Name="ControlFlowBranchSemantics" Kind="Enumeration" />
      <Type Name="ControlFlowConditionKind" Kind="Enumeration" />
      <Type Name="ControlFlowGraph" Kind="Class" />
      <Type Name="ControlFlowRegion" Kind="Class" />
      <Type Name="ControlFlowRegionKind" Kind="Enumeration" />
      <Type Name="ICaughtExceptionOperation" Kind="Interface" />
      <Type Name="IFlowAnonymousFunctionOperation" Kind="Interface" />
      <Type Name="IFlowCaptureOperation" Kind="Interface" />
      <Type Name="IFlowCaptureReferenceOperation" Kind="Interface" />
      <Type Name="IIsNullOperation" Kind="Interface" />
      <Type Name="IStaticLocalInitializationSemaphoreOperation" Kind="Interface" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Formatting">
      <Type Name="Formatter" Kind="Class" />
      <Type Name="FormattingOptions" Kind="Class" />
      <Type Name="FormattingOptions+IndentStyle" Kind="Enumeration" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Host">
      <Type Name="HostLanguageServices" Kind="Class" />
      <Type Name="HostServices" Kind="Class" />
      <Type Name="HostWorkspaceServices" Kind="Class" />
      <Type Name="HostWorkspaceServices+MetadataFilter" Kind="Delegate" />
      <Type Name="IAnalyzerService" Kind="Interface" />
      <Type Name="ILanguageService" Kind="Interface" />
      <Type Name="IPersistentStorage" Kind="Interface" />
      <Type Name="IPersistentStorageService" Kind="Interface" />
      <Type Name="ITemporaryStorageService" Kind="Interface" />
      <Type Name="ITemporaryStreamStorage" Kind="Interface" />
      <Type Name="ITemporaryTextStorage" Kind="Interface" />
      <Type Name="IWorkspaceService" Kind="Interface" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Host.Mef">
      <Type Name="DesktopMefHostServices" Kind="Class" />
      <Type Name="ExportLanguageServiceAttribute" Kind="Class" />
      <Type Name="ExportLanguageServiceFactoryAttribute" Kind="Class" />
      <Type Name="ExportWorkspaceServiceAttribute" Kind="Class" />
      <Type Name="ExportWorkspaceServiceFactoryAttribute" Kind="Class" />
      <Type Name="ILanguageServiceFactory" Kind="Interface" />
      <Type Name="IWorkspaceServiceFactory" Kind="Interface" />
      <Type Name="MefHostServices" Kind="Class" />
      <Type Name="MefV1HostServices" Kind="Class" />
      <Type Name="ServiceLayer" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Operations">
      <Type Name="ArgumentKind" Kind="Enumeration" />
      <Type Name="BinaryOperatorKind" Kind="Enumeration" />
      <Type Name="BranchKind" Kind="Enumeration" />
      <Type Name="CaseKind" Kind="Enumeration" />
      <Type Name="CommonConversion" Kind="Structure" />
      <Type Name="IAddressOfOperation" Kind="Interface" />
      <Type Name="IAnonymousFunctionOperation" Kind="Interface" />
      <Type Name="IAnonymousObjectCreationOperation" Kind="Interface" />
      <Type Name="IArgumentOperation" Kind="Interface" />
      <Type Name="IArrayCreationOperation" Kind="Interface" />
      <Type Name="IArrayElementReferenceOperation" Kind="Interface" />
      <Type Name="IArrayInitializerOperation" Kind="Interface" />
      <Type Name="IAssignmentOperation" Kind="Interface" />
      <Type Name="IAwaitOperation" Kind="Interface" />
      <Type Name="IBinaryOperation" Kind="Interface" />
      <Type Name="IBlockOperation" Kind="Interface" />
      <Type Name="IBranchOperation" Kind="Interface" />
      <Type Name="ICaseClauseOperation" Kind="Interface" />
      <Type Name="ICatchClauseOperation" Kind="Interface" />
      <Type Name="ICoalesceOperation" Kind="Interface" />
      <Type Name="ICollectionElementInitializerOperation" Kind="Interface" />
      <Type Name="ICompoundAssignmentOperation" Kind="Interface" />
      <Type Name="IConditionalAccessInstanceOperation" Kind="Interface" />
      <Type Name="IConditionalAccessOperation" Kind="Interface" />
      <Type Name="IConditionalOperation" Kind="Interface" />
      <Type Name="IConstantPatternOperation" Kind="Interface" />
      <Type Name="IConstructorBodyOperation" Kind="Interface" />
      <Type Name="IConversionOperation" Kind="Interface" />
      <Type Name="IDeclarationExpressionOperation" Kind="Interface" />
      <Type Name="IDeclarationPatternOperation" Kind="Interface" />
      <Type Name="IDeconstructionAssignmentOperation" Kind="Interface" />
      <Type Name="IDefaultCaseClauseOperation" Kind="Interface" />
      <Type Name="IDefaultValueOperation" Kind="Interface" />
      <Type Name="IDelegateCreationOperation" Kind="Interface" />
      <Type Name="IDiscardOperation" Kind="Interface" />
      <Type Name="IDynamicIndexerAccessOperation" Kind="Interface" />
      <Type Name="IDynamicInvocationOperation" Kind="Interface" />
      <Type Name="IDynamicMemberReferenceOperation" Kind="Interface" />
      <Type Name="IDynamicObjectCreationOperation" Kind="Interface" />
      <Type Name="IEmptyOperation" Kind="Interface" />
      <Type Name="IEndOperation" Kind="Interface" />
      <Type Name="IEventAssignmentOperation" Kind="Interface" />
      <Type Name="IEventReferenceOperation" Kind="Interface" />
      <Type Name="IExpressionStatementOperation" Kind="Interface" />
      <Type Name="IFieldInitializerOperation" Kind="Interface" />
      <Type Name="IFieldReferenceOperation" Kind="Interface" />
      <Type Name="IForEachLoopOperation" Kind="Interface" />
      <Type Name="IForLoopOperation" Kind="Interface" />
      <Type Name="IForToLoopOperation" Kind="Interface" />
      <Type Name="IIncrementOrDecrementOperation" Kind="Interface" />
      <Type Name="IInstanceReferenceOperation" Kind="Interface" />
      <Type Name="IInterpolatedStringContentOperation" Kind="Interface" />
      <Type Name="IInterpolatedStringOperation" Kind="Interface" />
      <Type Name="IInterpolatedStringTextOperation" Kind="Interface" />
      <Type Name="IInterpolationOperation" Kind="Interface" />
      <Type Name="IInvalidOperation" Kind="Interface" />
      <Type Name="IInvocationOperation" Kind="Interface" />
      <Type Name="IIsPatternOperation" Kind="Interface" />
      <Type Name="IIsTypeOperation" Kind="Interface" />
      <Type Name="ILabeledOperation" Kind="Interface" />
      <Type Name="ILiteralOperation" Kind="Interface" />
      <Type Name="ILocalFunctionOperation" Kind="Interface" />
      <Type Name="ILocalReferenceOperation" Kind="Interface" />
      <Type Name="ILockOperation" Kind="Interface" />
      <Type Name="ILoopOperation" Kind="Interface" />
      <Type Name="IMemberInitializerOperation" Kind="Interface" />
      <Type Name="IMemberReferenceOperation" Kind="Interface" />
      <Type Name="IMethodBodyBaseOperation" Kind="Interface" />
      <Type Name="IMethodBodyOperation" Kind="Interface" />
      <Type Name="IMethodReferenceOperation" Kind="Interface" />
      <Type Name="INameOfOperation" Kind="Interface" />
      <Type Name="InstanceReferenceKind" Kind="Enumeration" />
      <Type Name="IObjectCreationOperation" Kind="Interface" />
      <Type Name="IObjectOrCollectionInitializerOperation" Kind="Interface" />
      <Type Name="IOmittedArgumentOperation" Kind="Interface" />
      <Type Name="IParameterInitializerOperation" Kind="Interface" />
      <Type Name="IParameterReferenceOperation" Kind="Interface" />
      <Type Name="IParenthesizedOperation" Kind="Interface" />
      <Type Name="IPatternCaseClauseOperation" Kind="Interface" />
      <Type Name="IPatternOperation" Kind="Interface" />
      <Type Name="IPropertyInitializerOperation" Kind="Interface" />
      <Type Name="IPropertyReferenceOperation" Kind="Interface" />
      <Type Name="IRaiseEventOperation" Kind="Interface" />
      <Type Name="IRangeCaseClauseOperation" Kind="Interface" />
      <Type Name="IRelationalCaseClauseOperation" Kind="Interface" />
      <Type Name="IReturnOperation" Kind="Interface" />
      <Type Name="ISimpleAssignmentOperation" Kind="Interface" />
      <Type Name="ISingleValueCaseClauseOperation" Kind="Interface" />
      <Type Name="ISizeOfOperation" Kind="Interface" />
      <Type Name="IStopOperation" Kind="Interface" />
      <Type Name="ISwitchCaseOperation" Kind="Interface" />
      <Type Name="ISwitchOperation" Kind="Interface" />
      <Type Name="ISymbolInitializerOperation" Kind="Interface" />
      <Type Name="IThrowOperation" Kind="Interface" />
      <Type Name="ITranslatedQueryOperation" Kind="Interface" />
      <Type Name="ITryOperation" Kind="Interface" />
      <Type Name="ITupleBinaryOperation" Kind="Interface" />
      <Type Name="ITupleOperation" Kind="Interface" />
      <Type Name="ITypeOfOperation" Kind="Interface" />
      <Type Name="ITypeParameterObjectCreationOperation" Kind="Interface" />
      <Type Name="IUnaryOperation" Kind="Interface" />
      <Type Name="IUsingOperation" Kind="Interface" />
      <Type Name="IVariableDeclarationGroupOperation" Kind="Interface" />
      <Type Name="IVariableDeclarationOperation" Kind="Interface" />
      <Type Name="IVariableDeclaratorOperation" Kind="Interface" />
      <Type Name="IVariableInitializerOperation" Kind="Interface" />
      <Type Name="IWhileLoopOperation" Kind="Interface" />
      <Type Name="LoopKind" Kind="Enumeration" />
      <Type Name="OperationExtensions" Kind="Class" />
      <Type Name="OperationVisitor" Kind="Class" />
      <Type Name="OperationVisitor`2" DisplayName="OperationVisitor&lt;TArgument,TResult&gt;" Kind="Class" />
      <Type Name="OperationWalker" Kind="Class" />
      <Type Name="UnaryOperatorKind" Kind="Enumeration" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Options">
      <Type Name="DocumentOptionSet" Kind="Class" />
      <Type Name="IOption" Kind="Interface" />
      <Type Name="Option`1" DisplayName="Option&lt;T&gt;" Kind="Class" />
      <Type Name="OptionKey" Kind="Structure" />
      <Type Name="OptionSet" Kind="Class" />
      <Type Name="OptionStorageLocation" Kind="Class" />
      <Type Name="PerLanguageOption`1" DisplayName="PerLanguageOption&lt;T&gt;" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Recommendations">
      <Type Name="RecommendationOptions" Kind="Class" />
      <Type Name="Recommender" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Rename">
      <Type Name="RenameEntityKind" Kind="Enumeration" />
      <Type Name="RenameOptions" Kind="Class" />
      <Type Name="Renamer" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Simplification">
      <Type Name="SimplificationOptions" Kind="Class" />
      <Type Name="Simplifier" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Tags">
      <Type Name="WellKnownTags" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.Text">
      <Type Name="LinePosition" Kind="Structure" />
      <Type Name="LinePositionSpan" Kind="Structure" />
      <Type Name="SourceHashAlgorithm" Kind="Enumeration" />
      <Type Name="SourceText" Kind="Class" />
      <Type Name="SourceTextContainer" Kind="Class" />
      <Type Name="TextChange" Kind="Structure" />
      <Type Name="TextChangeEventArgs" Kind="Class" />
      <Type Name="TextChangeRange" Kind="Structure" />
      <Type Name="TextLine" Kind="Structure" />
      <Type Name="TextLineCollection" Kind="Class" />
      <Type Name="TextLineCollection+Enumerator" Kind="Structure" />
      <Type Name="TextSpan" Kind="Structure" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.VisualBasic">
      <Type Name="AggregateClauseSymbolInfo" Kind="Structure" />
      <Type Name="AwaitExpressionInfo" Kind="Structure" />
      <Type Name="CollectionRangeVariableSymbolInfo" Kind="Structure" />
      <Type Name="Conversion" Kind="Structure" />
      <Type Name="ForEachStatementInfo" Kind="Structure" />
      <Type Name="GeneratedExtensionSyntaxFacts" Kind="Class" />
      <Type Name="GlobalImport" Kind="Class" />
      <Type Name="HandledEvent" Kind="Class" />
      <Type Name="HandledEventKind" Kind="Enumeration" />
      <Type Name="LanguageVersion" Kind="Enumeration" />
      <Type Name="LanguageVersionFacts" Kind="Class" />
      <Type Name="LocalizableErrorArgument" Kind="Structure" />
      <Type Name="OptionStrict" Kind="Enumeration" />
      <Type Name="PredefinedPreprocessorSymbols" Kind="Class" />
      <Type Name="SymbolDisplay" Kind="Class" />
      <Type Name="SyntaxExtensions" Kind="Class" />
      <Type Name="SyntaxFactory" Kind="Class" />
      <Type Name="SyntaxFacts" Kind="Class" />
      <Type Name="SyntaxKind" Kind="Enumeration" />
      <Type Name="TypedConstantExtensions" Kind="Class" />
      <Type Name="VisualBasicCommandLineArguments" Kind="Class" />
      <Type Name="VisualBasicCommandLineParser" Kind="Class" />
      <Type Name="VisualBasicCompilation" Kind="Class" />
      <Type Name="VisualBasicCompilationOptions" Kind="Class" />
      <Type Name="VisualBasicDiagnosticFormatter" Kind="Class" />
      <Type Name="VisualBasicExtensions" Kind="Class" />
      <Type Name="VisualBasicParseOptions" Kind="Class" />
      <Type Name="VisualBasicSyntaxNode" Kind="Class" />
      <Type Name="VisualBasicSyntaxRewriter" Kind="Class" />
      <Type Name="VisualBasicSyntaxTree" Kind="Class" />
      <Type Name="VisualBasicSyntaxVisitor" Kind="Class" />
      <Type Name="VisualBasicSyntaxVisitor`1" DisplayName="VisualBasicSyntaxVisitor&lt;TResult&gt;" Kind="Class" />
      <Type Name="VisualBasicSyntaxWalker" Kind="Class" />
    </Namespace>
    <Namespace Name="Microsoft.CodeAnalysis.VisualBasic.Syntax">
      <Type Name="AccessorBlockSyntax" Kind="Class" />
      <Type Name="AccessorStatementSyntax" Kind="Class" />
      <Type Name="AddRemoveHandlerStatementSyntax" Kind="Class" />
      <Type Name="AggregateClauseSyntax" Kind="Class" />
      <Type Name="AggregationRangeVariableSyntax" Kind="Class" />
      <Type Name="AggregationSyntax" Kind="Class" />
      <Type Name="AnonymousObjectCreationExpressionSyntax" Kind="Class" />
      <Type Name="ArgumentListSyntax" Kind="Class" />
      <Type Name="ArgumentSyntax" Kind="Class" />
      <Type Name="ArrayCreationExpressionSyntax" Kind="Class" />
      <Type Name="ArrayRankSpecifierSyntax" Kind="Class" />
      <Type Name="ArrayTypeSyntax" Kind="Class" />
      <Type Name="AsClauseSyntax" Kind="Class" />
      <Type Name="AsNewClauseSyntax" Kind="Class" />
      <Type Name="AssignmentStatementSyntax" Kind="Class" />
      <Type Name="AttributeListSyntax" Kind="Class" />
      <Type Name="AttributesStatementSyntax" Kind="Class" />
      <Type Name="AttributeSyntax" Kind="Class" />
      <Type Name="AttributeTargetSyntax" Kind="Class" />
      <Type Name="AwaitExpressionSyntax" Kind="Class" />
      <Type Name="BadDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="BaseXmlAttributeSyntax" Kind="Class" />
      <Type Name="BinaryConditionalExpressionSyntax" Kind="Class" />
      <Type Name="BinaryExpressionSyntax" Kind="Class" />
      <Type Name="CallStatementSyntax" Kind="Class" />
      <Type Name="CaseBlockSyntax" Kind="Class" />
      <Type Name="CaseClauseSyntax" Kind="Class" />
      <Type Name="CaseStatementSyntax" Kind="Class" />
      <Type Name="CastExpressionSyntax" Kind="Class" />
      <Type Name="CatchBlockSyntax" Kind="Class" />
      <Type Name="CatchFilterClauseSyntax" Kind="Class" />
      <Type Name="CatchStatementSyntax" Kind="Class" />
      <Type Name="ClassBlockSyntax" Kind="Class" />
      <Type Name="ClassStatementSyntax" Kind="Class" />
      <Type Name="CollectionInitializerSyntax" Kind="Class" />
      <Type Name="CollectionRangeVariableSyntax" Kind="Class" />
      <Type Name="CompilationUnitSyntax" Kind="Class" />
      <Type Name="ConditionalAccessExpressionSyntax" Kind="Class" />
      <Type Name="ConstDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="ConstraintSyntax" Kind="Class" />
      <Type Name="ConstructorBlockSyntax" Kind="Class" />
      <Type Name="ContinueStatementSyntax" Kind="Class" />
      <Type Name="CrefOperatorReferenceSyntax" Kind="Class" />
      <Type Name="CrefReferenceSyntax" Kind="Class" />
      <Type Name="CrefSignaturePartSyntax" Kind="Class" />
      <Type Name="CrefSignatureSyntax" Kind="Class" />
      <Type Name="CTypeExpressionSyntax" Kind="Class" />
      <Type Name="DeclarationStatementSyntax" Kind="Class" />
      <Type Name="DeclareStatementSyntax" Kind="Class" />
      <Type Name="DelegateStatementSyntax" Kind="Class" />
      <Type Name="DirectCastExpressionSyntax" Kind="Class" />
      <Type Name="DirectiveTriviaSyntax" Kind="Class" />
      <Type Name="DisableWarningDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="DistinctClauseSyntax" Kind="Class" />
      <Type Name="DocumentationCommentTriviaSyntax" Kind="Class" />
      <Type Name="DoLoopBlockSyntax" Kind="Class" />
      <Type Name="DoStatementSyntax" Kind="Class" />
      <Type Name="ElseBlockSyntax" Kind="Class" />
      <Type Name="ElseCaseClauseSyntax" Kind="Class" />
      <Type Name="ElseDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="ElseIfBlockSyntax" Kind="Class" />
      <Type Name="ElseIfStatementSyntax" Kind="Class" />
      <Type Name="ElseStatementSyntax" Kind="Class" />
      <Type Name="EmptyStatementSyntax" Kind="Class" />
      <Type Name="EnableWarningDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EndBlockStatementSyntax" Kind="Class" />
      <Type Name="EndExternalSourceDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EndIfDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EndRegionDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="EnumBlockSyntax" Kind="Class" />
      <Type Name="EnumMemberDeclarationSyntax" Kind="Class" />
      <Type Name="EnumStatementSyntax" Kind="Class" />
      <Type Name="EqualsValueSyntax" Kind="Class" />
      <Type Name="EraseStatementSyntax" Kind="Class" />
      <Type Name="ErrorStatementSyntax" Kind="Class" />
      <Type Name="EventBlockSyntax" Kind="Class" />
      <Type Name="EventContainerSyntax" Kind="Class" />
      <Type Name="EventStatementSyntax" Kind="Class" />
      <Type Name="ExecutableStatementSyntax" Kind="Class" />
      <Type Name="ExitStatementSyntax" Kind="Class" />
      <Type Name="ExpressionRangeVariableSyntax" Kind="Class" />
      <Type Name="ExpressionStatementSyntax" Kind="Class" />
      <Type Name="ExpressionSyntax" Kind="Class" />
      <Type Name="ExternalChecksumDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="ExternalSourceDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="FieldDeclarationSyntax" Kind="Class" />
      <Type Name="FieldInitializerSyntax" Kind="Class" />
      <Type Name="FinallyBlockSyntax" Kind="Class" />
      <Type Name="FinallyStatementSyntax" Kind="Class" />
      <Type Name="ForBlockSyntax" Kind="Class" />
      <Type Name="ForEachBlockSyntax" Kind="Class" />
      <Type Name="ForEachStatementSyntax" Kind="Class" />
      <Type Name="ForOrForEachBlockSyntax" Kind="Class" />
      <Type Name="ForOrForEachStatementSyntax" Kind="Class" />
      <Type Name="ForStatementSyntax" Kind="Class" />
      <Type Name="ForStepClauseSyntax" Kind="Class" />
      <Type Name="FromClauseSyntax" Kind="Class" />
      <Type Name="FunctionAggregationSyntax" Kind="Class" />
      <Type Name="GenericNameSyntax" Kind="Class" />
      <Type Name="GetTypeExpressionSyntax" Kind="Class" />
      <Type Name="GetXmlNamespaceExpressionSyntax" Kind="Class" />
      <Type Name="GlobalNameSyntax" Kind="Class" />
      <Type Name="GoToStatementSyntax" Kind="Class" />
      <Type Name="GroupAggregationSyntax" Kind="Class" />
      <Type Name="GroupByClauseSyntax" Kind="Class" />
      <Type Name="GroupJoinClauseSyntax" Kind="Class" />
      <Type Name="HandlesClauseItemSyntax" Kind="Class" />
      <Type Name="HandlesClauseSyntax" Kind="Class" />
      <Type Name="IdentifierNameSyntax" Kind="Class" />
      <Type Name="IfDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="IfStatementSyntax" Kind="Class" />
      <Type Name="ImplementsClauseSyntax" Kind="Class" />
      <Type Name="ImplementsStatementSyntax" Kind="Class" />
      <Type Name="ImportAliasClauseSyntax" Kind="Class" />
      <Type Name="ImportsClauseSyntax" Kind="Class" />
      <Type Name="ImportsStatementSyntax" Kind="Class" />
      <Type Name="IncompleteMemberSyntax" Kind="Class" />
      <Type Name="InferredFieldInitializerSyntax" Kind="Class" />
      <Type Name="InheritsOrImplementsStatementSyntax" Kind="Class" />
      <Type Name="InheritsStatementSyntax" Kind="Class" />
      <Type Name="InstanceExpressionSyntax" Kind="Class" />
      <Type Name="InterfaceBlockSyntax" Kind="Class" />
      <Type Name="InterfaceStatementSyntax" Kind="Class" />
      <Type Name="InterpolatedStringContentSyntax" Kind="Class" />
      <Type Name="InterpolatedStringExpressionSyntax" Kind="Class" />
      <Type Name="InterpolatedStringTextSyntax" Kind="Class" />
      <Type Name="InterpolationAlignmentClauseSyntax" Kind="Class" />
      <Type Name="InterpolationFormatClauseSyntax" Kind="Class" />
      <Type Name="InterpolationSyntax" Kind="Class" />
      <Type Name="InvocationExpressionSyntax" Kind="Class" />
      <Type Name="JoinClauseSyntax" Kind="Class" />
      <Type Name="JoinConditionSyntax" Kind="Class" />
      <Type Name="KeywordEventContainerSyntax" Kind="Class" />
      <Type Name="LabelStatementSyntax" Kind="Class" />
      <Type Name="LabelSyntax" Kind="Class" />
      <Type Name="LambdaExpressionSyntax" Kind="Class" />
      <Type Name="LambdaHeaderSyntax" Kind="Class" />
      <Type Name="LetClauseSyntax" Kind="Class" />
      <Type Name="LiteralBase" Kind="Enumeration" />
      <Type Name="LiteralExpressionSyntax" Kind="Class" />
      <Type Name="LocalDeclarationStatementSyntax" Kind="Class" />
      <Type Name="LoopStatementSyntax" Kind="Class" />
      <Type Name="MeExpressionSyntax" Kind="Class" />
      <Type Name="MemberAccessExpressionSyntax" Kind="Class" />
      <Type Name="MethodBaseSyntax" Kind="Class" />
      <Type Name="MethodBlockBaseSyntax" Kind="Class" />
      <Type Name="MethodBlockSyntax" Kind="Class" />
      <Type Name="MethodStatementSyntax" Kind="Class" />
      <Type Name="MidExpressionSyntax" Kind="Class" />
      <Type Name="ModifiedIdentifierSyntax" Kind="Class" />
      <Type Name="ModuleBlockSyntax" Kind="Class" />
      <Type Name="ModuleStatementSyntax" Kind="Class" />
      <Type Name="MultiLineIfBlockSyntax" Kind="Class" />
      <Type Name="MultiLineLambdaExpressionSyntax" Kind="Class" />
      <Type Name="MyBaseExpressionSyntax" Kind="Class" />
      <Type Name="MyClassExpressionSyntax" Kind="Class" />
      <Type Name="NameColonEqualsSyntax" Kind="Class" />
      <Type Name="NamedFieldInitializerSyntax" Kind="Class" />
      <Type Name="NamedTupleElementSyntax" Kind="Class" />
      <Type Name="NameOfExpressionSyntax" Kind="Class" />
      <Type Name="NamespaceBlockSyntax" Kind="Class" />
      <Type Name="NamespaceStatementSyntax" Kind="Class" />
      <Type Name="NameSyntax" Kind="Class" />
      <Type Name="NewExpressionSyntax" Kind="Class" />
      <Type Name="NextStatementSyntax" Kind="Class" />
      <Type Name="NullableTypeSyntax" Kind="Class" />
      <Type Name="ObjectCollectionInitializerSyntax" Kind="Class" />
      <Type Name="ObjectCreationExpressionSyntax" Kind="Class" />
      <Type Name="ObjectCreationInitializerSyntax" Kind="Class" />
      <Type Name="ObjectMemberInitializerSyntax" Kind="Class" />
      <Type Name="OmittedArgumentSyntax" Kind="Class" />
      <Type Name="OnErrorGoToStatementSyntax" Kind="Class" />
      <Type Name="OnErrorResumeNextStatementSyntax" Kind="Class" />
      <Type Name="OperatorBlockSyntax" Kind="Class" />
      <Type Name="OperatorStatementSyntax" Kind="Class" />
      <Type Name="OptionStatementSyntax" Kind="Class" />
      <Type Name="OrderByClauseSyntax" Kind="Class" />
      <Type Name="OrderingSyntax" Kind="Class" />
      <Type Name="ParameterListSyntax" Kind="Class" />
      <Type Name="ParameterSyntax" Kind="Class" />
      <Type Name="ParenthesizedExpressionSyntax" Kind="Class" />
      <Type Name="PartitionClauseSyntax" Kind="Class" />
      <Type Name="PartitionWhileClauseSyntax" Kind="Class" />
      <Type Name="PredefinedCastExpressionSyntax" Kind="Class" />
      <Type Name="PredefinedTypeSyntax" Kind="Class" />
      <Type Name="PrintStatementSyntax" Kind="Class" />
      <Type Name="PropertyBlockSyntax" Kind="Class" />
      <Type Name="PropertyStatementSyntax" Kind="Class" />
      <Type Name="QualifiedCrefOperatorReferenceSyntax" Kind="Class" />
      <Type Name="QualifiedNameSyntax" Kind="Class" />
      <Type Name="QueryClauseSyntax" Kind="Class" />
      <Type Name="QueryExpressionSyntax" Kind="Class" />
      <Type Name="RaiseEventStatementSyntax" Kind="Class" />
      <Type Name="RangeArgumentSyntax" Kind="Class" />
      <Type Name="RangeCaseClauseSyntax" Kind="Class" />
      <Type Name="RedimClauseSyntax" Kind="Class" />
      <Type Name="ReDimStatementSyntax" Kind="Class" />
      <Type Name="ReferenceDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="RegionDirectiveTriviaSyntax" Kind="Class" />
      <Type Name="RelationalCaseClauseSyntax" Kind="Class" />
      <Type Name="ResumeStatementSyntax" Kind="Class" />
      <Type Name="ReturnStatementSyntax" Kind="Class" />
      <Type Name="SelectBlockSyntax" Kind="Class" />
      <Type Name="SelectClauseSyntax" Kind="Class" />
      <Type Name="SelectStatementSyntax" Kind="Class" />
      <Type Name="SimpleArgumentSyntax" Kind="Class" />
      <Type Name="SimpleAsClauseSyntax" Kind="Class" />
      <Type Name="SimpleCaseClauseSyntax" Kind="Class" />
      <Type Name="SimpleImportsClauseSyntax" Kind="Class" />
      <Type Name="SimpleJoinClauseSyntax" Kind="Class" />
      <Type Name="SimpleNameSyntax" Kind="Class" />
      <Type Name="SingleLineElseClauseSyntax" Kind="Class" />
      <Type Name="SingleLineIfStatementSyntax" Kind="Class" />
      <Type Name="SingleLineLambdaExpressionSyntax" Kind="Class" />
      <Type Name="SkippedTokensTriviaSyntax" Kind="Class" />
      <Type Name="SpecialConstraintSyntax" Kind="Class" />
      <Type Name="StatementSyntax" Kind="Class" />
      <Type Name="StopOrEndStatementSyntax" Kind="Class" />
      <Type Name="StructureBlockSyntax" Kind="Class" />
      <Type Name="StructuredTriviaSyntax" Kind="Class" />
      <Type Name="StructureStatementSyntax" Kind="Class" />
      <Type Name="SubNewStatementSyntax" Kind="Class" />
      <Type Name="SyncLockBlockSyntax" Kind="Class" />
      <Type Name="SyncLockStatementSyntax" Kind="Class" />
      <Type Name="SyntaxNodeRemover" Kind="Class" />
      <Type Name="TernaryConditionalExpressionSyntax" Kind="Class" />
      <Type Name="ThrowStatementSyntax" Kind="Class" />
      <Type Name="TryBlockSyntax" Kind="Class" />
      <Type Name="TryCastExpressionSyntax" Kind="Class" />
      <Type Name="TryStatementSyntax" Kind="Class" />
      <Type Name="TupleElementSyntax" Kind="Class" />
      <Type Name="TupleExpressionSyntax" Kind="Class" />
      <Type Name="TupleTypeSyntax" Kind="Class" />
      <Type Name="TypeArgumentListSyntax" Kind="Class" />
      <Type Name="TypeBlockSyntax" Kind="Class" />
      <Type Name="TypeCharacter" Kind="Enumeration" />
      <Type Name="TypeConstraintSyntax" Kind="Class" />
      <Type Name="TypedTupleElementSyntax" Kind="Class" />
      <Type Name="TypeOfExpressionSyntax" Kind="Class" />
      <Type Name="TypeParameterConstraintClauseSyntax" Kind="Class" />
      <Type Name="TypeParameterListSyntax" Kind="Class" />
      <Type Name="TypeParameterMultipleConstraintClauseSyntax" Kind="Class" />
      <Type Name="TypeParameterSingleConstraintClauseSyntax" Kind="Class" />
      <Type Name="TypeParameterSyntax" Kind="Class" />
      <Type Name="TypeStatementSyntax" Kind="Class" />
      <Type Name="TypeSyntax" Kind="Class" />
      <Type Name="UnaryExpressionSyntax" Kind="Class" />
      <Type Name="UsingBlockSyntax" Kind="Class" />
      <Type Name="UsingStatementSyntax" Kind="Class" />
      <Type Name="VariableDeclaratorSyntax" Kind="Class" />
      <Type Name="VariableNameEqualsSyntax" Kind="Class" />
      <Type Name="WhereClauseSyntax" Kind="Class" />
      <Type Name="WhileBlockSyntax" Kind="Class" />
      <Type Name="WhileOrUntilClauseSyntax" Kind="Class" />
      <Type Name="WhileStatementSyntax" Kind="Class" />
      <Type Name="WithBlockSyntax" Kind="Class" />
      <Type Name="WithEventsEventContainerSyntax" Kind="Class" />
      <Type Name="WithEventsPropertyEventContainerSyntax" Kind="Class" />
      <Type Name="WithStatementSyntax" Kind="Class" />
      <Type Name="XmlAttributeSyntax" Kind="Class" />
      <Type Name="XmlBracketedNameSyntax" Kind="Class" />
      <Type Name="XmlCDataSectionSyntax" Kind="Class" />
      <Type Name="XmlCommentSyntax" Kind="Class" />
      <Type Name="XmlCrefAttributeSyntax" Kind="Class" />
      <Type Name="XmlDeclarationOptionSyntax" Kind="Class" />
      <Type Name="XmlDeclarationSyntax" Kind="Class" />
      <Type Name="XmlDocumentSyntax" Kind="Class" />
      <Type Name="XmlElementEndTagSyntax" Kind="Class" />
      <Type Name="XmlElementStartTagSyntax" Kind="Class" />
      <Type Name="XmlElementSyntax" Kind="Class" />
      <Type Name="XmlEmbeddedExpressionSyntax" Kind="Class" />
      <Type Name="XmlEmptyElementSyntax" Kind="Class" />
      <Type Name="XmlMemberAccessExpressionSyntax" Kind="Class" />
      <Type Name="XmlNameAttributeSyntax" Kind="Class" />
      <Type Name="XmlNamespaceImportsClauseSyntax" Kind="Class" />
      <Type Name="XmlNameSyntax" Kind="Class" />
      <Type Name="XmlNodeSyntax" Kind="Class" />
      <Type Name="XmlPrefixNameSyntax" Kind="Class" />
      <Type Name="XmlPrefixSyntax" Kind="Class" />
      <Type Name="XmlProcessingInstructionSyntax" Kind="Class" />
      <Type Name="XmlStringSyntax" Kind="Class" />
      <Type Name="XmlTextSyntax" Kind="Class" />
      <Type Name="YieldStatementSyntax" Kind="Class" />
    </Namespace>
  </Types>
  <Title>Untitled</Title>
  <ExtensionMethods>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithAdditionalAnnotations&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static TNode WithAdditionalAnnotations&lt;TNode&gt; (this TNode node, params Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TNode WithAdditionalAnnotations&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(!!TNode node, class Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,Microsoft.CodeAnalysis.SyntaxAnnotation[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithAdditionalAnnotations(Of TNode As SyntaxNode) (node As TNode, ParamArray annotations As SyntaxAnnotation()) As TNode" />
        <MemberSignature Language="F#" Value="static member WithAdditionalAnnotations : 'Node * Microsoft.CodeAnalysis.SyntaxAnnotation[] -&gt; 'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations (node, annotations)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TNode WithAdditionalAnnotations(TNode node, ... cli::array &lt;Microsoft::CodeAnalysis::SyntaxAnnotation ^&gt; ^ annotations);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TNode</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TNode" RefType="this" />
          <Parameter Name="annotations" Type="Microsoft.CodeAnalysis.SyntaxAnnotation[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="node">Original node.</param>
          <param name="annotations">Annotations to be added to the new node.</param>
          <summary>
            Creates a new node identical to this node with the specified annotations attached.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.AnnotationExtensions" Member="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,Microsoft.CodeAnalysis.SyntaxAnnotation[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithAdditionalAnnotations&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static TNode WithAdditionalAnnotations&lt;TNode&gt; (this TNode node, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt; annotations) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TNode WithAdditionalAnnotations&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(!!TNode node, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxAnnotation&gt; annotations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithAdditionalAnnotations(Of TNode As SyntaxNode) (node As TNode, annotations As IEnumerable(Of SyntaxAnnotation)) As TNode" />
        <MemberSignature Language="F#" Value="static member WithAdditionalAnnotations : 'Node * seq&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt; -&gt; 'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations (node, annotations)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TNode WithAdditionalAnnotations(TNode node, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxAnnotation ^&gt; ^ annotations);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TNode</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TNode" RefType="this" />
          <Parameter Name="annotations" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="node">Original node.</param>
          <param name="annotations">Annotations to be added to the new node.</param>
          <summary>
            Creates a new node identical to this node with the specified annotations attached.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.AnnotationExtensions" Member="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithoutAnnotations&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static TNode WithoutAnnotations&lt;TNode&gt; (this TNode node, params Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TNode WithoutAnnotations&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(!!TNode node, class Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,Microsoft.CodeAnalysis.SyntaxAnnotation[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithoutAnnotations(Of TNode As SyntaxNode) (node As TNode, ParamArray annotations As SyntaxAnnotation()) As TNode" />
        <MemberSignature Language="F#" Value="static member WithoutAnnotations : 'Node * Microsoft.CodeAnalysis.SyntaxAnnotation[] -&gt; 'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations (node, annotations)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TNode WithoutAnnotations(TNode node, ... cli::array &lt;Microsoft::CodeAnalysis::SyntaxAnnotation ^&gt; ^ annotations);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TNode</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TNode" RefType="this" />
          <Parameter Name="annotations" Type="Microsoft.CodeAnalysis.SyntaxAnnotation[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="node">Original node.</param>
          <param name="annotations">Annotations to be removed from the new node.</param>
          <summary>
            Creates a new node identical to this node with the specified annotations removed.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.AnnotationExtensions" Member="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,Microsoft.CodeAnalysis.SyntaxAnnotation[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithoutAnnotations&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static TNode WithoutAnnotations&lt;TNode&gt; (this TNode node, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt; annotations) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TNode WithoutAnnotations&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(!!TNode node, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxAnnotation&gt; annotations) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithoutAnnotations(Of TNode As SyntaxNode) (node As TNode, annotations As IEnumerable(Of SyntaxAnnotation)) As TNode" />
        <MemberSignature Language="F#" Value="static member WithoutAnnotations : 'Node * seq&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt; -&gt; 'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations (node, annotations)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TNode WithoutAnnotations(TNode node, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxAnnotation ^&gt; ^ annotations);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TNode</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TNode" RefType="this" />
          <Parameter Name="annotations" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxAnnotation&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="node">Original node.</param>
          <param name="annotations">Annotations to be removed from the new node.</param>
          <summary>
            Creates a new node identical to this node with the specified annotations removed.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.AnnotationExtensions" Member="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithoutAnnotations&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static TNode WithoutAnnotations&lt;TNode&gt; (this TNode node, string annotationKind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TNode WithoutAnnotations&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(!!TNode node, string annotationKind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithoutAnnotations(Of TNode As SyntaxNode) (node As TNode, annotationKind As String) As TNode" />
        <MemberSignature Language="F#" Value="static member WithoutAnnotations : 'Node * string -&gt; 'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations (node, annotationKind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TNode WithoutAnnotations(TNode node, System::String ^ annotationKind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TNode</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TNode" RefType="this" />
          <Parameter Name="annotationKind" Type="System.String" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="node">Original node.</param>
          <param name="annotationKind">The kind of annotation to remove.</param>
          <summary>
            Creates a new node identical to this node with the annotations of the specified kind removed.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.AnnotationExtensions" Member="M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeControlFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
        <MemberSignature Language="F#" Value="static member AnalyzeControlFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax -&gt; Microsoft.CodeAnalysis.ControlFlowAnalysis" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow (semanticModel, statement)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::ControlFlowAnalysis ^ AnalyzeControlFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::StatementSyntax ^ statement);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="statement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="statement">To be added.</param>
          <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeControlFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
        <MemberSignature Language="F#" Value="static member AnalyzeControlFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax * Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax -&gt; Microsoft.CodeAnalysis.ControlFlowAnalysis" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow (semanticModel, firstStatement, lastStatement)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::ControlFlowAnalysis ^ AnalyzeControlFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::StatementSyntax ^ firstStatement, Microsoft::CodeAnalysis::CSharp::Syntax::StatementSyntax ^ lastStatement);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
          <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="firstStatement">To be added.</param>
          <param name="lastStatement">To be added.</param>
          <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeDataFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)" />
        <MemberSignature Language="F#" Value="static member AnalyzeDataFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax -&gt; Microsoft.CodeAnalysis.DataFlowAnalysis" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow (semanticModel, expression)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::DataFlowAnalysis ^ AnalyzeDataFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::ExpressionSyntax ^ expression);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <summary>
            Analyze data-flow within an expression. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeDataFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
        <MemberSignature Language="F#" Value="static member AnalyzeDataFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax -&gt; Microsoft.CodeAnalysis.DataFlowAnalysis" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow (semanticModel, statement)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::DataFlowAnalysis ^ AnalyzeDataFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::StatementSyntax ^ statement);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="statement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="statement">To be added.</param>
          <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeDataFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
        <MemberSignature Language="F#" Value="static member AnalyzeDataFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax * Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax -&gt; Microsoft.CodeAnalysis.DataFlowAnalysis" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow (semanticModel, firstStatement, lastStatement)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::DataFlowAnalysis ^ AnalyzeDataFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::StatementSyntax ^ firstStatement, Microsoft::CodeAnalysis::CSharp::Syntax::StatementSyntax ^ lastStatement);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
          <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="firstStatement">To be added.</param>
          <param name="lastStatement">To be added.</param>
          <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="ClassifyConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.Compilation compilation, class Microsoft.CodeAnalysis.ITypeSymbol source, class Microsoft.CodeAnalysis.ITypeSymbol destination) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
        <MemberSignature Language="F#" Value="static member ClassifyConversion : Microsoft.CodeAnalysis.Compilation * Microsoft.CodeAnalysis.ITypeSymbol * Microsoft.CodeAnalysis.ITypeSymbol -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion (compilation, source, destination)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::Conversion ClassifyConversion(Microsoft::CodeAnalysis::Compilation ^ compilation, Microsoft::CodeAnalysis::ITypeSymbol ^ source, Microsoft::CodeAnalysis::ITypeSymbol ^ destination);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
          <Parameter Name="source" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
          <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        </Parameters>
        <Docs>
          <param name="compilation">To be added.</param>
          <param name="source">To be added.</param>
          <param name="destination">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="ClassifyConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, class Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member ClassifyConversion : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.ITypeSymbol * bool -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion (semanticModel, expression, destination, isExplicitInSource)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
          <Parameter Name="isExplicitInSource" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="destination">To be added.</param>
          <param name="isExplicitInSource">To be added.</param>
          <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="ClassifyConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, class Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)" />
        <MemberSignature Language="F#" Value="static member ClassifyConversion : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.ITypeSymbol * bool -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion (semanticModel, position, expression, destination, isExplicitInSource)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
          <Parameter Name="isExplicitInSource" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="destination">To be added.</param>
          <param name="isExplicitInSource">To be added.</param>
          <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetAliasInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetAliasInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo (semanticModel, nameSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="nameSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            If <paramref name="nameSyntax" /> resolves to an alias name, return the AliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetAwaitExpressionInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo GetAwaitExpressionInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax awaitExpression);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo GetAwaitExpressionInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax awaitExpression) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)" />
        <MemberSignature Language="F#" Value="static member GetAwaitExpressionInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax -&gt; Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo (semanticModel, awaitExpression)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::AwaitExpressionInfo GetAwaitExpressionInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::AwaitExpressionSyntax ^ awaitExpression);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="awaitExpression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="awaitExpression">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetCollectionInitializerSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetCollectionInitializerSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetCollectionInitializerSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetCollectionInitializerSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo (semanticModel, expression, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax 
            within <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.Initializer" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTree" />
      </Targets>
      <Member MemberName="GetCompilationUnitRoot">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax GetCompilationUnitRoot (this Microsoft.CodeAnalysis.SyntaxTree tree, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax GetCompilationUnitRoot(class Microsoft.CodeAnalysis.SyntaxTree tree, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetCompilationUnitRoot : Microsoft.CodeAnalysis.SyntaxTree * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot (tree, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="tree" Type="Microsoft.CodeAnalysis.SyntaxTree" RefType="this" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="tree">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetConstantValue">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.Optional&lt;object&gt; GetConstantValue (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.Optional`1&lt;object&gt; GetConstantValue(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetConstantValue : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.Optional&lt;obj&gt;" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue (semanticModel, expression, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.Optional&lt;System.Object&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.IConversionOperation" />
      </Targets>
      <Member MemberName="GetConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion GetConversion (this Microsoft.CodeAnalysis.Operations.IConversionOperation conversionExpression);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion GetConversion(class Microsoft.CodeAnalysis.Operations.IConversionOperation conversionExpression) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.Operations.IConversionOperation)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetConversion (conversionExpression As IConversionOperation) As Conversion" />
        <MemberSignature Language="F#" Value="static member GetConversion : Microsoft.CodeAnalysis.Operations.IConversionOperation -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion conversionExpression" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::Conversion GetConversion(Microsoft::CodeAnalysis::Operations::IConversionOperation ^ conversionExpression);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="conversionExpression" Type="Microsoft.CodeAnalysis.Operations.IConversionOperation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="conversionExpression">The conversion expression to get original info from.</param>
          <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion" /> information from this <see cref="T:Microsoft.CodeAnalysis.Operations.IConversionOperation" />. This
            <see cref="T:Microsoft.CodeAnalysis.Operations.IConversionOperation" /> must have been created from CSharp code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.Operations.IConversionOperation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion GetConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion GetConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetConversion : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion (semanticModel, expression, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IMethodSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node that declares a property or member accessor, get the corresponding symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declaratorSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declaratorSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IPropertySymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declaratorSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declaratorSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declaratorSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declaratorSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node of a tuple argument, get the tuple element symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IMethodSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a base method declaration syntax, get the corresponding method symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a type declaration, get the corresponding type symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax catchDeclaration, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax catchDeclaration, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ILocalSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, catchDeclaration, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ILocalSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="catchDeclaration" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="catchDeclaration">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a catch declaration, get the symbol for the exception variable
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a delegate declaration, get the corresponding type symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IFieldSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IFieldSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IFieldSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IFieldSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a enum member declaration, get the corresponding field symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IEventSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IEventSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node that declares a (custom) event, get the corresponding event symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given an extern alias declaration get the corresponding symbol for the alias that was introduced.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ILocalSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, forEachStatement, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ILocalSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="forEachStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="forEachStatement">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a foreach statement, get the symbol for the iteration variable
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IPropertySymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node that declares an indexer, get the corresponding declared symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IRangeVariableSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, node, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Get the query range variable declared in a join into clause.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ILabelSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ILabelSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a labeled statement syntax, get the corresponding label symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a member declaration syntax, get the corresponding symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamespaceSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for
            the declaration assembly.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IParameterSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IParameterSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IParameterSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IParameterSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a parameter declaration syntax node, get the corresponding symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IPropertySymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node that declares a property, get the corresponding declared symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax queryClause, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax queryClause, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IRangeVariableSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, queryClause, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="queryClause" Type="Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="queryClause">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IRangeVariableSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, node, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Get the query range variable declared in a query continuation clause.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax designationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax designationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, designationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="designationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="designationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ILabelSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ILabelSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a switch label syntax, get the corresponding label symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a tuple element syntax, get the corresponding symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax declaratorSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declaratorSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declaratorSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declaratorSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a syntax node of tuple expression, get the tuple type symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ITypeParameterSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax typeParameter, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ITypeParameterSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax typeParameter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ITypeParameterSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, typeParameter, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ITypeParameterSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="typeParameter" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="typeParameter">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a type parameter declaration (field or method), get the corresponding symbol
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a using declaration get the corresponding symbol for the using alias that was introduced.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeconstructionInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.DeconstructionInfo GetDeconstructionInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax assignment);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.DeconstructionInfo GetDeconstructionInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax assignment) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeconstructionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax)" />
        <MemberSignature Language="F#" Value="static member GetDeconstructionInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax -&gt; Microsoft.CodeAnalysis.CSharp.DeconstructionInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeconstructionInfo (semanticModel, assignment)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::DeconstructionInfo GetDeconstructionInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::AssignmentExpressionSyntax ^ assignment);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.DeconstructionInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="assignment" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="assignment">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeconstructionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeconstructionInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.DeconstructionInfo GetDeconstructionInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax foreach);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.DeconstructionInfo GetDeconstructionInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax foreach) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeconstructionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax)" />
        <MemberSignature Language="F#" Value="static member GetDeconstructionInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax -&gt; Microsoft.CodeAnalysis.CSharp.DeconstructionInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeconstructionInfo (semanticModel, foreach)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::DeconstructionInfo GetDeconstructionInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::ForEachVariableStatementSyntax ^ foreach);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.DeconstructionInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="foreach" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="foreach">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeconstructionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="GetFirstDirective">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetFirstDirective (this Microsoft.CodeAnalysis.SyntaxNode node, Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,bool&gt; predicate = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetFirstDirective(class Microsoft.CodeAnalysis.SyntaxNode node, class System.Func`2&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool&gt; predicate) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetFirstDirective (node As SyntaxNode, Optional predicate As Func(Of DirectiveTriviaSyntax, Boolean) = null) As DirectiveTriviaSyntax" />
        <MemberSignature Language="F#" Value="static member GetFirstDirective : Microsoft.CodeAnalysis.SyntaxNode * Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool&gt; -&gt; Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective (node, predicate)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="predicate" Type="System.Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean&gt;" />
        </Parameters>
        <Docs>
          <param name="node">To be added.</param>
          <param name="predicate">To be added.</param>
          <summary>
            Gets the first directive of the tree rooted by this node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetForEachStatementInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEachStatement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEachStatement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax)" />
        <MemberSignature Language="F#" Value="static member GetForEachStatementInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax -&gt; Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo (semanticModel, forEachStatement)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::ForEachStatementInfo GetForEachStatementInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::CommonForEachStatementSyntax ^ forEachStatement);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="forEachStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="forEachStatement">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetForEachStatementInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)" />
        <MemberSignature Language="F#" Value="static member GetForEachStatementInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax -&gt; Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo (semanticModel, forEachStatement)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::ForEachStatementInfo GetForEachStatementInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::CSharp::Syntax::ForEachStatementSyntax ^ forEachStatement);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="forEachStatement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="forEachStatement">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" />
      </Targets>
      <Member MemberName="GetInConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion GetInConversion (this Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation compoundAssignment);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion GetInConversion(class Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation compoundAssignment) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetInConversion(Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetInConversion (compoundAssignment As ICompoundAssignmentOperation) As Conversion" />
        <MemberSignature Language="F#" Value="static member GetInConversion : Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetInConversion compoundAssignment" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::Conversion GetInConversion(Microsoft::CodeAnalysis::Operations::ICompoundAssignmentOperation ^ compoundAssignment);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compoundAssignment" Type="Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="compoundAssignment">To be added.</param>
          <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion" /> information from this <see cref="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" />. This
            conversion is applied before the operator is applied to the result of this conversion and <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Value" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetInConversion(Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetIndexerGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IPropertySymbol&gt; GetIndexerGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.IPropertySymbol&gt; GetIndexerGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetIndexerGroup : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IPropertySymbol&gt;" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup (semanticModel, expression, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IPropertySymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="GetLastDirective">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetLastDirective (this Microsoft.CodeAnalysis.SyntaxNode node, Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,bool&gt; predicate = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetLastDirective(class Microsoft.CodeAnalysis.SyntaxNode node, class System.Func`2&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool&gt; predicate) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetLastDirective (node As SyntaxNode, Optional predicate As Func(Of DirectiveTriviaSyntax, Boolean) = null) As DirectiveTriviaSyntax" />
        <MemberSignature Language="F#" Value="static member GetLastDirective : Microsoft.CodeAnalysis.SyntaxNode * Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool&gt; -&gt; Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective (node, predicate)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="predicate" Type="System.Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean&gt;" />
        </Parameters>
        <Docs>
          <param name="node">To be added.</param>
          <param name="predicate">To be added.</param>
          <summary>
            Gets the last directive of the tree rooted by this node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetMemberGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetMemberGroup : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup (semanticModel, attribute, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="attribute">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetMemberGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetMemberGroup : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup (semanticModel, initializer, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="initializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="initializer">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetMemberGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetMemberGroup : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup (semanticModel, expression, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" />
      </Targets>
      <Member MemberName="GetOutConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion GetOutConversion (this Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation compoundAssignment);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion GetOutConversion(class Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation compoundAssignment) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetOutConversion(Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetOutConversion (compoundAssignment As ICompoundAssignmentOperation) As Conversion" />
        <MemberSignature Language="F#" Value="static member GetOutConversion : Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetOutConversion compoundAssignment" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::Conversion GetOutConversion(Microsoft::CodeAnalysis::Operations::ICompoundAssignmentOperation ^ compoundAssignment);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compoundAssignment" Type="Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="compoundAssignment">To be added.</param>
          <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion" /> information from this <see cref="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" />. This
            conversion is applied after the operator is applied, before the result is assigned to <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Target" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetOutConversion(Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetQueryClauseInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.QueryClauseInfo GetQueryClauseInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.QueryClauseInfo GetQueryClauseInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetQueryClauseInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.CSharp.QueryClauseInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo (semanticModel, node, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.QueryClauseInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets the semantic information associated with a query clause.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeAliasInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeAliasInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo (semanticModel, position, nameSyntax, bindingOption)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::IAliasSymbol ^ GetSpeculativeAliasInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::IdentifierNameSyntax ^ nameSyntax, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="nameSyntax">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Conversion GetSpeculativeConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.Conversion GetSpeculativeConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeConversion : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.CSharp.Conversion" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion (semanticModel, position, expression, bindingOption)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::Conversion GetSpeculativeConversion(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::ExpressionSyntax ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo (semanticModel, position, attribute)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SymbolInfo GetSpeculativeSymbolInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::AttributeSyntax ^ attribute);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="attribute">To be added.</param>
          <summary>
            Bind the attribute in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about an attribute
            that did not actually appear in the source code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo (semanticModel, position, constructorInitializer)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SymbolInfo GetSpeculativeSymbolInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::ConstructorInitializerSyntax ^ constructorInitializer);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="constructorInitializer">To be added.</param>
          <summary>
            Bind the constructor initializer in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about a constructor
            initializer that did not actually appear in the source code.
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo (semanticModel, position, expression, bindingOption)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SymbolInfo GetSpeculativeSymbolInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::CrefSyntax ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
            Binds the CrefSyntax expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo (semanticModel, position, expression, bindingOption)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SymbolInfo GetSpeculativeSymbolInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::ExpressionSyntax ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
            Binds the expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeTypeInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo (semanticModel, position, expression, bindingOption)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::TypeInfo GetSpeculativeTypeInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::ExpressionSyntax ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
            Binds the expression in the context of the specified location and gets type information.
            This method is used to get type information about an expression that did not actually
            appear in the source code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo (semanticModel, attributeSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="attributeSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="attributeSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Returns what symbol(s), if any, the given attribute syntax bound to in the program.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo (semanticModel, constructorInitializer, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="constructorInitializer">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo (semanticModel, crefSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="crefSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="crefSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets the semantic information associated with a documentation comment cref.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo (semanticModel, expression, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Returns what symbol(s), if any, the given expression syntax bound to in the program.
            
            An AliasSymbol will never be returned by this method. What the alias refers to will be
            returned instead. To get information about aliases, call GetAliasInfo.
            
            If binding the type name C in the expression "new C(...)" the actual constructor bound to
            will be returned (or all constructor if overload resolution failed). This occurs as long as C
            unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple
            types, or C binds to a static class, then type(s) are returned.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo (semanticModel, node, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets the semantic information for an ordering clause in an orderby query clause.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo (semanticModel, node, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets the semantic information associated with a select or group clause.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetTypeInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo (semanticModel, attributeSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="attributeSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="attributeSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets type information about an attribute.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetTypeInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo (semanticModel, constructorInitializer, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="constructorInitializer">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets type information about a constructor initializer.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetTypeInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo (semanticModel, expression, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets type information about an expression.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetTypeInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo (semanticModel, node, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTokenList" />
      </Targets>
      <Member MemberName="Insert">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTokenList Insert (this Microsoft.CodeAnalysis.SyntaxTokenList list, int index, params Microsoft.CodeAnalysis.SyntaxToken[] items);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxTokenList Insert(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, int32 index, valuetype Microsoft.CodeAnalysis.SyntaxToken[] items) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Insert (list As SyntaxTokenList, index As Integer, ParamArray items As SyntaxToken()) As SyntaxTokenList" />
        <MemberSignature Language="F#" Value="static member Insert : Microsoft.CodeAnalysis.SyntaxTokenList * int * Microsoft.CodeAnalysis.SyntaxToken[] -&gt; Microsoft.CodeAnalysis.SyntaxTokenList" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert (list, index, items)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxTokenList Insert(Microsoft::CodeAnalysis::SyntaxTokenList list, int index, ... cli::array &lt;Microsoft::CodeAnalysis::SyntaxToken&gt; ^ items);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTokenList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
          <Parameter Name="index" Type="System.Int32" />
          <Parameter Name="items" Type="Microsoft.CodeAnalysis.SyntaxToken[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="list">To be added.</param>
          <param name="index">To be added.</param>
          <param name="items">To be added.</param>
          <summary>
            Insert one or more tokens in the list at the specified index.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsContextualKeyword">
        <MemberSignature Language="C#" Value="public static bool IsContextualKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsContextualKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsContextualKeyword (token As SyntaxToken) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsContextualKeyword : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsContextualKeyword(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsKeyword">
        <MemberSignature Language="C#" Value="public static bool IsKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsKeyword (token As SyntaxToken) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsKeyword : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsKeyword(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsReservedKeyword">
        <MemberSignature Language="C#" Value="public static bool IsReservedKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsReservedKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsReservedKeyword (token As SyntaxToken) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsReservedKeyword : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsReservedKeyword(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsVerbatimIdentifier">
        <MemberSignature Language="C#" Value="public static bool IsVerbatimIdentifier (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsVerbatimIdentifier(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsVerbatimIdentifier (token As SyntaxToken) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsVerbatimIdentifier : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsVerbatimIdentifier(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsVerbatimStringLiteral">
        <MemberSignature Language="C#" Value="public static bool IsVerbatimStringLiteral (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsVerbatimStringLiteral(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsVerbatimStringLiteral (token As SyntaxToken) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsVerbatimStringLiteral : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsVerbatimStringLiteral(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxNode node);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(class Microsoft.CodeAnalysis.SyntaxNode node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Kind (node As SyntaxNode) As SyntaxKind" />
        <MemberSignature Language="F#" Value="static member Kind : Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.CSharp.SyntaxKind" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind node" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::SyntaxKind Kind(Microsoft::CodeAnalysis::SyntaxNode ^ node);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
        </Parameters>
        <Docs>
          <param name="node">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Kind (nodeOrToken As SyntaxNodeOrToken) As SyntaxKind" />
        <MemberSignature Language="F#" Value="static member Kind : Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; Microsoft.CodeAnalysis.CSharp.SyntaxKind" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind nodeOrToken" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::SyntaxKind Kind(Microsoft::CodeAnalysis::SyntaxNodeOrToken nodeOrToken);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="nodeOrToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Kind (token As SyntaxToken) As SyntaxKind" />
        <MemberSignature Language="F#" Value="static member Kind : Microsoft.CodeAnalysis.SyntaxToken -&gt; Microsoft.CodeAnalysis.CSharp.SyntaxKind" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::SyntaxKind Kind(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTrivia" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxTrivia trivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxTrivia trivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Kind (trivia As SyntaxTrivia) As SyntaxKind" />
        <MemberSignature Language="F#" Value="static member Kind : Microsoft.CodeAnalysis.SyntaxTrivia -&gt; Microsoft.CodeAnalysis.CSharp.SyntaxKind" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind trivia" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::SyntaxKind Kind(Microsoft::CodeAnalysis::SyntaxTrivia trivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" RefType="this" />
        </Parameters>
        <Docs>
          <param name="trivia">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="ReplaceTrivia">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia (this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, Microsoft.CodeAnalysis.SyntaxTrivia newTrivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(valuetype Microsoft.CodeAnalysis.SyntaxToken token, valuetype Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia newTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceTrivia (token As SyntaxToken, oldTrivia As SyntaxTrivia, newTrivia As SyntaxTrivia) As SyntaxToken" />
        <MemberSignature Language="F#" Value="static member ReplaceTrivia : Microsoft.CodeAnalysis.SyntaxToken * Microsoft.CodeAnalysis.SyntaxTrivia * Microsoft.CodeAnalysis.SyntaxTrivia -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia (token, oldTrivia, newTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxToken ReplaceTrivia(Microsoft::CodeAnalysis::SyntaxToken token, Microsoft::CodeAnalysis::SyntaxTrivia oldTrivia, Microsoft::CodeAnalysis::SyntaxTrivia newTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="oldTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
          <Parameter Name="newTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
        </Parameters>
        <Docs>
          <param name="token" />
          <param name="oldTrivia">The trivia to be replaced.</param>
          <param name="newTrivia">The new trivia to use in the new tree in place of the old
            trivia.</param>
          <summary>
            Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in
            the token's leading or trailing trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="ReplaceTrivia">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia (this Microsoft.CodeAnalysis.SyntaxToken token, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(valuetype Microsoft.CodeAnalysis.SyntaxToken token, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, class System.Func`3&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceTrivia (token As SyntaxToken, trivia As IEnumerable(Of SyntaxTrivia), computeReplacementTrivia As Func(Of SyntaxTrivia, SyntaxTrivia, SyntaxTrivia)) As SyntaxToken" />
        <MemberSignature Language="F#" Value="static member ReplaceTrivia : Microsoft.CodeAnalysis.SyntaxToken * seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; * Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia (token, trivia, computeReplacementTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxToken ReplaceTrivia(Microsoft::CodeAnalysis::SyntaxToken token, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ trivia, Func&lt;Microsoft::CodeAnalysis::SyntaxTrivia, Microsoft::CodeAnalysis::SyntaxTrivia, Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ computeReplacementTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="trivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
          <Parameter Name="computeReplacementTrivia" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        </Parameters>
        <Docs>
          <param name="token" />
          <param name="trivia">The trivia to be replaced; descendants of the root token.</param>
          <param name="computeReplacementTrivia">A function that computes a replacement trivia for
            the argument trivia. The first argument is the original trivia. The second argument is
            the same trivia rewritten with replaced structure.</param>
          <summary>
            Creates a new token with the specified old trivia replaced with computed new trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, expressionBody, speculativeModel)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::ArrowExpressionClauseSyntax ^ expressionBody, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expressionBody" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expressionBody">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with an expression body that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an expression body that did not appear in source code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, attribute, speculativeModel)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::AttributeSyntax ^ attribute, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="attribute">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with an attribute that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an attribute that did not appear in source code. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, constructorInitializer, speculativeModel)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::ConstructorInitializerSyntax ^ constructorInitializer, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="constructorInitializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="constructorInitializer">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with a constructor initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a constructor initializer that did not appear in source code. 
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, crefSyntax, speculativeModel)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::CrefSyntax ^ crefSyntax, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="crefSyntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="crefSyntax">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with a cref syntax node that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a cref syntax that did not appear in source code. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, initializer, speculativeModel)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::EqualsValueClauseSyntax ^ initializer, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="initializer" Type="Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="initializer">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with an initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a field initializer or default parameter value that did not appear in source code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, statement, speculativeModel)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::StatementSyntax ^ statement, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="statement" Type="Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="statement">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with a statement that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a statement that did not appear in source code. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, out Microsoft.CodeAnalysis.SemanticModel speculativeModel, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption = Microsoft.CodeAnalysis.SpeculativeBindingOption.BindAsExpression);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax *  * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, type, speculativeModel, bindingOption)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="type" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="type">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with a type syntax node that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a type syntax that did not appear in source code. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModelForMethodBody">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModelForMethodBody (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax accessor, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModelForMethodBody(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax accessor, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModelForMethodBody : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody (semanticModel, position, accessor, speculativeModel)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModelForMethodBody(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::AccessorDeclarationSyntax ^ accessor, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="accessor" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="accessor">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position" /> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModelForMethodBody">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModelForMethodBody (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax method, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSpeculativeSemanticModelForMethodBody(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax method, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModelForMethodBody : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody (semanticModel, position, method, speculativeModel)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModelForMethodBody(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::CSharp::Syntax::BaseMethodDeclarationSyntax ^ method, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="method" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="method">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position" /> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="VarianceKindFromToken">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VarianceKind VarianceKindFromToken (this Microsoft.CodeAnalysis.SyntaxToken node);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.VarianceKind VarianceKindFromToken(valuetype Microsoft.CodeAnalysis.SyntaxToken node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function VarianceKindFromToken (node As SyntaxToken) As VarianceKind" />
        <MemberSignature Language="F#" Value="static member VarianceKindFromToken : Microsoft.CodeAnalysis.SyntaxToken -&gt; Microsoft.CodeAnalysis.VarianceKind" Usage="Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken node" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VarianceKind VarianceKindFromToken(Microsoft::CodeAnalysis::SyntaxToken node);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VarianceKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="node">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation" />
      </Targets>
      <Member MemberName="Emit">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.Emit.EmitResult Emit (this Microsoft.CodeAnalysis.CSharp.CSharpCompilation compilation, string outputPath, string pdbPath = null, string xmlDocumentationPath = null, string win32ResourcesPath = null, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ResourceDescription&gt; manifestResources = null, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.Emit.EmitResult Emit(class Microsoft.CodeAnalysis.CSharp.CSharpCompilation compilation, string outputPath, string pdbPath, string xmlDocumentationPath, string win32ResourcesPath, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.ResourceDescription&gt; manifestResources, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.CSharpFileSystemExtensions.Emit(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member Emit : Microsoft.CodeAnalysis.CSharp.CSharpCompilation * string * string * string * string * seq&lt;Microsoft.CodeAnalysis.ResourceDescription&gt; * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.Emit.EmitResult" Usage="Microsoft.CodeAnalysis.CSharp.CSharpFileSystemExtensions.Emit (compilation, outputPath, pdbPath, xmlDocumentationPath, win32ResourcesPath, manifestResources, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.Emit.EmitResult</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.CSharp.CSharpCompilation" RefType="this" />
          <Parameter Name="outputPath" Type="System.String" />
          <Parameter Name="pdbPath" Type="System.String" />
          <Parameter Name="xmlDocumentationPath" Type="System.String" />
          <Parameter Name="win32ResourcesPath" Type="System.String" />
          <Parameter Name="manifestResources" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ResourceDescription&gt;" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="compilation">Compilation.</param>
          <param name="outputPath">Path of the file to which the PE image will be written.</param>
          <param name="pdbPath">Path of the file to which the compilation's debug info will be written.
            Also embedded in the output file.  Null to forego PDB generation.
            </param>
          <param name="xmlDocumentationPath">Path of the file to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
          <param name="win32ResourcesPath">Path of the file from which the compilation's Win32 resources will be read (in RES format).  
            Null to indicate that there are none.</param>
          <param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
          <param name="cancellationToken">To cancel the emit process.</param>
          <summary>
            Emit the IL for the compilation into the specified stream.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.CSharpFileSystemExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.CSharpFileSystemExtensions.Emit(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.CSharp.LanguageVersion" />
      </Targets>
      <Member MemberName="MapSpecifiedToEffectiveVersion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.LanguageVersion MapSpecifiedToEffectiveVersion (this Microsoft.CodeAnalysis.CSharp.LanguageVersion version);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.CSharp.LanguageVersion MapSpecifiedToEffectiveVersion(valuetype Microsoft.CodeAnalysis.CSharp.LanguageVersion version) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.MapSpecifiedToEffectiveVersion(Microsoft.CodeAnalysis.CSharp.LanguageVersion)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapSpecifiedToEffectiveVersion (version As LanguageVersion) As LanguageVersion" />
        <MemberSignature Language="F#" Value="static member MapSpecifiedToEffectiveVersion : Microsoft.CodeAnalysis.CSharp.LanguageVersion -&gt; Microsoft.CodeAnalysis.CSharp.LanguageVersion" Usage="Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.MapSpecifiedToEffectiveVersion version" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::LanguageVersion MapSpecifiedToEffectiveVersion(Microsoft::CodeAnalysis::CSharp::LanguageVersion version);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.LanguageVersion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="version" Type="Microsoft.CodeAnalysis.CSharp.LanguageVersion" RefType="this" />
        </Parameters>
        <Docs>
          <param name="version">To be added.</param>
          <summary>
            Map a language version (such as Default, Latest, or CSharpN) to a specific version (CSharpM).
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts" Member="M:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.MapSpecifiedToEffectiveVersion(Microsoft.CodeAnalysis.CSharp.LanguageVersion)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.CSharp.LanguageVersion" />
      </Targets>
      <Member MemberName="ToDisplayString">
        <MemberSignature Language="C#" Value="public static string ToDisplayString (this Microsoft.CodeAnalysis.CSharp.LanguageVersion version);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToDisplayString(valuetype Microsoft.CodeAnalysis.CSharp.LanguageVersion version) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.ToDisplayString(Microsoft.CodeAnalysis.CSharp.LanguageVersion)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDisplayString (version As LanguageVersion) As String" />
        <MemberSignature Language="F#" Value="static member ToDisplayString : Microsoft.CodeAnalysis.CSharp.LanguageVersion -&gt; string" Usage="Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.ToDisplayString version" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ ToDisplayString(Microsoft::CodeAnalysis::CSharp::LanguageVersion version);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="version" Type="Microsoft.CodeAnalysis.CSharp.LanguageVersion" RefType="this" />
        </Parameters>
        <Docs>
          <param name="version">To be added.</param>
          <summary>
            Displays the version number in the format expected on the command-line (/langver flag).
            For instance, "6", "7", "7.1", "latest".
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts" Member="M:Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts.ToDisplayString(Microsoft.CodeAnalysis.CSharp.LanguageVersion)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="NormalizeWhitespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace (this Microsoft.CodeAnalysis.SyntaxToken token, string indentation, bool elasticTrivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace(valuetype Microsoft.CodeAnalysis.SyntaxToken token, string indentation, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeWhitespace (token As SyntaxToken, indentation As String, elasticTrivia As Boolean) As SyntaxToken" />
        <MemberSignature Language="F#" Value="static member NormalizeWhitespace : Microsoft.CodeAnalysis.SyntaxToken * string * bool -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace (token, indentation, elasticTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxToken NormalizeWhitespace(Microsoft::CodeAnalysis::SyntaxToken token, System::String ^ indentation, bool elasticTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="token">The token to normalize.</param>
          <param name="indentation">A sequence of whitespace characters that defines a single level of indentation.</param>
          <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
          <summary>
            Creates a new syntax token with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="NormalizeWhitespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace (this Microsoft.CodeAnalysis.SyntaxToken token, string indentation = &quot;    &quot;, string eol = &quot;\r\n&quot;, bool elasticTrivia = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace(valuetype Microsoft.CodeAnalysis.SyntaxToken token, string indentation, string eol, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.String,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeWhitespace (token As SyntaxToken, Optional indentation As String = &quot;    &quot;, Optional eol As String = &quot;\r\n&quot;, Optional elasticTrivia As Boolean = false) As SyntaxToken" />
        <MemberSignature Language="F#" Value="static member NormalizeWhitespace : Microsoft.CodeAnalysis.SyntaxToken * string * string * bool -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace (token, indentation, eol, elasticTrivia)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="eol" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="token">The token to normalize.</param>
          <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
          <param name="eol">An optional sequence of whitespace characters used for end of line.</param>
          <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
          <summary>
            Creates a new syntax token with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />
      </Targets>
      <Member MemberName="NormalizeWhitespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace (this Microsoft.CodeAnalysis.SyntaxTriviaList list, string indentation, bool elasticTrivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace(valuetype Microsoft.CodeAnalysis.SyntaxTriviaList list, string indentation, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeWhitespace (list As SyntaxTriviaList, indentation As String, elasticTrivia As Boolean) As SyntaxTriviaList" />
        <MemberSignature Language="F#" Value="static member NormalizeWhitespace : Microsoft.CodeAnalysis.SyntaxTriviaList * string * bool -&gt; Microsoft.CodeAnalysis.SyntaxTriviaList" Usage="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace (list, indentation, elasticTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxTriviaList NormalizeWhitespace(Microsoft::CodeAnalysis::SyntaxTriviaList list, System::String ^ indentation, bool elasticTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTriviaList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="list">The trivia list to normalize.</param>
          <param name="indentation">A sequence of whitespace characters that defines a single level of indentation.</param>
          <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
          <summary>
            Creates a new syntax trivia list with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />
      </Targets>
      <Member MemberName="NormalizeWhitespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace (this Microsoft.CodeAnalysis.SyntaxTriviaList list, string indentation = &quot;    &quot;, string eol = &quot;\r\n&quot;, bool elasticTrivia = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace(valuetype Microsoft.CodeAnalysis.SyntaxTriviaList list, string indentation, string eol, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeWhitespace (list As SyntaxTriviaList, Optional indentation As String = &quot;    &quot;, Optional eol As String = &quot;\r\n&quot;, Optional elasticTrivia As Boolean = false) As SyntaxTriviaList" />
        <MemberSignature Language="F#" Value="static member NormalizeWhitespace : Microsoft.CodeAnalysis.SyntaxTriviaList * string * string * bool -&gt; Microsoft.CodeAnalysis.SyntaxTriviaList" Usage="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace (list, indentation, eol, elasticTrivia)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTriviaList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="eol" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="list">The trivia list to normalize.</param>
          <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
          <param name="eol">An optional sequence of whitespace characters used for end of line.</param>
          <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
          <summary>
            Creates a new syntax trivia list with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ToSyntaxTriviaList">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTriviaList ToSyntaxTriviaList (this System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; sequence);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxTriviaList ToSyntaxTriviaList(class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; sequence) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.ToSyntaxTriviaList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToSyntaxTriviaList (sequence As IEnumerable(Of SyntaxTrivia)) As SyntaxTriviaList" />
        <MemberSignature Language="F#" Value="static member ToSyntaxTriviaList : seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; Microsoft.CodeAnalysis.SyntaxTriviaList" Usage="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.ToSyntaxTriviaList sequence" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxTriviaList ToSyntaxTriviaList(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ sequence);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTriviaList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="sequence" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="sequence">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.ToSyntaxTriviaList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax" />
      </Targets>
      <Member MemberName="Update">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax Update (this Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax syntax, Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken thisKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax Update(class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax syntax, valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; attributeLists, valuetype Microsoft.CodeAnalysis.SyntaxTokenList modifiers, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, class Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, valuetype Microsoft.CodeAnalysis.SyntaxToken thisKeyword, class Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList, class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Update (syntax As IndexerDeclarationSyntax, attributeLists As SyntaxList(Of AttributeListSyntax), modifiers As SyntaxTokenList, type As TypeSyntax, explicitInterfaceSpecifier As ExplicitInterfaceSpecifierSyntax, thisKeyword As SyntaxToken, parameterList As BracketedParameterListSyntax, accessorList As AccessorListSyntax) As IndexerDeclarationSyntax" />
        <MemberSignature Language="F#" Value="static member Update : Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax * Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; * Microsoft.CodeAnalysis.SyntaxTokenList * Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax * Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax * Microsoft.CodeAnalysis.SyntaxToken * Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax * Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax -&gt; Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax" Usage="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update (syntax, attributeLists, modifiers, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::Syntax::IndexerDeclarationSyntax ^ Update(Microsoft::CodeAnalysis::CSharp::Syntax::IndexerDeclarationSyntax ^ syntax, Microsoft::CodeAnalysis::SyntaxList&lt;Microsoft::CodeAnalysis::CSharp::Syntax::AttributeListSyntax ^&gt; attributeLists, Microsoft::CodeAnalysis::SyntaxTokenList modifiers, Microsoft::CodeAnalysis::CSharp::Syntax::TypeSyntax ^ type, Microsoft::CodeAnalysis::CSharp::Syntax::ExplicitInterfaceSpecifierSyntax ^ explicitInterfaceSpecifier, Microsoft::CodeAnalysis::SyntaxToken thisKeyword, Microsoft::CodeAnalysis::CSharp::Syntax::BracketedParameterListSyntax ^ parameterList, Microsoft::CodeAnalysis::CSharp::Syntax::AccessorListSyntax ^ accessorList);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="syntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax" RefType="this" />
          <Parameter Name="attributeLists" Type="Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt;" />
          <Parameter Name="modifiers" Type="Microsoft.CodeAnalysis.SyntaxTokenList" />
          <Parameter Name="type" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" />
          <Parameter Name="explicitInterfaceSpecifier" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax" />
          <Parameter Name="thisKeyword" Type="Microsoft.CodeAnalysis.SyntaxToken" />
          <Parameter Name="parameterList" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax" />
          <Parameter Name="accessorList" Type="Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax" />
        </Parameters>
        <Docs>
          <param name="syntax">To be added.</param>
          <param name="attributeLists">To be added.</param>
          <param name="modifiers">To be added.</param>
          <param name="type">To be added.</param>
          <param name="explicitInterfaceSpecifier">To be added.</param>
          <param name="thisKeyword">To be added.</param>
          <param name="parameterList">To be added.</param>
          <param name="accessorList">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax" />
      </Targets>
      <Member MemberName="Update">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax Update (this Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax syntax, Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax&gt; constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxToken semicolonToken);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax Update(class Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax syntax, valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; attributeLists, valuetype Microsoft.CodeAnalysis.SyntaxTokenList modifiers, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, class Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, valuetype Microsoft.CodeAnalysis.SyntaxToken identifier, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax&gt; constraintClauses, class Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, valuetype Microsoft.CodeAnalysis.SyntaxToken semicolonToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Update (syntax As MethodDeclarationSyntax, attributeLists As SyntaxList(Of AttributeListSyntax), modifiers As SyntaxTokenList, returnType As TypeSyntax, explicitInterfaceSpecifier As ExplicitInterfaceSpecifierSyntax, identifier As SyntaxToken, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, constraintClauses As SyntaxList(Of TypeParameterConstraintClauseSyntax), block As BlockSyntax, semicolonToken As SyntaxToken) As MethodDeclarationSyntax" />
        <MemberSignature Language="F#" Value="static member Update : Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax * Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; * Microsoft.CodeAnalysis.SyntaxTokenList * Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax * Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax * Microsoft.CodeAnalysis.SyntaxToken * Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax * Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax * Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax&gt; * Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax * Microsoft.CodeAnalysis.SyntaxToken -&gt; Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax" Usage="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update (syntax, attributeLists, modifiers, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, block, semicolonToken)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::Syntax::MethodDeclarationSyntax ^ Update(Microsoft::CodeAnalysis::CSharp::Syntax::MethodDeclarationSyntax ^ syntax, Microsoft::CodeAnalysis::SyntaxList&lt;Microsoft::CodeAnalysis::CSharp::Syntax::AttributeListSyntax ^&gt; attributeLists, Microsoft::CodeAnalysis::SyntaxTokenList modifiers, Microsoft::CodeAnalysis::CSharp::Syntax::TypeSyntax ^ returnType, Microsoft::CodeAnalysis::CSharp::Syntax::ExplicitInterfaceSpecifierSyntax ^ explicitInterfaceSpecifier, Microsoft::CodeAnalysis::SyntaxToken identifier, Microsoft::CodeAnalysis::CSharp::Syntax::TypeParameterListSyntax ^ typeParameterList, Microsoft::CodeAnalysis::CSharp::Syntax::ParameterListSyntax ^ parameterList, Microsoft::CodeAnalysis::SyntaxList&lt;Microsoft::CodeAnalysis::CSharp::Syntax::TypeParameterConstraintClauseSyntax ^&gt; constraintClauses, Microsoft::CodeAnalysis::CSharp::Syntax::BlockSyntax ^ block, Microsoft::CodeAnalysis::SyntaxToken semicolonToken);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="syntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax" RefType="this" />
          <Parameter Name="attributeLists" Type="Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt;" />
          <Parameter Name="modifiers" Type="Microsoft.CodeAnalysis.SyntaxTokenList" />
          <Parameter Name="returnType" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" />
          <Parameter Name="explicitInterfaceSpecifier" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax" />
          <Parameter Name="identifier" Type="Microsoft.CodeAnalysis.SyntaxToken" />
          <Parameter Name="typeParameterList" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax" />
          <Parameter Name="parameterList" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax" />
          <Parameter Name="constraintClauses" Type="Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax&gt;" />
          <Parameter Name="block" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax" />
          <Parameter Name="semicolonToken" Type="Microsoft.CodeAnalysis.SyntaxToken" />
        </Parameters>
        <Docs>
          <param name="syntax">To be added.</param>
          <param name="attributeLists">To be added.</param>
          <param name="modifiers">To be added.</param>
          <param name="returnType">To be added.</param>
          <param name="explicitInterfaceSpecifier">To be added.</param>
          <param name="identifier">To be added.</param>
          <param name="typeParameterList">To be added.</param>
          <param name="parameterList">To be added.</param>
          <param name="constraintClauses">To be added.</param>
          <param name="block">To be added.</param>
          <param name="semicolonToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax" />
      </Targets>
      <Member MemberName="Update">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax Update (this Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax syntax, Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxToken semicolonToken);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax Update(class Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax syntax, valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; attributeLists, valuetype Microsoft.CodeAnalysis.SyntaxTokenList modifiers, class Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, valuetype Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, valuetype Microsoft.CodeAnalysis.SyntaxToken operatorToken, class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, class Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, valuetype Microsoft.CodeAnalysis.SyntaxToken semicolonToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Update (syntax As OperatorDeclarationSyntax, attributeLists As SyntaxList(Of AttributeListSyntax), modifiers As SyntaxTokenList, returnType As TypeSyntax, operatorKeyword As SyntaxToken, operatorToken As SyntaxToken, parameterList As ParameterListSyntax, block As BlockSyntax, semicolonToken As SyntaxToken) As OperatorDeclarationSyntax" />
        <MemberSignature Language="F#" Value="static member Update : Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax * Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt; * Microsoft.CodeAnalysis.SyntaxTokenList * Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax * Microsoft.CodeAnalysis.SyntaxToken * Microsoft.CodeAnalysis.SyntaxToken * Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax * Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax * Microsoft.CodeAnalysis.SyntaxToken -&gt; Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax" Usage="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update (syntax, attributeLists, modifiers, returnType, operatorKeyword, operatorToken, parameterList, block, semicolonToken)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::Syntax::OperatorDeclarationSyntax ^ Update(Microsoft::CodeAnalysis::CSharp::Syntax::OperatorDeclarationSyntax ^ syntax, Microsoft::CodeAnalysis::SyntaxList&lt;Microsoft::CodeAnalysis::CSharp::Syntax::AttributeListSyntax ^&gt; attributeLists, Microsoft::CodeAnalysis::SyntaxTokenList modifiers, Microsoft::CodeAnalysis::CSharp::Syntax::TypeSyntax ^ returnType, Microsoft::CodeAnalysis::SyntaxToken operatorKeyword, Microsoft::CodeAnalysis::SyntaxToken operatorToken, Microsoft::CodeAnalysis::CSharp::Syntax::ParameterListSyntax ^ parameterList, Microsoft::CodeAnalysis::CSharp::Syntax::BlockSyntax ^ block, Microsoft::CodeAnalysis::SyntaxToken semicolonToken);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="syntax" Type="Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax" RefType="this" />
          <Parameter Name="attributeLists" Type="Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt;" />
          <Parameter Name="modifiers" Type="Microsoft.CodeAnalysis.SyntaxTokenList" />
          <Parameter Name="returnType" Type="Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" />
          <Parameter Name="operatorKeyword" Type="Microsoft.CodeAnalysis.SyntaxToken" />
          <Parameter Name="operatorToken" Type="Microsoft.CodeAnalysis.SyntaxToken" />
          <Parameter Name="parameterList" Type="Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax" />
          <Parameter Name="block" Type="Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax" />
          <Parameter Name="semicolonToken" Type="Microsoft.CodeAnalysis.SyntaxToken" />
        </Parameters>
        <Docs>
          <param name="syntax">To be added.</param>
          <param name="attributeLists">To be added.</param>
          <param name="modifiers">To be added.</param>
          <param name="returnType">To be added.</param>
          <param name="operatorKeyword">To be added.</param>
          <param name="operatorToken">To be added.</param>
          <param name="parameterList">To be added.</param>
          <param name="block">To be added.</param>
          <param name="semicolonToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.Update(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax" />
      </Targets>
      <Member MemberName="WithIdentifier">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax WithIdentifier (this Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax simpleName, Microsoft.CodeAnalysis.SyntaxToken identifier);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax WithIdentifier(class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax simpleName, valuetype Microsoft.CodeAnalysis.SyntaxToken identifier) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.WithIdentifier(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithIdentifier (simpleName As SimpleNameSyntax, identifier As SyntaxToken) As SimpleNameSyntax" />
        <MemberSignature Language="F#" Value="static member WithIdentifier : Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax * Microsoft.CodeAnalysis.SyntaxToken -&gt; Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax" Usage="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.WithIdentifier (simpleName, identifier)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::CSharp::Syntax::SimpleNameSyntax ^ WithIdentifier(Microsoft::CodeAnalysis::CSharp::Syntax::SimpleNameSyntax ^ simpleName, Microsoft::CodeAnalysis::SyntaxToken identifier);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="simpleName" Type="Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax" RefType="this" />
          <Parameter Name="identifier" Type="Microsoft.CodeAnalysis.SyntaxToken" />
        </Parameters>
        <Docs>
          <param name="simpleName" />
          <param name="identifier" />
          <summary>
            Updates the given SimpleNameSyntax node with the given identifier token.
            This function is a wrapper that calls WithIdentifier on derived syntax nodes.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.WithIdentifier(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="TryGetInferredMemberName">
        <MemberSignature Language="C#" Value="public static string TryGetInferredMemberName (this Microsoft.CodeAnalysis.SyntaxNode syntax);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TryGetInferredMemberName(class Microsoft.CodeAnalysis.SyntaxNode syntax) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.TryGetInferredMemberName(Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryGetInferredMemberName (syntax As SyntaxNode) As String" />
        <MemberSignature Language="F#" Value="static member TryGetInferredMemberName : Microsoft.CodeAnalysis.SyntaxNode -&gt; string" Usage="Microsoft.CodeAnalysis.CSharp.SyntaxFacts.TryGetInferredMemberName syntax" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ TryGetInferredMemberName(Microsoft::CodeAnalysis::SyntaxNode ^ syntax);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="syntax" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
        </Parameters>
        <Docs>
          <param name="syntax">To be added.</param>
          <summary>
            Given an initializer expression infer the name of anonymous property or tuple element.
            Returns null if unsuccessful
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.SyntaxFacts" Member="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.TryGetInferredMemberName(Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.TypedConstant" />
      </Targets>
      <Member MemberName="ToCSharpString">
        <MemberSignature Language="C#" Value="public static string ToCSharpString (this Microsoft.CodeAnalysis.TypedConstant constant);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToCSharpString(valuetype Microsoft.CodeAnalysis.TypedConstant constant) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharp.TypedConstantExtensions.ToCSharpString(Microsoft.CodeAnalysis.TypedConstant)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToCSharpString (constant As TypedConstant) As String" />
        <MemberSignature Language="F#" Value="static member ToCSharpString : Microsoft.CodeAnalysis.TypedConstant -&gt; string" Usage="Microsoft.CodeAnalysis.CSharp.TypedConstantExtensions.ToCSharpString constant" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ ToCSharpString(Microsoft::CodeAnalysis::TypedConstant constant);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="constant" Type="Microsoft.CodeAnalysis.TypedConstant" RefType="this" />
        </Parameters>
        <Docs>
          <param name="constant">To be added.</param>
          <summary>
            Returns the System.String that represents the current TypedConstant.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharp.TypedConstantExtensions" Member="M:Microsoft.CodeAnalysis.CSharp.TypedConstantExtensions.ToCSharpString(Microsoft.CodeAnalysis.TypedConstant)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTokenList" />
      </Targets>
      <Member MemberName="Any">
        <MemberSignature Language="C#" Value="public static bool Any (this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.Any(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any (list As SyntaxTokenList, kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member Any : Microsoft.CodeAnalysis.SyntaxTokenList * Microsoft.CodeAnalysis.CSharp.SyntaxKind -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharpExtensions.Any (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(Microsoft::CodeAnalysis::SyntaxTokenList list, Microsoft::CodeAnalysis::CSharp::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list" />
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind" /> to test for.</param>
          <summary>
            Tests whether a list contains a token of a particular kind.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.Any(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />
      </Targets>
      <Member MemberName="Any">
        <MemberSignature Language="C#" Value="public static bool Any (this Microsoft.CodeAnalysis.SyntaxTriviaList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any(valuetype Microsoft.CodeAnalysis.SyntaxTriviaList list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.Any(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any (list As SyntaxTriviaList, kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member Any : Microsoft.CodeAnalysis.SyntaxTriviaList * Microsoft.CodeAnalysis.CSharp.SyntaxKind -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharpExtensions.Any (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(Microsoft::CodeAnalysis::SyntaxTriviaList list, Microsoft::CodeAnalysis::CSharp::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>
            True if the list has at least one trivia of the specified kind.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.Any(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />
      </Targets>
      <Member MemberName="Any&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static bool Any&lt;TNode&gt; (this Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SeparatedSyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.Any``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TNode As SyntaxNode) (list As SeparatedSyntaxList(Of TNode), kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member Any : Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; * Microsoft.CodeAnalysis.CSharp.SyntaxKind -&gt; bool (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.CSharpExtensions.Any (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(Microsoft::CodeAnalysis::SeparatedSyntaxList&lt;TNode&gt; list, Microsoft::CodeAnalysis::CSharp::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>
            True if the list has at least one node of the specified kind.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.Any``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxList`1" />
      </Targets>
      <Member MemberName="Any&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static bool Any&lt;TNode&gt; (this Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.Any``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TNode As SyntaxNode) (list As SyntaxList(Of TNode), kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member Any : Microsoft.CodeAnalysis.SyntaxList&lt;'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; * Microsoft.CodeAnalysis.CSharp.SyntaxKind -&gt; bool (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.CSharpExtensions.Any (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(Microsoft::CodeAnalysis::SyntaxList&lt;TNode&gt; list, Microsoft::CodeAnalysis::CSharp::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>
            True if the list has at least one node of the specified kind.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.Any``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTokenList" />
      </Targets>
      <Member MemberName="IndexOf">
        <MemberSignature Language="C#" Value="public static int IndexOf (this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf (list As SyntaxTokenList, kind As SyntaxKind) As Integer" />
        <MemberSignature Language="F#" Value="static member IndexOf : Microsoft.CodeAnalysis.SyntaxTokenList * Microsoft.CodeAnalysis.CSharp.SyntaxKind -&gt; int" Usage="Microsoft.CodeAnalysis.CSharpExtensions.IndexOf (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Microsoft::CodeAnalysis::SyntaxTokenList list, Microsoft::CodeAnalysis::CSharp::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list">Token list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind" /> to find.</param>
          <summary>
            Returns the index of the first token of a specified kind in the token list.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />
      </Targets>
      <Member MemberName="IndexOf">
        <MemberSignature Language="C#" Value="public static int IndexOf (this Microsoft.CodeAnalysis.SyntaxTriviaList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(valuetype Microsoft.CodeAnalysis.SyntaxTriviaList list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf (list As SyntaxTriviaList, kind As SyntaxKind) As Integer" />
        <MemberSignature Language="F#" Value="static member IndexOf : Microsoft.CodeAnalysis.SyntaxTriviaList * Microsoft.CodeAnalysis.CSharp.SyntaxKind -&gt; int" Usage="Microsoft.CodeAnalysis.CSharpExtensions.IndexOf (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Microsoft::CodeAnalysis::SyntaxTriviaList list, Microsoft::CodeAnalysis::CSharp::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list">Trivia list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind" /> to find.</param>
          <summary>
            Returns the index of the first trivia of a specified kind in the trivia list.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />
      </Targets>
      <Member MemberName="IndexOf&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static int IndexOf&lt;TNode&gt; (this Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SeparatedSyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of TNode As SyntaxNode) (list As SeparatedSyntaxList(Of TNode), kind As SyntaxKind) As Integer" />
        <MemberSignature Language="F#" Value="static member IndexOf : Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; * Microsoft.CodeAnalysis.CSharp.SyntaxKind -&gt; int (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.CSharpExtensions.IndexOf (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Microsoft::CodeAnalysis::SeparatedSyntaxList&lt;TNode&gt; list, Microsoft::CodeAnalysis::CSharp::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">Node list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind" /> to find.</param>
          <summary>
            Returns the index of the first node of a specified kind in the node list.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxList`1" />
      </Targets>
      <Member MemberName="IndexOf&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static int IndexOf&lt;TNode&gt; (this Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of TNode As SyntaxNode) (list As SyntaxList(Of TNode), kind As SyntaxKind) As Integer" />
        <MemberSignature Language="F#" Value="static member IndexOf : Microsoft.CodeAnalysis.SyntaxList&lt;'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; * Microsoft.CodeAnalysis.CSharp.SyntaxKind -&gt; int (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.CSharpExtensions.IndexOf (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Microsoft::CodeAnalysis::SyntaxList&lt;TNode&gt; list, Microsoft::CodeAnalysis::CSharp::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">Node list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind" /> to find.</param>
          <summary>
            Returns the index of the first node of a specified kind in the node list.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKind(class Microsoft.CodeAnalysis.SyntaxNode node, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsKind (node As SyntaxNode, kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsKind : Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.CSharp.SyntaxKind -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharpExtensions.IsKind (node, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsKind(Microsoft::CodeAnalysis::SyntaxNode ^ node, Microsoft::CodeAnalysis::CSharp::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="node">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKind(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsKind (nodeOrToken As SyntaxNodeOrToken, kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsKind : Microsoft.CodeAnalysis.SyntaxNodeOrToken * Microsoft.CodeAnalysis.CSharp.SyntaxKind -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharpExtensions.IsKind (nodeOrToken, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsKind(Microsoft::CodeAnalysis::SyntaxNodeOrToken nodeOrToken, Microsoft::CodeAnalysis::CSharp::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="nodeOrToken">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKind(valuetype Microsoft.CodeAnalysis.SyntaxToken token, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsKind (token As SyntaxToken, kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsKind : Microsoft.CodeAnalysis.SyntaxToken * Microsoft.CodeAnalysis.CSharp.SyntaxKind -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharpExtensions.IsKind (token, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsKind(Microsoft::CodeAnalysis::SyntaxToken token, Microsoft::CodeAnalysis::CSharp::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTrivia" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxTrivia trivia, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKind(valuetype Microsoft.CodeAnalysis.SyntaxTrivia trivia, valuetype Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsKind (trivia As SyntaxTrivia, kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsKind : Microsoft.CodeAnalysis.SyntaxTrivia * Microsoft.CodeAnalysis.CSharp.SyntaxKind -&gt; bool" Usage="Microsoft.CodeAnalysis.CSharpExtensions.IsKind (trivia, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsKind(Microsoft::CodeAnalysis::SyntaxTrivia trivia, Microsoft::CodeAnalysis::CSharp::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.CSharp.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="trivia">To be added.</param>
          <param name="kind">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.CSharpExtensions" Member="M:Microsoft.CodeAnalysis.CSharpExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.CSharp.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="WithAnalyzers">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers WithAnalyzers (this Microsoft.CodeAnalysis.Compilation compilation, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer&gt; analyzers, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options = null, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers WithAnalyzers(class Microsoft.CodeAnalysis.Compilation compilation, valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer&gt; analyzers, class Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions.WithAnalyzers(Microsoft.CodeAnalysis.Compilation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member WithAnalyzers : Microsoft.CodeAnalysis.Compilation * System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer&gt; * Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers" Usage="Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions.WithAnalyzers (compilation, analyzers, options, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
          <Parameter Name="analyzers" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer&gt;" />
          <Parameter Name="options" Type="Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="compilation">Compilation to which analyzers are to be added.</param>
          <param name="analyzers">The set of analyzers to include in future analyses.</param>
          <param name="options">Options that are passed to analyzers.</param>
          <param name="cancellationToken">A cancellation token that can be used to abort analysis.</param>
          <summary>
            Returns a new compilation with attached diagnostic analyzers.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions" Member="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions.WithAnalyzers(Microsoft.CodeAnalysis.Compilation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="WithAnalyzers">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers WithAnalyzers (this Microsoft.CodeAnalysis.Compilation compilation, System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer&gt; analyzers, Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions analysisOptions);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers WithAnalyzers(class Microsoft.CodeAnalysis.Compilation compilation, valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer&gt; analyzers, class Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions analysisOptions) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions.WithAnalyzers(Microsoft.CodeAnalysis.Compilation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions)" />
        <MemberSignature Language="F#" Value="static member WithAnalyzers : Microsoft.CodeAnalysis.Compilation * System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer&gt; * Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions -&gt; Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers" Usage="Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions.WithAnalyzers (compilation, analyzers, analysisOptions)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::Diagnostics::CompilationWithAnalyzers ^ WithAnalyzers(Microsoft::CodeAnalysis::Compilation ^ compilation, System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::Diagnostics::DiagnosticAnalyzer ^&gt; analyzers, Microsoft::CodeAnalysis::Diagnostics::CompilationWithAnalyzersOptions ^ analysisOptions);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
          <Parameter Name="analyzers" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer&gt;" />
          <Parameter Name="analysisOptions" Type="Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions" />
        </Parameters>
        <Docs>
          <param name="compilation">Compilation to which analyzers are to be added.</param>
          <param name="analyzers">The set of analyzers to include in future analyses.</param>
          <param name="analysisOptions">Options to configure analyzer execution within <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers" />.</param>
          <summary>
            Returns a new compilation with attached diagnostic analyzers.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions" Member="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions.WithAnalyzers(Microsoft.CodeAnalysis.Compilation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SymbolEditor" />
      </Targets>
      <Member MemberName="GetBaseOrInterfaceDeclarationReferenceAsync">
        <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; GetBaseOrInterfaceDeclarationReferenceAsync (this Microsoft.CodeAnalysis.Editing.SymbolEditor editor, Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.ITypeSymbol baseOrInterfaceType, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; GetBaseOrInterfaceDeclarationReferenceAsync(class Microsoft.CodeAnalysis.Editing.SymbolEditor editor, class Microsoft.CodeAnalysis.ISymbol symbol, class Microsoft.CodeAnalysis.ITypeSymbol baseOrInterfaceType, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.GetBaseOrInterfaceDeclarationReferenceAsync(Microsoft.CodeAnalysis.Editing.SymbolEditor,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetBaseOrInterfaceDeclarationReferenceAsync : Microsoft.CodeAnalysis.Editing.SymbolEditor * Microsoft.CodeAnalysis.ISymbol * Microsoft.CodeAnalysis.ITypeSymbol * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" Usage="Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.GetBaseOrInterfaceDeclarationReferenceAsync (editor, symbol, baseOrInterfaceType, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SymbolEditor" RefType="this" />
          <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" />
          <Parameter Name="baseOrInterfaceType" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="symbol">To be added.</param>
          <param name="baseOrInterfaceType">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Gets the reference to the declaration of the base or interface type as part of the symbol's declaration. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.GetBaseOrInterfaceDeclarationReferenceAsync(Microsoft.CodeAnalysis.Editing.SymbolEditor,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SymbolEditor" />
      </Targets>
      <Member MemberName="SetBaseTypeAsync">
        <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.ISymbol&gt; SetBaseTypeAsync (this Microsoft.CodeAnalysis.Editing.SymbolEditor editor, Microsoft.CodeAnalysis.INamedTypeSymbol symbol, Microsoft.CodeAnalysis.ITypeSymbol newBaseType, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; SetBaseTypeAsync(class Microsoft.CodeAnalysis.Editing.SymbolEditor editor, class Microsoft.CodeAnalysis.INamedTypeSymbol symbol, class Microsoft.CodeAnalysis.ITypeSymbol newBaseType, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.SetBaseTypeAsync(Microsoft.CodeAnalysis.Editing.SymbolEditor,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member SetBaseTypeAsync : Microsoft.CodeAnalysis.Editing.SymbolEditor * Microsoft.CodeAnalysis.INamedTypeSymbol * Microsoft.CodeAnalysis.ITypeSymbol * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.SetBaseTypeAsync (editor, symbol, newBaseType, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SymbolEditor" RefType="this" />
          <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.INamedTypeSymbol" />
          <Parameter Name="newBaseType" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="symbol">To be added.</param>
          <param name="newBaseType">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Changes the base type of the symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.SetBaseTypeAsync(Microsoft.CodeAnalysis.Editing.SymbolEditor,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SymbolEditor" />
      </Targets>
      <Member MemberName="SetBaseTypeAsync">
        <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.ISymbol&gt; SetBaseTypeAsync (this Microsoft.CodeAnalysis.Editing.SymbolEditor editor, Microsoft.CodeAnalysis.INamedTypeSymbol symbol, Func&lt;Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.SyntaxNode&gt; getNewBaseType, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; SetBaseTypeAsync(class Microsoft.CodeAnalysis.Editing.SymbolEditor editor, class Microsoft.CodeAnalysis.INamedTypeSymbol symbol, class System.Func`2&lt;class Microsoft.CodeAnalysis.Editing.SyntaxGenerator, class Microsoft.CodeAnalysis.SyntaxNode&gt; getNewBaseType, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.SetBaseTypeAsync(Microsoft.CodeAnalysis.Editing.SymbolEditor,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Func{Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member SetBaseTypeAsync : Microsoft.CodeAnalysis.Editing.SymbolEditor * Microsoft.CodeAnalysis.INamedTypeSymbol * Func&lt;Microsoft.CodeAnalysis.Editing.SyntaxGenerator, Microsoft.CodeAnalysis.SyntaxNode&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.SetBaseTypeAsync (editor, symbol, getNewBaseType, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SymbolEditor" RefType="this" />
          <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.INamedTypeSymbol" />
          <Parameter Name="getNewBaseType" Type="System.Func&lt;Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.SyntaxNode&gt;" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="symbol">To be added.</param>
          <param name="getNewBaseType">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
            Changes the base type of the symbol.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.SetBaseTypeAsync(Microsoft.CodeAnalysis.Editing.SymbolEditor,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Func{Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="AddAttribute">
        <MemberSignature Language="C#" Value="public static void AddAttribute (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, Microsoft.CodeAnalysis.SyntaxNode attribute);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddAttribute(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, class Microsoft.CodeAnalysis.SyntaxNode attribute) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddAttribute(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AddAttribute (editor As SyntaxEditor, declaration As SyntaxNode, attribute As SyntaxNode)" />
        <MemberSignature Language="F#" Value="static member AddAttribute : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxNode -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddAttribute (editor, declaration, attribute)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void AddAttribute(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, Microsoft::CodeAnalysis::SyntaxNode ^ attribute);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="attribute">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddAttribute(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="AddAttributeArgument">
        <MemberSignature Language="C#" Value="public static void AddAttributeArgument (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode attributeDeclaration, Microsoft.CodeAnalysis.SyntaxNode attributeArgument);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddAttributeArgument(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode attributeDeclaration, class Microsoft.CodeAnalysis.SyntaxNode attributeArgument) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddAttributeArgument(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AddAttributeArgument (editor As SyntaxEditor, attributeDeclaration As SyntaxNode, attributeArgument As SyntaxNode)" />
        <MemberSignature Language="F#" Value="static member AddAttributeArgument : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxNode -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddAttributeArgument (editor, attributeDeclaration, attributeArgument)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void AddAttributeArgument(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ attributeDeclaration, Microsoft::CodeAnalysis::SyntaxNode ^ attributeArgument);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="attributeDeclaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="attributeArgument" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="attributeDeclaration">To be added.</param>
          <param name="attributeArgument">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddAttributeArgument(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="AddBaseType">
        <MemberSignature Language="C#" Value="public static void AddBaseType (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, Microsoft.CodeAnalysis.SyntaxNode baseType);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddBaseType(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, class Microsoft.CodeAnalysis.SyntaxNode baseType) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddBaseType(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AddBaseType (editor As SyntaxEditor, declaration As SyntaxNode, baseType As SyntaxNode)" />
        <MemberSignature Language="F#" Value="static member AddBaseType : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxNode -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddBaseType (editor, declaration, baseType)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void AddBaseType(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, Microsoft::CodeAnalysis::SyntaxNode ^ baseType);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="baseType" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="baseType">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddBaseType(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="AddInterfaceType">
        <MemberSignature Language="C#" Value="public static void AddInterfaceType (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, Microsoft.CodeAnalysis.SyntaxNode interfaceType);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddInterfaceType(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, class Microsoft.CodeAnalysis.SyntaxNode interfaceType) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddInterfaceType(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AddInterfaceType (editor As SyntaxEditor, declaration As SyntaxNode, interfaceType As SyntaxNode)" />
        <MemberSignature Language="F#" Value="static member AddInterfaceType : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxNode -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddInterfaceType (editor, declaration, interfaceType)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void AddInterfaceType(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, Microsoft::CodeAnalysis::SyntaxNode ^ interfaceType);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="interfaceType" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="interfaceType">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddInterfaceType(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="AddMember">
        <MemberSignature Language="C#" Value="public static void AddMember (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, Microsoft.CodeAnalysis.SyntaxNode member);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMember(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, class Microsoft.CodeAnalysis.SyntaxNode member) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddMember(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AddMember (editor As SyntaxEditor, declaration As SyntaxNode, member As SyntaxNode)" />
        <MemberSignature Language="F#" Value="static member AddMember : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxNode -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddMember (editor, declaration, member)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void AddMember(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, Microsoft::CodeAnalysis::SyntaxNode ^ member);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="member" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="member">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddMember(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="AddParameter">
        <MemberSignature Language="C#" Value="public static void AddParameter (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, Microsoft.CodeAnalysis.SyntaxNode parameter);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddParameter(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, class Microsoft.CodeAnalysis.SyntaxNode parameter) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddParameter(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AddParameter (editor As SyntaxEditor, declaration As SyntaxNode, parameter As SyntaxNode)" />
        <MemberSignature Language="F#" Value="static member AddParameter : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxNode -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddParameter (editor, declaration, parameter)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void AddParameter(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, Microsoft::CodeAnalysis::SyntaxNode ^ parameter);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="parameter" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="parameter">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddParameter(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="AddReturnAttribute">
        <MemberSignature Language="C#" Value="public static void AddReturnAttribute (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, Microsoft.CodeAnalysis.SyntaxNode attribute);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddReturnAttribute(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, class Microsoft.CodeAnalysis.SyntaxNode attribute) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddReturnAttribute(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub AddReturnAttribute (editor As SyntaxEditor, declaration As SyntaxNode, attribute As SyntaxNode)" />
        <MemberSignature Language="F#" Value="static member AddReturnAttribute : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxNode -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddReturnAttribute (editor, declaration, attribute)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void AddReturnAttribute(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, Microsoft::CodeAnalysis::SyntaxNode ^ attribute);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="attribute">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.AddReturnAttribute(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="InsertMembers">
        <MemberSignature Language="C#" Value="public static void InsertMembers (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, int index, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; members);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InsertMembers(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, int32 index, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; members) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.InsertMembers(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub InsertMembers (editor As SyntaxEditor, declaration As SyntaxNode, index As Integer, members As IEnumerable(Of SyntaxNode))" />
        <MemberSignature Language="F#" Value="static member InsertMembers : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * int * seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.InsertMembers (editor, declaration, index, members)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void InsertMembers(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, int index, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ members);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="index" Type="System.Int32" />
          <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="index">To be added.</param>
          <param name="members">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.InsertMembers(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="InsertParameter">
        <MemberSignature Language="C#" Value="public static void InsertParameter (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, int index, Microsoft.CodeAnalysis.SyntaxNode parameter);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InsertParameter(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, int32 index, class Microsoft.CodeAnalysis.SyntaxNode parameter) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.InsertParameter(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub InsertParameter (editor As SyntaxEditor, declaration As SyntaxNode, index As Integer, parameter As SyntaxNode)" />
        <MemberSignature Language="F#" Value="static member InsertParameter : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * int * Microsoft.CodeAnalysis.SyntaxNode -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.InsertParameter (editor, declaration, index, parameter)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void InsertParameter(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, int index, Microsoft::CodeAnalysis::SyntaxNode ^ parameter);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="index" Type="System.Int32" />
          <Parameter Name="parameter" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="index">To be added.</param>
          <param name="parameter">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.InsertParameter(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="SetAccessibility">
        <MemberSignature Language="C#" Value="public static void SetAccessibility (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, Microsoft.CodeAnalysis.Accessibility accessibility);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessibility(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, valuetype Microsoft.CodeAnalysis.Accessibility accessibility) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetAccessibility(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility)" />
        <MemberSignature Language="F#" Value="static member SetAccessibility : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.Accessibility -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetAccessibility (editor, declaration, accessibility)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void SetAccessibility(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, Microsoft::CodeAnalysis::Accessibility accessibility);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="accessibility" Type="Microsoft.CodeAnalysis.Accessibility" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="accessibility">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetAccessibility(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="SetExpression">
        <MemberSignature Language="C#" Value="public static void SetExpression (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, Microsoft.CodeAnalysis.SyntaxNode expression);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetExpression(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, class Microsoft.CodeAnalysis.SyntaxNode expression) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetExpression(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub SetExpression (editor As SyntaxEditor, declaration As SyntaxNode, expression As SyntaxNode)" />
        <MemberSignature Language="F#" Value="static member SetExpression : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxNode -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetExpression (editor, declaration, expression)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void SetExpression(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, Microsoft::CodeAnalysis::SyntaxNode ^ expression);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="expression">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetExpression(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="SetGetAccessorStatements">
        <MemberSignature Language="C#" Value="public static void SetGetAccessorStatements (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; statements);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetGetAccessorStatements(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; statements) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetGetAccessorStatements(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub SetGetAccessorStatements (editor As SyntaxEditor, declaration As SyntaxNode, statements As IEnumerable(Of SyntaxNode))" />
        <MemberSignature Language="F#" Value="static member SetGetAccessorStatements : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetGetAccessorStatements (editor, declaration, statements)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void SetGetAccessorStatements(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ statements);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="statements" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="statements">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetGetAccessorStatements(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="SetModifiers">
        <MemberSignature Language="C#" Value="public static void SetModifiers (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, Microsoft.CodeAnalysis.Editing.DeclarationModifiers modifiers);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetModifiers(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, valuetype Microsoft.CodeAnalysis.Editing.DeclarationModifiers modifiers) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetModifiers(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.DeclarationModifiers)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub SetModifiers (editor As SyntaxEditor, declaration As SyntaxNode, modifiers As DeclarationModifiers)" />
        <MemberSignature Language="F#" Value="static member SetModifiers : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.Editing.DeclarationModifiers -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetModifiers (editor, declaration, modifiers)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void SetModifiers(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, Microsoft::CodeAnalysis::Editing::DeclarationModifiers modifiers);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="modifiers" Type="Microsoft.CodeAnalysis.Editing.DeclarationModifiers" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="modifiers">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetModifiers(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.DeclarationModifiers)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="SetName">
        <MemberSignature Language="C#" Value="public static void SetName (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, string name);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetName(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, string name) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetName(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub SetName (editor As SyntaxEditor, declaration As SyntaxNode, name As String)" />
        <MemberSignature Language="F#" Value="static member SetName : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * string -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetName (editor, declaration, name)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void SetName(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, System::String ^ name);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="name" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="name">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetName(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="SetSetAccessorStatements">
        <MemberSignature Language="C#" Value="public static void SetSetAccessorStatements (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; statements);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetSetAccessorStatements(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; statements) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetSetAccessorStatements(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub SetSetAccessorStatements (editor As SyntaxEditor, declaration As SyntaxNode, statements As IEnumerable(Of SyntaxNode))" />
        <MemberSignature Language="F#" Value="static member SetSetAccessorStatements : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetSetAccessorStatements (editor, declaration, statements)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void SetSetAccessorStatements(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ statements);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="statements" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="statements">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetSetAccessorStatements(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="SetStatements">
        <MemberSignature Language="C#" Value="public static void SetStatements (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; statements);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetStatements(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; statements) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetStatements(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub SetStatements (editor As SyntaxEditor, declaration As SyntaxNode, statements As IEnumerable(Of SyntaxNode))" />
        <MemberSignature Language="F#" Value="static member SetStatements : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetStatements (editor, declaration, statements)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void SetStatements(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ statements);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="statements" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="statements">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetStatements(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="SetType">
        <MemberSignature Language="C#" Value="public static void SetType (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, Microsoft.CodeAnalysis.SyntaxNode type);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetType(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, class Microsoft.CodeAnalysis.SyntaxNode type) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetType(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub SetType (editor As SyntaxEditor, declaration As SyntaxNode, type As SyntaxNode)" />
        <MemberSignature Language="F#" Value="static member SetType : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxNode -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetType (editor, declaration, type)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void SetType(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, Microsoft::CodeAnalysis::SyntaxNode ^ type);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="type" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="type">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetType(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="SetTypeConstraint">
        <MemberSignature Language="C#" Value="public static void SetTypeConstraint (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, string typeParameterName, Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind kind, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; types);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTypeConstraint(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, string typeParameterName, valuetype Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind kind, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; types) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetTypeConstraint(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub SetTypeConstraint (editor As SyntaxEditor, declaration As SyntaxNode, typeParameterName As String, kind As SpecialTypeConstraintKind, types As IEnumerable(Of SyntaxNode))" />
        <MemberSignature Language="F#" Value="static member SetTypeConstraint : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * string * Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind * seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetTypeConstraint (editor, declaration, typeParameterName, kind, types)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void SetTypeConstraint(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, System::String ^ typeParameterName, Microsoft::CodeAnalysis::Editing::SpecialTypeConstraintKind kind, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ types);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="typeParameterName" Type="System.String" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind" />
          <Parameter Name="types" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="typeParameterName">To be added.</param>
          <param name="kind">To be added.</param>
          <param name="types">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetTypeConstraint(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor" />
      </Targets>
      <Member MemberName="SetTypeParameters">
        <MemberSignature Language="C#" Value="public static void SetTypeParameters (this Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, Microsoft.CodeAnalysis.SyntaxNode declaration, System.Collections.Generic.IEnumerable&lt;string&gt; typeParameters);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTypeParameters(class Microsoft.CodeAnalysis.Editing.SyntaxEditor editor, class Microsoft.CodeAnalysis.SyntaxNode declaration, class System.Collections.Generic.IEnumerable`1&lt;string&gt; typeParameters) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetTypeParameters(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.String})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub SetTypeParameters (editor As SyntaxEditor, declaration As SyntaxNode, typeParameters As IEnumerable(Of String))" />
        <MemberSignature Language="F#" Value="static member SetTypeParameters : Microsoft.CodeAnalysis.Editing.SyntaxEditor * Microsoft.CodeAnalysis.SyntaxNode * seq&lt;string&gt; -&gt; unit" Usage="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetTypeParameters (editor, declaration, typeParameters)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void SetTypeParameters(Microsoft::CodeAnalysis::Editing::SyntaxEditor ^ editor, Microsoft::CodeAnalysis::SyntaxNode ^ declaration, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ typeParameters);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Void</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="editor" Type="Microsoft.CodeAnalysis.Editing.SyntaxEditor" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="typeParameters" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        </Parameters>
        <Docs>
          <param name="editor">To be added.</param>
          <param name="declaration">To be added.</param>
          <param name="typeParameters">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions" Member="M:Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions.SetTypeParameters(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.String})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="Emit">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.Emit.EmitResult Emit (this Microsoft.CodeAnalysis.Compilation compilation, string outputPath, string pdbPath = null, string xmlDocPath = null, string win32ResourcesPath = null, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ResourceDescription&gt; manifestResources = null, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.Emit.EmitResult Emit(class Microsoft.CodeAnalysis.Compilation compilation, string outputPath, string pdbPath, string xmlDocPath, string win32ResourcesPath, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.ResourceDescription&gt; manifestResources, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.FileSystemExtensions.Emit(Microsoft.CodeAnalysis.Compilation,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member Emit : Microsoft.CodeAnalysis.Compilation * string * string * string * string * seq&lt;Microsoft.CodeAnalysis.ResourceDescription&gt; * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.Emit.EmitResult" Usage="Microsoft.CodeAnalysis.FileSystemExtensions.Emit (compilation, outputPath, pdbPath, xmlDocPath, win32ResourcesPath, manifestResources, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.Emit.EmitResult</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
          <Parameter Name="outputPath" Type="System.String" />
          <Parameter Name="pdbPath" Type="System.String" />
          <Parameter Name="xmlDocPath" Type="System.String" />
          <Parameter Name="win32ResourcesPath" Type="System.String" />
          <Parameter Name="manifestResources" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.ResourceDescription&gt;" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="compilation">Compilation.</param>
          <param name="outputPath">Path of the file to which the compilation will be written.</param>
          <param name="pdbPath">Path of the file to which the compilation's debug info will be written.
            Also embedded in the output file.  Null to forego PDB generation.
            </param>
          <param name="xmlDocPath">Path of the file to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
          <param name="win32ResourcesPath">Path of the file from which the compilation's Win32 resources will be read (in RES format).  
            Null to indicate that there are none.</param>
          <param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
          <param name="cancellationToken">To cancel the emit process.</param>
          <summary>
            Emit the IL for the compilation into the specified stream.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.FileSystemExtensions" Member="M:Microsoft.CodeAnalysis.FileSystemExtensions.Emit(Microsoft.CodeAnalysis.Compilation,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IMethodSymbol" />
      </Targets>
      <Member MemberName="GetConstructedReducedFrom">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetConstructedReducedFrom (this Microsoft.CodeAnalysis.IMethodSymbol method);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IMethodSymbol GetConstructedReducedFrom(class Microsoft.CodeAnalysis.IMethodSymbol method) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.ISymbolExtensions.GetConstructedReducedFrom(Microsoft.CodeAnalysis.IMethodSymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetConstructedReducedFrom (method As IMethodSymbol) As IMethodSymbol" />
        <MemberSignature Language="F#" Value="static member GetConstructedReducedFrom : Microsoft.CodeAnalysis.IMethodSymbol -&gt; Microsoft.CodeAnalysis.IMethodSymbol" Usage="Microsoft.CodeAnalysis.ISymbolExtensions.GetConstructedReducedFrom method" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::IMethodSymbol ^ GetConstructedReducedFrom(Microsoft::CodeAnalysis::IMethodSymbol ^ method);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="method" Type="Microsoft.CodeAnalysis.IMethodSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="method">To be added.</param>
          <summary>
            Returns the constructed form of the ReducedFrom property,
            including the type arguments that were either inferred during reduction or supplied at the call site.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.ISymbolExtensions" Member="M:Microsoft.CodeAnalysis.ISymbolExtensions.GetConstructedReducedFrom(Microsoft.CodeAnalysis.IMethodSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeControlFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode statement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode statement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="F#" Value="static member AnalyzeControlFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.ControlFlowAnalysis" Usage="Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow (semanticModel, statement)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::ControlFlowAnalysis ^ AnalyzeControlFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::SyntaxNode ^ statement);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="statement" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="statement">To be added.</param>
          <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.ModelExtensions" Member="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeControlFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode firstStatement, Microsoft.CodeAnalysis.SyntaxNode lastStatement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode firstStatement, class Microsoft.CodeAnalysis.SyntaxNode lastStatement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="F#" Value="static member AnalyzeControlFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.ControlFlowAnalysis" Usage="Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow (semanticModel, firstStatement, lastStatement)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::ControlFlowAnalysis ^ AnalyzeControlFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::SyntaxNode ^ firstStatement, Microsoft::CodeAnalysis::SyntaxNode ^ lastStatement);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="firstStatement">To be added.</param>
          <param name="lastStatement">To be added.</param>
          <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.ModelExtensions" Member="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeDataFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode statementOrExpression);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode statementOrExpression) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="F#" Value="static member AnalyzeDataFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.DataFlowAnalysis" Usage="Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow (semanticModel, statementOrExpression)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::DataFlowAnalysis ^ AnalyzeDataFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::SyntaxNode ^ statementOrExpression);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="statementOrExpression" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="statementOrExpression">To be added.</param>
          <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.ModelExtensions" Member="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeDataFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode firstStatement, Microsoft.CodeAnalysis.SyntaxNode lastStatement);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode firstStatement, class Microsoft.CodeAnalysis.SyntaxNode lastStatement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="F#" Value="static member AnalyzeDataFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.DataFlowAnalysis" Usage="Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow (semanticModel, firstStatement, lastStatement)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::DataFlowAnalysis ^ AnalyzeDataFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::SyntaxNode ^ firstStatement, Microsoft::CodeAnalysis::SyntaxNode ^ lastStatement);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="firstStatement">To be added.</param>
          <param name="lastStatement">To be added.</param>
          <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.ModelExtensions" Member="M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetAliasInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode nameSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode nameSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.ModelExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetAliasInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="Microsoft.CodeAnalysis.ModelExtensions.GetAliasInfo (semanticModel, nameSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel" />
          <param name="nameSyntax">Name to get alias info for.</param>
          <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the alias information.</param>
          <summary>
            If "nameSyntax" resolves to an alias name, return the IAliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.ModelExtensions" Member="M:Microsoft.CodeAnalysis.ModelExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode declaration, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode declaration, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.ModelExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.ModelExtensions.GetDeclaredSymbol (semanticModel, declaration, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel" />
          <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax</param>
          <param name="cancellationToken">The cancellation token.</param>
          <summary>
            Gets the symbol associated with a declaration syntax node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.ModelExtensions" Member="M:Microsoft.CodeAnalysis.ModelExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetMemberGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.ModelExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetMemberGroup : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="Microsoft.CodeAnalysis.ModelExtensions.GetMemberGroup (semanticModel, node, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel" />
          <param name="node">The syntax node to get semantic information for.</param>
          <param name="cancellationToken">The cancellation token.</param>
          <summary>
            Gets a list of method or indexed property symbols for a syntax node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.ModelExtensions" Member="M:Microsoft.CodeAnalysis.ModelExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeAliasInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SyntaxNode nameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.SyntaxNode nameSyntax, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeAliasInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeAliasInfo (semanticModel, position, nameSyntax, bindingOption)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::IAliasSymbol ^ GetSpeculativeAliasInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::SyntaxNode ^ nameSyntax, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel" />
          <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
          <param name="nameSyntax">A syntax node that represents a name. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
          <param name="bindingOption">Indicates whether to binding the name as a full expression,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
          <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.ModelExtensions" Member="M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SyntaxNode expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.SyntaxNode expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeSymbolInfo (semanticModel, position, expression, bindingOption)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SymbolInfo GetSpeculativeSymbolInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::SyntaxNode ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel" />
          <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
          <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
          <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
          <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.ModelExtensions" Member="M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SyntaxNode expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.SyntaxNode expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeTypeInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeTypeInfo (semanticModel, position, expression, bindingOption)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::TypeInfo GetSpeculativeTypeInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::SyntaxNode ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel" />
          <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
          <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
          <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
          <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.ModelExtensions" Member="M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.ModelExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.ModelExtensions.GetSymbolInfo (semanticModel, node, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel" />
          <param name="node">The syntax node to get semantic information for.</param>
          <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
          <summary>
            Gets symbol information about a syntax node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.ModelExtensions" Member="M:Microsoft.CodeAnalysis.ModelExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode node, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.ModelExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetTypeInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.ModelExtensions.GetTypeInfo (semanticModel, node, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel" />
          <param name="node">The syntax node to get semantic information for.</param>
          <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
          <summary>
            Gets type information about a syntax node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.ModelExtensions" Member="M:Microsoft.CodeAnalysis.ModelExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IOperation" />
      </Targets>
      <Member MemberName="Descendants">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.IOperation&gt; Descendants (this Microsoft.CodeAnalysis.IOperation operation);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.IOperation&gt; Descendants(class Microsoft.CodeAnalysis.IOperation operation) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.Descendants(Microsoft.CodeAnalysis.IOperation)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Descendants (operation As IOperation) As IEnumerable(Of IOperation)" />
        <MemberSignature Language="F#" Value="static member Descendants : Microsoft.CodeAnalysis.IOperation -&gt; seq&lt;Microsoft.CodeAnalysis.IOperation&gt;" Usage="Microsoft.CodeAnalysis.Operations.OperationExtensions.Descendants operation" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::IOperation ^&gt; ^ Descendants(Microsoft::CodeAnalysis::IOperation ^ operation);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.IOperation&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="operation" Type="Microsoft.CodeAnalysis.IOperation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="operation">Operation whose descendants are to be fetched.</param>
          <summary>
            Returns all the descendant operations of the given <paramref name="operation" /> in evaluation order.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Operations.OperationExtensions" Member="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.Descendants(Microsoft.CodeAnalysis.IOperation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IOperation" />
      </Targets>
      <Member MemberName="DescendantsAndSelf">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.IOperation&gt; DescendantsAndSelf (this Microsoft.CodeAnalysis.IOperation operation);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.IOperation&gt; DescendantsAndSelf(class Microsoft.CodeAnalysis.IOperation operation) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.DescendantsAndSelf(Microsoft.CodeAnalysis.IOperation)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DescendantsAndSelf (operation As IOperation) As IEnumerable(Of IOperation)" />
        <MemberSignature Language="F#" Value="static member DescendantsAndSelf : Microsoft.CodeAnalysis.IOperation -&gt; seq&lt;Microsoft.CodeAnalysis.IOperation&gt;" Usage="Microsoft.CodeAnalysis.Operations.OperationExtensions.DescendantsAndSelf operation" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::IOperation ^&gt; ^ DescendantsAndSelf(Microsoft::CodeAnalysis::IOperation ^ operation);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.IOperation&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="operation" Type="Microsoft.CodeAnalysis.IOperation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="operation">Operation whose descendants are to be fetched.</param>
          <summary>
            Returns all the descendant operations of the given <paramref name="operation" /> including the given <paramref name="operation" /> in evaluation order.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Operations.OperationExtensions" Member="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.DescendantsAndSelf(Microsoft.CodeAnalysis.IOperation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation" />
      </Targets>
      <Member MemberName="GetArgumentName">
        <MemberSignature Language="C#" Value="public static string GetArgumentName (this Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation dynamicOperation, int index);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetArgumentName(class Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation dynamicOperation, int32 index) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentName(Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetArgumentName (dynamicOperation As IDynamicIndexerAccessOperation, index As Integer) As String" />
        <MemberSignature Language="F#" Value="static member GetArgumentName : Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation * int -&gt; string" Usage="Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentName (dynamicOperation, index)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ GetArgumentName(Microsoft::CodeAnalysis::Operations::IDynamicIndexerAccessOperation ^ dynamicOperation, int index);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dynamicOperation" Type="Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation" RefType="this" />
          <Parameter Name="index" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="dynamicOperation">Dynamic or late bound operation.</param>
          <param name="index">Argument index.</param>
          <summary>
            Get an optional argument name for a named argument to the given <paramref name="dynamicOperation" /> at the given <paramref name="index" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Operations.OperationExtensions" Member="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentName(Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation" />
      </Targets>
      <Member MemberName="GetArgumentName">
        <MemberSignature Language="C#" Value="public static string GetArgumentName (this Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation dynamicOperation, int index);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetArgumentName(class Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation dynamicOperation, int32 index) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentName(Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetArgumentName (dynamicOperation As IDynamicInvocationOperation, index As Integer) As String" />
        <MemberSignature Language="F#" Value="static member GetArgumentName : Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation * int -&gt; string" Usage="Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentName (dynamicOperation, index)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ GetArgumentName(Microsoft::CodeAnalysis::Operations::IDynamicInvocationOperation ^ dynamicOperation, int index);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dynamicOperation" Type="Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation" RefType="this" />
          <Parameter Name="index" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="dynamicOperation">Dynamic or late bound operation.</param>
          <param name="index">Argument index.</param>
          <summary>
            Get an optional argument name for a named argument to the given <paramref name="dynamicOperation" /> at the given <paramref name="index" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Operations.OperationExtensions" Member="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentName(Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation" />
      </Targets>
      <Member MemberName="GetArgumentName">
        <MemberSignature Language="C#" Value="public static string GetArgumentName (this Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation dynamicOperation, int index);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetArgumentName(class Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation dynamicOperation, int32 index) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentName(Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetArgumentName (dynamicOperation As IDynamicObjectCreationOperation, index As Integer) As String" />
        <MemberSignature Language="F#" Value="static member GetArgumentName : Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation * int -&gt; string" Usage="Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentName (dynamicOperation, index)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ GetArgumentName(Microsoft::CodeAnalysis::Operations::IDynamicObjectCreationOperation ^ dynamicOperation, int index);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dynamicOperation" Type="Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation" RefType="this" />
          <Parameter Name="index" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="dynamicOperation">Dynamic or late bound operation.</param>
          <param name="index">Argument index.</param>
          <summary>
            Get an optional argument name for a named argument to the given <paramref name="dynamicOperation" /> at the given <paramref name="index" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Operations.OperationExtensions" Member="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentName(Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation" />
      </Targets>
      <Member MemberName="GetArgumentRefKind">
        <MemberSignature Language="C#" Value="public static Nullable&lt;Microsoft.CodeAnalysis.RefKind&gt; GetArgumentRefKind (this Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation dynamicOperation, int index);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype Microsoft.CodeAnalysis.RefKind&gt; GetArgumentRefKind(class Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation dynamicOperation, int32 index) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentRefKind(Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetArgumentRefKind (dynamicOperation As IDynamicIndexerAccessOperation, index As Integer) As Nullable(Of RefKind)" />
        <MemberSignature Language="F#" Value="static member GetArgumentRefKind : Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation * int -&gt; Nullable&lt;Microsoft.CodeAnalysis.RefKind&gt;" Usage="Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentRefKind (dynamicOperation, index)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;Microsoft::CodeAnalysis::RefKind&gt; GetArgumentRefKind(Microsoft::CodeAnalysis::Operations::IDynamicIndexerAccessOperation ^ dynamicOperation, int index);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Nullable&lt;Microsoft.CodeAnalysis.RefKind&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dynamicOperation" Type="Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation" RefType="this" />
          <Parameter Name="index" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="dynamicOperation">Dynamic or late bound operation.</param>
          <param name="index">Argument index.</param>
          <summary>
            Get an optional argument <see cref="T:Microsoft.CodeAnalysis.RefKind" /> for an argument at the given <paramref name="index" /> to the given <paramref name="dynamicOperation" />.
            Returns a non-null argument <see cref="T:Microsoft.CodeAnalysis.RefKind" /> for C#.
            Always returns null for VB as <see cref="T:Microsoft.CodeAnalysis.RefKind" /> cannot be specified for an the argument in VB.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Operations.OperationExtensions" Member="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentRefKind(Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation" />
      </Targets>
      <Member MemberName="GetArgumentRefKind">
        <MemberSignature Language="C#" Value="public static Nullable&lt;Microsoft.CodeAnalysis.RefKind&gt; GetArgumentRefKind (this Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation dynamicOperation, int index);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype Microsoft.CodeAnalysis.RefKind&gt; GetArgumentRefKind(class Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation dynamicOperation, int32 index) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentRefKind(Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetArgumentRefKind (dynamicOperation As IDynamicInvocationOperation, index As Integer) As Nullable(Of RefKind)" />
        <MemberSignature Language="F#" Value="static member GetArgumentRefKind : Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation * int -&gt; Nullable&lt;Microsoft.CodeAnalysis.RefKind&gt;" Usage="Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentRefKind (dynamicOperation, index)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;Microsoft::CodeAnalysis::RefKind&gt; GetArgumentRefKind(Microsoft::CodeAnalysis::Operations::IDynamicInvocationOperation ^ dynamicOperation, int index);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Nullable&lt;Microsoft.CodeAnalysis.RefKind&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dynamicOperation" Type="Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation" RefType="this" />
          <Parameter Name="index" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="dynamicOperation">Dynamic or late bound operation.</param>
          <param name="index">Argument index.</param>
          <summary>
            Get an optional argument <see cref="T:Microsoft.CodeAnalysis.RefKind" /> for an argument at the given <paramref name="index" /> to the given <paramref name="dynamicOperation" />.
            Returns a non-null argument <see cref="T:Microsoft.CodeAnalysis.RefKind" /> for C#.
            Always returns null for VB as <see cref="T:Microsoft.CodeAnalysis.RefKind" /> cannot be specified for an the argument in VB.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Operations.OperationExtensions" Member="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentRefKind(Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation" />
      </Targets>
      <Member MemberName="GetArgumentRefKind">
        <MemberSignature Language="C#" Value="public static Nullable&lt;Microsoft.CodeAnalysis.RefKind&gt; GetArgumentRefKind (this Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation dynamicOperation, int index);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype Microsoft.CodeAnalysis.RefKind&gt; GetArgumentRefKind(class Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation dynamicOperation, int32 index) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentRefKind(Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation,System.Int32)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetArgumentRefKind (dynamicOperation As IDynamicObjectCreationOperation, index As Integer) As Nullable(Of RefKind)" />
        <MemberSignature Language="F#" Value="static member GetArgumentRefKind : Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation * int -&gt; Nullable&lt;Microsoft.CodeAnalysis.RefKind&gt;" Usage="Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentRefKind (dynamicOperation, index)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;Microsoft::CodeAnalysis::RefKind&gt; GetArgumentRefKind(Microsoft::CodeAnalysis::Operations::IDynamicObjectCreationOperation ^ dynamicOperation, int index);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Nullable&lt;Microsoft.CodeAnalysis.RefKind&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="dynamicOperation" Type="Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation" RefType="this" />
          <Parameter Name="index" Type="System.Int32" />
        </Parameters>
        <Docs>
          <param name="dynamicOperation">Dynamic or late bound operation.</param>
          <param name="index">Argument index.</param>
          <summary>
            Get an optional argument <see cref="T:Microsoft.CodeAnalysis.RefKind" /> for an argument at the given <paramref name="index" /> to the given <paramref name="dynamicOperation" />.
            Returns a non-null argument <see cref="T:Microsoft.CodeAnalysis.RefKind" /> for C#.
            Always returns null for VB as <see cref="T:Microsoft.CodeAnalysis.RefKind" /> cannot be specified for an the argument in VB.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Operations.OperationExtensions" Member="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetArgumentRefKind(Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation,System.Int32)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.IVariableDeclarationGroupOperation" />
      </Targets>
      <Member MemberName="GetDeclaredVariables">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ILocalSymbol&gt; GetDeclaredVariables (this Microsoft.CodeAnalysis.Operations.IVariableDeclarationGroupOperation declarationGroup);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ILocalSymbol&gt; GetDeclaredVariables(class Microsoft.CodeAnalysis.Operations.IVariableDeclarationGroupOperation declarationGroup) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetDeclaredVariables(Microsoft.CodeAnalysis.Operations.IVariableDeclarationGroupOperation)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetDeclaredVariables (declarationGroup As IVariableDeclarationGroupOperation) As ImmutableArray(Of ILocalSymbol)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredVariables : Microsoft.CodeAnalysis.Operations.IVariableDeclarationGroupOperation -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ILocalSymbol&gt;" Usage="Microsoft.CodeAnalysis.Operations.OperationExtensions.GetDeclaredVariables declarationGroup" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ILocalSymbol ^&gt; GetDeclaredVariables(Microsoft::CodeAnalysis::Operations::IVariableDeclarationGroupOperation ^ declarationGroup);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ILocalSymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="declarationGroup" Type="Microsoft.CodeAnalysis.Operations.IVariableDeclarationGroupOperation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="declarationGroup">Variable declaration group</param>
          <summary>
            Gets all the declared local variables in the given <paramref name="declarationGroup" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Operations.OperationExtensions" Member="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetDeclaredVariables(Microsoft.CodeAnalysis.Operations.IVariableDeclarationGroupOperation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation" />
      </Targets>
      <Member MemberName="GetDeclaredVariables">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ILocalSymbol&gt; GetDeclaredVariables (this Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation declaration);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ILocalSymbol&gt; GetDeclaredVariables(class Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation declaration) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetDeclaredVariables(Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetDeclaredVariables (declaration As IVariableDeclarationOperation) As ImmutableArray(Of ILocalSymbol)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredVariables : Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ILocalSymbol&gt;" Usage="Microsoft.CodeAnalysis.Operations.OperationExtensions.GetDeclaredVariables declaration" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ILocalSymbol ^&gt; GetDeclaredVariables(Microsoft::CodeAnalysis::Operations::IVariableDeclarationOperation ^ declaration);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ILocalSymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="declaration" Type="Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="declaration">Variable declaration</param>
          <summary>
            Gets all the declared local variables in the given <paramref name="declaration" />.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Operations.OperationExtensions" Member="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetDeclaredVariables(Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation" />
      </Targets>
      <Member MemberName="GetVariableInitializer">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.Operations.IVariableInitializerOperation GetVariableInitializer (this Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation declarationOperation);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.CodeAnalysis.Operations.IVariableInitializerOperation GetVariableInitializer(class Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation declarationOperation) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetVariableInitializer(Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetVariableInitializer (declarationOperation As IVariableDeclaratorOperation) As IVariableInitializerOperation" />
        <MemberSignature Language="F#" Value="static member GetVariableInitializer : Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation -&gt; Microsoft.CodeAnalysis.Operations.IVariableInitializerOperation" Usage="Microsoft.CodeAnalysis.Operations.OperationExtensions.GetVariableInitializer declarationOperation" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::Operations::IVariableInitializerOperation ^ GetVariableInitializer(Microsoft::CodeAnalysis::Operations::IVariableDeclaratorOperation ^ declarationOperation);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.Operations.IVariableInitializerOperation</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="declarationOperation" Type="Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="declarationOperation">Single variable declaration to retrieve initializer for.</param>
          <summary>
            Gets the variable initialzer for the given <paramref name="declarationOperation" />, checking to see if there is a parent initializer
            if the single variable initializer is null.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.Operations.OperationExtensions" Member="M:Microsoft.CodeAnalysis.Operations.OperationExtensions.GetVariableInitializer(Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Immutable.ImmutableArray`1" />
      </Targets>
      <Member MemberName="ToDisplayString">
        <MemberSignature Language="C#" Value="public static string ToDisplayString (this System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.SymbolDisplayPart&gt; parts);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToDisplayString(valuetype System.Collections.Immutable.ImmutableArray`1&lt;valuetype Microsoft.CodeAnalysis.SymbolDisplayPart&gt; parts) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.ToDisplayString(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SymbolDisplayPart})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDisplayString (parts As ImmutableArray(Of SymbolDisplayPart)) As String" />
        <MemberSignature Language="F#" Value="static member ToDisplayString : System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.SymbolDisplayPart&gt; -&gt; string" Usage="Microsoft.CodeAnalysis.SymbolDisplayExtensions.ToDisplayString parts" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ ToDisplayString(System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::SymbolDisplayPart&gt; parts);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="parts" Type="System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.SymbolDisplayPart&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="parts">The array of parts.</param>
          <summary>
            Converts an immutable array of <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayPart" />s to a string.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SymbolDisplayExtensions" Member="M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.ToDisplayString(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SymbolDisplayPart})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="GetCurrentNode&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static TNode GetCurrentNode&lt;TNode&gt; (this Microsoft.CodeAnalysis.SyntaxNode root, TNode node) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TNode GetCurrentNode&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(class Microsoft.CodeAnalysis.SyntaxNode root, !!TNode node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNode``1(Microsoft.CodeAnalysis.SyntaxNode,``0)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetCurrentNode(Of TNode As SyntaxNode) (root As SyntaxNode, node As TNode) As TNode" />
        <MemberSignature Language="F#" Value="static member GetCurrentNode : Microsoft.CodeAnalysis.SyntaxNode * 'Node -&gt; 'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNode (root, node)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TNode GetCurrentNode(Microsoft::CodeAnalysis::SyntaxNode ^ root, TNode node);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TNode</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="node" Type="TNode" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="root">The root of the subtree containing the current node corresponding to the original tracked node.</param>
          <param name="node">The node instance originally tracked.</param>
          <summary>
            Gets the node within the subtree corresponding to the original tracked node.
            Use TrackNodes to start tracking nodes.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNode``1(Microsoft.CodeAnalysis.SyntaxNode,``0)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="GetCurrentNodes&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TNode&gt; GetCurrentNodes&lt;TNode&gt; (this Microsoft.CodeAnalysis.SyntaxNode root, TNode node) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TNode&gt; GetCurrentNodes&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(class Microsoft.CodeAnalysis.SyntaxNode root, !!TNode node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Microsoft.CodeAnalysis.SyntaxNode,``0)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetCurrentNodes(Of TNode As SyntaxNode) (root As SyntaxNode, node As TNode) As IEnumerable(Of TNode)" />
        <MemberSignature Language="F#" Value="static member GetCurrentNodes : Microsoft.CodeAnalysis.SyntaxNode * 'Node -&gt; seq&lt;'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes (root, node)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TNode&gt; ^ GetCurrentNodes(Microsoft::CodeAnalysis::SyntaxNode ^ root, TNode node);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;TNode&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="node" Type="TNode" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="root">The root of the subtree containing the current node corresponding to the original tracked node.</param>
          <param name="node">The node instance originally tracked.</param>
          <summary>
            Gets the nodes within the subtree corresponding to the original tracked node.
            Use TrackNodes to start tracking nodes.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Microsoft.CodeAnalysis.SyntaxNode,``0)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="GetCurrentNodes&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TNode&gt; GetCurrentNodes&lt;TNode&gt; (this Microsoft.CodeAnalysis.SyntaxNode root, System.Collections.Generic.IEnumerable&lt;TNode&gt; nodes) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TNode&gt; GetCurrentNodes&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(class Microsoft.CodeAnalysis.SyntaxNode root, class System.Collections.Generic.IEnumerable`1&lt;!!TNode&gt; nodes) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{``0})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Iterator Function GetCurrentNodes(Of TNode As SyntaxNode) (root As SyntaxNode, nodes As IEnumerable(Of TNode)) As IEnumerable(Of TNode)" />
        <MemberSignature Language="F#" Value="static member GetCurrentNodes : Microsoft.CodeAnalysis.SyntaxNode * seq&lt;'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; -&gt; seq&lt;'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes (root, nodes)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TNode&gt; ^ GetCurrentNodes(Microsoft::CodeAnalysis::SyntaxNode ^ root, System::Collections::Generic::IEnumerable&lt;TNode&gt; ^ nodes);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IEnumerable&lt;TNode&gt;</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="nodes" Type="System.Collections.Generic.IEnumerable&lt;TNode&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="root">The root of the subtree containing the current nodes corresponding to the original tracked nodes.</param>
          <param name="nodes">One or more node instances originally tracked.</param>
          <summary>
            Gets the nodes within the subtree corresponding to the original tracked nodes.
            Use TrackNodes to start tracking nodes.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{``0})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="InsertNodesAfter&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot InsertNodesAfter&lt;TRoot&gt; (this TRoot root, Microsoft.CodeAnalysis.SyntaxNode nodeInList, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; newNodes) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot InsertNodesAfter&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, class Microsoft.CodeAnalysis.SyntaxNode nodeInList, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; newNodes) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesAfter``1(``0,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function InsertNodesAfter(Of TRoot As SyntaxNode) (root As TRoot, nodeInList As SyntaxNode, newNodes As IEnumerable(Of SyntaxNode)) As TRoot" />
        <MemberSignature Language="F#" Value="static member InsertNodesAfter : 'Root * Microsoft.CodeAnalysis.SyntaxNode * seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesAfter (root, nodeInList, newNodes)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot InsertNodesAfter(TRoot root, Microsoft::CodeAnalysis::SyntaxNode ^ nodeInList, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ newNodes);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="nodeInList" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="newNodes" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root of the tree of nodes.</param>
          <param name="nodeInList">The node to insert after; a descendant of the root node an element of a list member.</param>
          <param name="newNodes">A sequence of nodes to insert into the tree immediately after the specified node.</param>
          <summary>
            Creates a new tree of nodes with new nodes inserted after the specified node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesAfter``1(``0,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="InsertNodesBefore&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot InsertNodesBefore&lt;TRoot&gt; (this TRoot root, Microsoft.CodeAnalysis.SyntaxNode nodeInList, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; newNodes) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot InsertNodesBefore&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, class Microsoft.CodeAnalysis.SyntaxNode nodeInList, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; newNodes) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesBefore``1(``0,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function InsertNodesBefore(Of TRoot As SyntaxNode) (root As TRoot, nodeInList As SyntaxNode, newNodes As IEnumerable(Of SyntaxNode)) As TRoot" />
        <MemberSignature Language="F#" Value="static member InsertNodesBefore : 'Root * Microsoft.CodeAnalysis.SyntaxNode * seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesBefore (root, nodeInList, newNodes)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot InsertNodesBefore(TRoot root, Microsoft::CodeAnalysis::SyntaxNode ^ nodeInList, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ newNodes);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="nodeInList" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="newNodes" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root of the tree of nodes.</param>
          <param name="nodeInList">The node to insert before; a descendant of the root node an element of a list member.</param>
          <param name="newNodes">A sequence of nodes to insert into the tree immediately before the specified node.</param>
          <summary>
            Creates a new tree of nodes with new nodes inserted before the specified node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesBefore``1(``0,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="InsertTokensAfter&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot InsertTokensAfter&lt;TRoot&gt; (this TRoot root, Microsoft.CodeAnalysis.SyntaxToken tokenInList, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; newTokens) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot InsertTokensAfter&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, valuetype Microsoft.CodeAnalysis.SyntaxToken tokenInList, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; newTokens) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensAfter``1(``0,Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function InsertTokensAfter(Of TRoot As SyntaxNode) (root As TRoot, tokenInList As SyntaxToken, newTokens As IEnumerable(Of SyntaxToken)) As TRoot" />
        <MemberSignature Language="F#" Value="static member InsertTokensAfter : 'Root * Microsoft.CodeAnalysis.SyntaxToken * seq&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensAfter (root, tokenInList, newTokens)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot InsertTokensAfter(TRoot root, Microsoft::CodeAnalysis::SyntaxToken tokenInList, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxToken&gt; ^ newTokens);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="tokenInList" Type="Microsoft.CodeAnalysis.SyntaxToken" />
          <Parameter Name="newTokens" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root of the tree of nodes.</param>
          <param name="tokenInList">The token to insert after; a descendant of the root node and an element of a list member.</param>
          <param name="newTokens">A sequence of tokens to insert into the tree immediately after the specified token.</param>
          <summary>
            Creates a new tree of nodes with new tokens inserted after the specified token.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensAfter``1(``0,Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="InsertTokensBefore&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot InsertTokensBefore&lt;TRoot&gt; (this TRoot root, Microsoft.CodeAnalysis.SyntaxToken tokenInList, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; newTokens) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot InsertTokensBefore&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, valuetype Microsoft.CodeAnalysis.SyntaxToken tokenInList, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; newTokens) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensBefore``1(``0,Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function InsertTokensBefore(Of TRoot As SyntaxNode) (root As TRoot, tokenInList As SyntaxToken, newTokens As IEnumerable(Of SyntaxToken)) As TRoot" />
        <MemberSignature Language="F#" Value="static member InsertTokensBefore : 'Root * Microsoft.CodeAnalysis.SyntaxToken * seq&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensBefore (root, tokenInList, newTokens)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot InsertTokensBefore(TRoot root, Microsoft::CodeAnalysis::SyntaxToken tokenInList, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxToken&gt; ^ newTokens);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="tokenInList" Type="Microsoft.CodeAnalysis.SyntaxToken" />
          <Parameter Name="newTokens" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root of the tree of nodes.</param>
          <param name="tokenInList">The token to insert before; a descendant of the root node and an element of a list member.</param>
          <param name="newTokens">A sequence of tokens to insert into the tree immediately before the specified token.</param>
          <summary>
            Creates a new tree of nodes with new tokens inserted before the specified token.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensBefore``1(``0,Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="InsertTriviaAfter&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot InsertTriviaAfter&lt;TRoot&gt; (this TRoot root, Microsoft.CodeAnalysis.SyntaxTrivia trivia, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; newTrivia) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot InsertTriviaAfter&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, valuetype Microsoft.CodeAnalysis.SyntaxTrivia trivia, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; newTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaAfter``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function InsertTriviaAfter(Of TRoot As SyntaxNode) (root As TRoot, trivia As SyntaxTrivia, newTrivia As IEnumerable(Of SyntaxTrivia)) As TRoot" />
        <MemberSignature Language="F#" Value="static member InsertTriviaAfter : 'Root * Microsoft.CodeAnalysis.SyntaxTrivia * seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaAfter (root, trivia, newTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot InsertTriviaAfter(TRoot root, Microsoft::CodeAnalysis::SyntaxTrivia trivia, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ newTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
          <Parameter Name="newTrivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root of the tree of nodes.</param>
          <param name="trivia">The trivia to insert after; a descendant of the root node.</param>
          <param name="newTrivia">A sequence of trivia to insert into the tree immediately after the specified trivia.</param>
          <summary>
            Creates a new tree of nodes with new trivia inserted after the specified trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaAfter``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="InsertTriviaBefore&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot InsertTriviaBefore&lt;TRoot&gt; (this TRoot root, Microsoft.CodeAnalysis.SyntaxTrivia trivia, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; newTrivia) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot InsertTriviaBefore&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, valuetype Microsoft.CodeAnalysis.SyntaxTrivia trivia, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; newTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaBefore``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function InsertTriviaBefore(Of TRoot As SyntaxNode) (root As TRoot, trivia As SyntaxTrivia, newTrivia As IEnumerable(Of SyntaxTrivia)) As TRoot" />
        <MemberSignature Language="F#" Value="static member InsertTriviaBefore : 'Root * Microsoft.CodeAnalysis.SyntaxTrivia * seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaBefore (root, trivia, newTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot InsertTriviaBefore(TRoot root, Microsoft::CodeAnalysis::SyntaxTrivia trivia, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ newTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
          <Parameter Name="newTrivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root of the tree of nodes.</param>
          <param name="trivia">The trivia to insert before; a descendant of the root node.</param>
          <param name="newTrivia">A sequence of trivia to insert into the tree immediately before the specified trivia.</param>
          <summary>
            Creates a new tree of nodes with new trivia inserted before the specified trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaBefore``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="NormalizeWhitespace&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static TNode NormalizeWhitespace&lt;TNode&gt; (this TNode node, string indentation, bool elasticTrivia) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TNode NormalizeWhitespace&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(!!TNode node, string indentation, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.NormalizeWhitespace``1(``0,System.String,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeWhitespace(Of TNode As SyntaxNode) (node As TNode, indentation As String, elasticTrivia As Boolean) As TNode" />
        <MemberSignature Language="F#" Value="static member NormalizeWhitespace : 'Node * string * bool -&gt; 'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.NormalizeWhitespace (node, indentation, elasticTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TNode NormalizeWhitespace(TNode node, System::String ^ indentation, bool elasticTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TNode</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TNode" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">The type of the node.</typeparam>
          <param name="node">The node to format.</param>
          <param name="indentation">A sequence of whitespace characters that defines a single level of indentation.</param>
          <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
          <summary>
            Creates a new syntax node with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.NormalizeWhitespace``1(``0,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="NormalizeWhitespace&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static TNode NormalizeWhitespace&lt;TNode&gt; (this TNode node, string indentation = &quot;    &quot;, string eol = &quot;\r\n&quot;, bool elasticTrivia = false) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TNode NormalizeWhitespace&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(!!TNode node, string indentation, string eol, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.NormalizeWhitespace``1(``0,System.String,System.String,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeWhitespace(Of TNode As SyntaxNode) (node As TNode, Optional indentation As String = &quot;    &quot;, Optional eol As String = &quot;\r\n&quot;, Optional elasticTrivia As Boolean = false) As TNode" />
        <MemberSignature Language="F#" Value="static member NormalizeWhitespace : 'Node * string * string * bool -&gt; 'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.NormalizeWhitespace (node, indentation, eol, elasticTrivia)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TNode</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TNode" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="eol" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">The type of the node.</typeparam>
          <param name="node">The node to format.</param>
          <param name="indentation">An optional sequence of whitespace characters that defines a single level of indentation.</param>
          <param name="eol">An optional sequence of whitespace characters used for end of line.</param>
          <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
          <summary>
            Creates a new syntax node with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.NormalizeWhitespace``1(``0,System.String,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="RemoveNode&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot RemoveNode&lt;TRoot&gt; (this TRoot root, Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.SyntaxRemoveOptions options) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot RemoveNode&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, class Microsoft.CodeAnalysis.SyntaxNode node, valuetype Microsoft.CodeAnalysis.SyntaxRemoveOptions options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNode``1(``0,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxRemoveOptions)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function RemoveNode(Of TRoot As SyntaxNode) (root As TRoot, node As SyntaxNode, options As SyntaxRemoveOptions) As TRoot" />
        <MemberSignature Language="F#" Value="static member RemoveNode : 'Root * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxRemoveOptions -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNode (root, node, options)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot RemoveNode(TRoot root, Microsoft::CodeAnalysis::SyntaxNode ^ node, Microsoft::CodeAnalysis::SyntaxRemoveOptions options);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="options" Type="Microsoft.CodeAnalysis.SyntaxRemoveOptions" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root node from which to remove a descendant node from.</param>
          <param name="node">The node to remove.</param>
          <param name="options">Options that determine how the node's trivia is treated.</param>
          <summary>
            Creates a new tree of nodes with the specified node removed.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNode``1(``0,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxRemoveOptions)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="RemoveNodes&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot RemoveNodes&lt;TRoot&gt; (this TRoot root, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; nodes, Microsoft.CodeAnalysis.SyntaxRemoveOptions options) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot RemoveNodes&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; nodes, valuetype Microsoft.CodeAnalysis.SyntaxRemoveOptions options) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNodes``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxRemoveOptions)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function RemoveNodes(Of TRoot As SyntaxNode) (root As TRoot, nodes As IEnumerable(Of SyntaxNode), options As SyntaxRemoveOptions) As TRoot" />
        <MemberSignature Language="F#" Value="static member RemoveNodes : 'Root * seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; * Microsoft.CodeAnalysis.SyntaxRemoveOptions -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNodes (root, nodes, options)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot RemoveNodes(TRoot root, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ nodes, Microsoft::CodeAnalysis::SyntaxRemoveOptions options);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="nodes" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" />
          <Parameter Name="options" Type="Microsoft.CodeAnalysis.SyntaxRemoveOptions" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root node from which to remove a descendant node from.</param>
          <param name="nodes">The nodes to remove.</param>
          <param name="options">Options that determine how the nodes' trivia is treated.</param>
          <summary>
            Creates a new tree of nodes with the specified nodes removed.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNodes``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxRemoveOptions)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="ReplaceNode&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot ReplaceNode&lt;TRoot&gt; (this TRoot root, Microsoft.CodeAnalysis.SyntaxNode oldNode, Microsoft.CodeAnalysis.SyntaxNode newNode) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot ReplaceNode&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, class Microsoft.CodeAnalysis.SyntaxNode oldNode, class Microsoft.CodeAnalysis.SyntaxNode newNode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``1(``0,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceNode(Of TRoot As SyntaxNode) (root As TRoot, oldNode As SyntaxNode, newNode As SyntaxNode) As TRoot" />
        <MemberSignature Language="F#" Value="static member ReplaceNode : 'Root * Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.SyntaxNode -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode (root, oldNode, newNode)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot ReplaceNode(TRoot root, Microsoft::CodeAnalysis::SyntaxNode ^ oldNode, Microsoft::CodeAnalysis::SyntaxNode ^ newNode);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="oldNode" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="newNode" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root node of the tree of nodes.</param>
          <param name="oldNode">The node to be replaced; a descendant of the root node.</param>
          <param name="newNode">The new node to use in the new tree in place of the old node.</param>
          <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``1(``0,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="ReplaceNode&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot ReplaceNode&lt;TRoot&gt; (this TRoot root, Microsoft.CodeAnalysis.SyntaxNode oldNode, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; newNodes) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot ReplaceNode&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, class Microsoft.CodeAnalysis.SyntaxNode oldNode, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; newNodes) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``1(``0,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceNode(Of TRoot As SyntaxNode) (root As TRoot, oldNode As SyntaxNode, newNodes As IEnumerable(Of SyntaxNode)) As TRoot" />
        <MemberSignature Language="F#" Value="static member ReplaceNode : 'Root * Microsoft.CodeAnalysis.SyntaxNode * seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode (root, oldNode, newNodes)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot ReplaceNode(TRoot root, Microsoft::CodeAnalysis::SyntaxNode ^ oldNode, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ newNodes);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="oldNode" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="newNodes" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root of the tree of nodes.</param>
          <param name="oldNode">The node to be replaced; a descendant of the root node and an element of a list member.</param>
          <param name="newNodes">A sequence of nodes to use in the tree in place of the old node.</param>
          <summary>
            Creates a new tree of nodes with specified old node replaced with a new nodes.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``1(``0,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="ReplaceNodes&lt;TRoot,TNode&gt;">
        <MemberSignature Language="C#" Value="public static TRoot ReplaceNodes&lt;TRoot,TNode&gt; (this TRoot root, System.Collections.Generic.IEnumerable&lt;TNode&gt; nodes, Func&lt;TNode,TNode,Microsoft.CodeAnalysis.SyntaxNode&gt; computeReplacementNode) where TRoot : Microsoft.CodeAnalysis.SyntaxNode where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot ReplaceNodes&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot, (class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(!!TRoot root, class System.Collections.Generic.IEnumerable`1&lt;!!TNode&gt; nodes, class System.Func`3&lt;!!TNode, !!TNode, class Microsoft.CodeAnalysis.SyntaxNode&gt; computeReplacementNode) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNodes``2(``0,System.Collections.Generic.IEnumerable{``1},System.Func{``1,``1,Microsoft.CodeAnalysis.SyntaxNode})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceNodes(Of TRoot As SyntaxNode, TNode As SyntaxNode) (root As TRoot, nodes As IEnumerable(Of TNode), computeReplacementNode As Func(Of TNode, TNode, SyntaxNode)) As TRoot" />
        <MemberSignature Language="F#" Value="static member ReplaceNodes : 'Root * seq&lt;'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; * Func&lt;'Node, 'Node, Microsoft.CodeAnalysis.SyntaxNode (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode and 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode and 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNodes (root, nodes, computeReplacementNode)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot, typename TNode&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot ReplaceNodes(TRoot root, System::Collections::Generic::IEnumerable&lt;TNode&gt; ^ nodes, Func&lt;TNode, TNode, Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ computeReplacementNode);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="nodes" Type="System.Collections.Generic.IEnumerable&lt;TNode&gt;" />
          <Parameter Name="computeReplacementNode" Type="System.Func&lt;TNode,TNode,Microsoft.CodeAnalysis.SyntaxNode&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <typeparam name="TNode">The type of the nodes being replaced.</typeparam>
          <param name="root">The root node of the tree of nodes.</param>
          <param name="nodes">The nodes to be replaced; descendants of the root node.</param>
          <param name="computeReplacementNode">A function that computes a replacement node for the
            argument nodes. The first argument is the original node. The second argument is the same
            node potentially rewritten with replaced descendants.</param>
          <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNodes``2(``0,System.Collections.Generic.IEnumerable{``1},System.Func{``1,``1,Microsoft.CodeAnalysis.SyntaxNode})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="ReplaceSyntax&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot ReplaceSyntax&lt;TRoot&gt; (this TRoot root, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; nodes, Func&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode&gt; computeReplacementNode, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; tokens, Func&lt;Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken&gt; computeReplacementToken, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot ReplaceSyntax&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; nodes, class System.Func`3&lt;class Microsoft.CodeAnalysis.SyntaxNode, class Microsoft.CodeAnalysis.SyntaxNode, class Microsoft.CodeAnalysis.SyntaxNode&gt; computeReplacementNode, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; tokens, class System.Func`3&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken, valuetype Microsoft.CodeAnalysis.SyntaxToken, valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; computeReplacementToken, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, class System.Func`3&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceSyntax``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceSyntax(Of TRoot As SyntaxNode) (root As TRoot, nodes As IEnumerable(Of SyntaxNode), computeReplacementNode As Func(Of SyntaxNode, SyntaxNode, SyntaxNode), tokens As IEnumerable(Of SyntaxToken), computeReplacementToken As Func(Of SyntaxToken, SyntaxToken, SyntaxToken), trivia As IEnumerable(Of SyntaxTrivia), computeReplacementTrivia As Func(Of SyntaxTrivia, SyntaxTrivia, SyntaxTrivia)) As TRoot" />
        <MemberSignature Language="F#" Value="static member ReplaceSyntax : 'Root * seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; * Func&lt;Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SyntaxNode&gt; * seq&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; * Func&lt;Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken&gt; * seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; * Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceSyntax (root, nodes, computeReplacementNode, tokens, computeReplacementToken, trivia, computeReplacementTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot ReplaceSyntax(TRoot root, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ nodes, Func&lt;Microsoft::CodeAnalysis::SyntaxNode ^, Microsoft::CodeAnalysis::SyntaxNode ^, Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ computeReplacementNode, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxToken&gt; ^ tokens, Func&lt;Microsoft::CodeAnalysis::SyntaxToken, Microsoft::CodeAnalysis::SyntaxToken, Microsoft::CodeAnalysis::SyntaxToken&gt; ^ computeReplacementToken, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ trivia, Func&lt;Microsoft::CodeAnalysis::SyntaxTrivia, Microsoft::CodeAnalysis::SyntaxTrivia, Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ computeReplacementTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="nodes" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" />
          <Parameter Name="computeReplacementNode" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode&gt;" />
          <Parameter Name="tokens" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;" />
          <Parameter Name="computeReplacementToken" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken&gt;" />
          <Parameter Name="trivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
          <Parameter Name="computeReplacementTrivia" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root node of the tree of nodes.</param>
          <param name="nodes">The nodes to be replaced.</param>
          <param name="computeReplacementNode">A function that computes a replacement node for the
            argument nodes. The first argument is the original node. The second argument is the same
            node potentially rewritten with replaced descendants.</param>
          <param name="tokens">The tokens to be replaced.</param>
          <param name="computeReplacementToken">A function that computes a replacement token for
            the argument tokens. The first argument is the original token. The second argument is
            the same token potentially rewritten with replaced trivia.</param>
          <param name="trivia">The trivia to be replaced.</param>
          <param name="computeReplacementTrivia">A function that computes replacement trivia for
            the specified arguments. The first argument is the original trivia. The second argument is
            the same trivia with potentially rewritten sub structure.</param>
          <summary>
            Creates a new tree of nodes with the specified nodes, tokens and trivia replaced.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceSyntax``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="ReplaceToken&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot ReplaceToken&lt;TRoot&gt; (this TRoot root, Microsoft.CodeAnalysis.SyntaxToken oldToken, Microsoft.CodeAnalysis.SyntaxToken newToken) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot ReplaceToken&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, valuetype Microsoft.CodeAnalysis.SyntaxToken oldToken, valuetype Microsoft.CodeAnalysis.SyntaxToken newToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceToken(Of TRoot As SyntaxNode) (root As TRoot, oldToken As SyntaxToken, newToken As SyntaxToken) As TRoot" />
        <MemberSignature Language="F#" Value="static member ReplaceToken : 'Root * Microsoft.CodeAnalysis.SyntaxToken * Microsoft.CodeAnalysis.SyntaxToken -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken (root, oldToken, newToken)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot ReplaceToken(TRoot root, Microsoft::CodeAnalysis::SyntaxToken oldToken, Microsoft::CodeAnalysis::SyntaxToken newToken);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="oldToken" Type="Microsoft.CodeAnalysis.SyntaxToken" />
          <Parameter Name="newToken" Type="Microsoft.CodeAnalysis.SyntaxToken" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root node of the tree of nodes.</param>
          <param name="oldToken">The token to be replaced.</param>
          <param name="newToken">The new token to use in the new tree in place of the old
            token.</param>
          <summary>
            Creates a new tree of nodes with the specified old token replaced with a new token.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="ReplaceToken&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot ReplaceToken&lt;TRoot&gt; (this TRoot root, Microsoft.CodeAnalysis.SyntaxToken tokenInList, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; newTokens) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot ReplaceToken&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, valuetype Microsoft.CodeAnalysis.SyntaxToken tokenInList, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; newTokens) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceToken(Of TRoot As SyntaxNode) (root As TRoot, tokenInList As SyntaxToken, newTokens As IEnumerable(Of SyntaxToken)) As TRoot" />
        <MemberSignature Language="F#" Value="static member ReplaceToken : 'Root * Microsoft.CodeAnalysis.SyntaxToken * seq&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken (root, tokenInList, newTokens)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot ReplaceToken(TRoot root, Microsoft::CodeAnalysis::SyntaxToken tokenInList, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxToken&gt; ^ newTokens);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="tokenInList" Type="Microsoft.CodeAnalysis.SyntaxToken" />
          <Parameter Name="newTokens" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root of the tree of nodes.</param>
          <param name="tokenInList">The token to be replaced; a descendant of the root node and an element of a list member.</param>
          <param name="newTokens">A sequence of tokens to use in the tree in place of the specified token.</param>
          <summary>
            Creates a new tree of nodes with the specified old token replaced with new tokens.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="ReplaceTokens&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot ReplaceTokens&lt;TRoot&gt; (this TRoot root, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; tokens, Func&lt;Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken&gt; computeReplacementToken) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot ReplaceTokens&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; tokens, class System.Func`3&lt;valuetype Microsoft.CodeAnalysis.SyntaxToken, valuetype Microsoft.CodeAnalysis.SyntaxToken, valuetype Microsoft.CodeAnalysis.SyntaxToken&gt; computeReplacementToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTokens``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceTokens(Of TRoot As SyntaxNode) (root As TRoot, tokens As IEnumerable(Of SyntaxToken), computeReplacementToken As Func(Of SyntaxToken, SyntaxToken, SyntaxToken)) As TRoot" />
        <MemberSignature Language="F#" Value="static member ReplaceTokens : 'Root * seq&lt;Microsoft.CodeAnalysis.SyntaxToken&gt; * Func&lt;Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken&gt; -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTokens (root, tokens, computeReplacementToken)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot ReplaceTokens(TRoot root, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxToken&gt; ^ tokens, Func&lt;Microsoft::CodeAnalysis::SyntaxToken, Microsoft::CodeAnalysis::SyntaxToken, Microsoft::CodeAnalysis::SyntaxToken&gt; ^ computeReplacementToken);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="tokens" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxToken&gt;" />
          <Parameter Name="computeReplacementToken" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root node of the tree of nodes.</param>
          <param name="tokens">The token to be replaced; descendants of the root node.</param>
          <param name="computeReplacementToken">A function that computes a replacement token for
            the argument tokens. The first argument is the original token. The second argument is
            the same token potentially rewritten with replaced trivia.</param>
          <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTokens``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="ReplaceTrivia&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot ReplaceTrivia&lt;TRoot&gt; (this TRoot root, Microsoft.CodeAnalysis.SyntaxTrivia trivia, Microsoft.CodeAnalysis.SyntaxTrivia newTrivia) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot ReplaceTrivia&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, valuetype Microsoft.CodeAnalysis.SyntaxTrivia trivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia newTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceTrivia(Of TRoot As SyntaxNode) (root As TRoot, trivia As SyntaxTrivia, newTrivia As SyntaxTrivia) As TRoot" />
        <MemberSignature Language="F#" Value="static member ReplaceTrivia : 'Root * Microsoft.CodeAnalysis.SyntaxTrivia * Microsoft.CodeAnalysis.SyntaxTrivia -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia (root, trivia, newTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot ReplaceTrivia(TRoot root, Microsoft::CodeAnalysis::SyntaxTrivia trivia, Microsoft::CodeAnalysis::SyntaxTrivia newTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
          <Parameter Name="newTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root node of the tree of nodes.</param>
          <param name="trivia">The trivia to be replaced.</param>
          <param name="newTrivia">The new trivia to use in the new tree in place of the old trivia.</param>
          <summary>
            Creates a new tree of nodes with the specified trivia replaced with new trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="ReplaceTrivia&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot ReplaceTrivia&lt;TRoot&gt; (this TRoot root, Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; newTrivia) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot ReplaceTrivia&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, valuetype Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; newTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceTrivia(Of TRoot As SyntaxNode) (root As TRoot, oldTrivia As SyntaxTrivia, newTrivia As IEnumerable(Of SyntaxTrivia)) As TRoot" />
        <MemberSignature Language="F#" Value="static member ReplaceTrivia : 'Root * Microsoft.CodeAnalysis.SyntaxTrivia * seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia (root, oldTrivia, newTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot ReplaceTrivia(TRoot root, Microsoft::CodeAnalysis::SyntaxTrivia oldTrivia, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ newTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="oldTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
          <Parameter Name="newTrivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root of the tree of nodes.</param>
          <param name="oldTrivia">The trivia to be replaced; a descendant of the root node.</param>
          <param name="newTrivia">A sequence of trivia to use in the tree in place of the specified trivia.</param>
          <summary>
            Creates a new tree of nodes with the specified old trivia replaced with new trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="ReplaceTrivia&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot ReplaceTrivia&lt;TRoot&gt; (this TRoot root, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot ReplaceTrivia&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, class System.Func`3&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceTrivia(Of TRoot As SyntaxNode) (root As TRoot, trivia As IEnumerable(Of SyntaxTrivia), computeReplacementTrivia As Func(Of SyntaxTrivia, SyntaxTrivia, SyntaxTrivia)) As TRoot" />
        <MemberSignature Language="F#" Value="static member ReplaceTrivia : 'Root * seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; * Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia (root, trivia, computeReplacementTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot ReplaceTrivia(TRoot root, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ trivia, Func&lt;Microsoft::CodeAnalysis::SyntaxTrivia, Microsoft::CodeAnalysis::SyntaxTrivia, Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ computeReplacementTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="trivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
          <Parameter Name="computeReplacementTrivia" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">The type of the root node.</typeparam>
          <param name="root">The root node of the tree of nodes.</param>
          <param name="trivia">The trivia to be replaced; descendants of the root node.</param>
          <param name="computeReplacementTrivia">A function that computes replacement trivia for
            the specified arguments. The first argument is the original trivia. The second argument is
            the same trivia with potentially rewritten sub structure.</param>
          <summary>
            Creates a new tree of nodes with the specified trivia replaced with new trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="TrackNodes&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot TrackNodes&lt;TRoot&gt; (this TRoot root, params Microsoft.CodeAnalysis.SyntaxNode[] nodes) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot TrackNodes&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, class Microsoft.CodeAnalysis.SyntaxNode[] nodes) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,Microsoft.CodeAnalysis.SyntaxNode[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrackNodes(Of TRoot As SyntaxNode) (root As TRoot, ParamArray nodes As SyntaxNode()) As TRoot" />
        <MemberSignature Language="F#" Value="static member TrackNodes : 'Root * Microsoft.CodeAnalysis.SyntaxNode[] -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes (root, nodes)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot TrackNodes(TRoot root, ... cli::array &lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ nodes);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="nodes" Type="Microsoft.CodeAnalysis.SyntaxNode[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="TRoot">To be added.</typeparam>
          <param name="root">The root of the subtree containing the nodes to be tracked.</param>
          <param name="nodes">One or more nodes that are descendants of the root node.</param>
          <summary>
            Creates a new tree of nodes with the specified nodes being tracked.
            
            Use GetCurrentNode on the subtree resulting from this operation, or any transformation of it,
            to get the current node corresponding to the original tracked node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,Microsoft.CodeAnalysis.SyntaxNode[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="TrackNodes&lt;TRoot&gt;">
        <MemberSignature Language="C#" Value="public static TRoot TrackNodes&lt;TRoot&gt; (this TRoot root, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; nodes) where TRoot : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TRoot TrackNodes&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TRoot&gt;(!!TRoot root, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.CodeAnalysis.SyntaxNode&gt; nodes) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrackNodes(Of TRoot As SyntaxNode) (root As TRoot, nodes As IEnumerable(Of SyntaxNode)) As TRoot" />
        <MemberSignature Language="F#" Value="static member TrackNodes : 'Root * seq&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; -&gt; 'Root (requires 'Root :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes (root, nodes)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TRoot&gt;&#xA; where TRoot : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TRoot TrackNodes(TRoot root, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxNode ^&gt; ^ nodes);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TRoot</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TRoot">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="root" Type="TRoot" RefType="this" />
          <Parameter Name="nodes" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TRoot">To be added.</typeparam>
          <param name="root">The root of the subtree containing the nodes to be tracked.</param>
          <param name="nodes">One or more nodes that are descendants of the root node.</param>
          <summary>
            Creates a new tree of nodes with the specified nodes being tracked.
            
            Use GetCurrentNode on the subtree resulting from this operation, or any transformation of it,
            to get the current node corresponding to the original tracked node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithLeadingTrivia&lt;TSyntax&gt;">
        <MemberSignature Language="C#" Value="public static TSyntax WithLeadingTrivia&lt;TSyntax&gt; (this TSyntax node, params Microsoft.CodeAnalysis.SyntaxTrivia[] trivia) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSyntax WithLeadingTrivia&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TSyntax&gt;(!!TSyntax node, valuetype Microsoft.CodeAnalysis.SyntaxTrivia[] trivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithLeadingTrivia(Of TSyntax As SyntaxNode) (node As TSyntax, ParamArray trivia As SyntaxTrivia()) As TSyntax" />
        <MemberSignature Language="F#" Value="static member WithLeadingTrivia : 'Syntax * Microsoft.CodeAnalysis.SyntaxTrivia[] -&gt; 'Syntax (requires 'Syntax :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia (node, trivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSyntax&gt;&#xA; where TSyntax : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TSyntax WithLeadingTrivia(TSyntax node, ... cli::array &lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ trivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TSyntax</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSyntax">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TSyntax" RefType="this" />
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="TSyntax">To be added.</typeparam>
          <param name="node">To be added.</param>
          <param name="trivia">To be added.</param>
          <summary>
            Creates a new node from this node with the leading trivia replaced.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithLeadingTrivia&lt;TSyntax&gt;">
        <MemberSignature Language="C#" Value="public static TSyntax WithLeadingTrivia&lt;TSyntax&gt; (this TSyntax node, Microsoft.CodeAnalysis.SyntaxTriviaList trivia) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSyntax WithLeadingTrivia&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TSyntax&gt;(!!TSyntax node, valuetype Microsoft.CodeAnalysis.SyntaxTriviaList trivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTriviaList)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithLeadingTrivia(Of TSyntax As SyntaxNode) (node As TSyntax, trivia As SyntaxTriviaList) As TSyntax" />
        <MemberSignature Language="F#" Value="static member WithLeadingTrivia : 'Syntax * Microsoft.CodeAnalysis.SyntaxTriviaList -&gt; 'Syntax (requires 'Syntax :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia (node, trivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSyntax&gt;&#xA; where TSyntax : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TSyntax WithLeadingTrivia(TSyntax node, Microsoft::CodeAnalysis::SyntaxTriviaList trivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TSyntax</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSyntax">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TSyntax" RefType="this" />
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" />
        </Parameters>
        <Docs>
          <typeparam name="TSyntax">To be added.</typeparam>
          <param name="node">To be added.</param>
          <param name="trivia">To be added.</param>
          <summary>
            Creates a new node from this node with the leading trivia replaced.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTriviaList)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithLeadingTrivia&lt;TSyntax&gt;">
        <MemberSignature Language="C#" Value="public static TSyntax WithLeadingTrivia&lt;TSyntax&gt; (this TSyntax node, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSyntax WithLeadingTrivia&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TSyntax&gt;(!!TSyntax node, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithLeadingTrivia(Of TSyntax As SyntaxNode) (node As TSyntax, trivia As IEnumerable(Of SyntaxTrivia)) As TSyntax" />
        <MemberSignature Language="F#" Value="static member WithLeadingTrivia : 'Syntax * seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; 'Syntax (requires 'Syntax :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia (node, trivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSyntax&gt;&#xA; where TSyntax : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TSyntax WithLeadingTrivia(TSyntax node, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ trivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TSyntax</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSyntax">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TSyntax" RefType="this" />
          <Parameter Name="trivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TSyntax">To be added.</typeparam>
          <param name="node">To be added.</param>
          <param name="trivia">To be added.</param>
          <summary>
            Creates a new node from this node with the leading trivia replaced.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithoutLeadingTrivia&lt;TSyntax&gt;">
        <MemberSignature Language="C#" Value="public static TSyntax WithoutLeadingTrivia&lt;TSyntax&gt; (this TSyntax node) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSyntax WithoutLeadingTrivia&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TSyntax&gt;(!!TSyntax node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutLeadingTrivia``1(``0)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithoutLeadingTrivia(Of TSyntax As SyntaxNode) (node As TSyntax) As TSyntax" />
        <MemberSignature Language="F#" Value="static member WithoutLeadingTrivia : 'Syntax -&gt; 'Syntax (requires 'Syntax :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutLeadingTrivia node" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSyntax&gt;&#xA; where TSyntax : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TSyntax WithoutLeadingTrivia(TSyntax node);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TSyntax</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSyntax">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TSyntax" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TSyntax">To be added.</typeparam>
          <param name="node">To be added.</param>
          <summary>
            Creates a new node from this node with the leading trivia removed.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutLeadingTrivia``1(``0)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithoutTrailingTrivia&lt;TSyntax&gt;">
        <MemberSignature Language="C#" Value="public static TSyntax WithoutTrailingTrivia&lt;TSyntax&gt; (this TSyntax node) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSyntax WithoutTrailingTrivia&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TSyntax&gt;(!!TSyntax node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrailingTrivia``1(``0)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithoutTrailingTrivia(Of TSyntax As SyntaxNode) (node As TSyntax) As TSyntax" />
        <MemberSignature Language="F#" Value="static member WithoutTrailingTrivia : 'Syntax -&gt; 'Syntax (requires 'Syntax :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrailingTrivia node" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSyntax&gt;&#xA; where TSyntax : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TSyntax WithoutTrailingTrivia(TSyntax node);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TSyntax</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSyntax">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TSyntax" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TSyntax">To be added.</typeparam>
          <param name="node">To be added.</param>
          <summary>
            Creates a new node from this node with the trailing trivia removed.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrailingTrivia``1(``0)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="WithoutTrivia">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken WithoutTrivia (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.CodeAnalysis.SyntaxToken WithoutTrivia(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrivia(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithoutTrivia (token As SyntaxToken) As SyntaxToken" />
        <MemberSignature Language="F#" Value="static member WithoutTrivia : Microsoft.CodeAnalysis.SyntaxToken -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrivia token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxToken WithoutTrivia(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>
            Creates a new token from this token without leading or trailing trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrivia(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithoutTrivia&lt;TSyntax&gt;">
        <MemberSignature Language="C#" Value="public static TSyntax WithoutTrivia&lt;TSyntax&gt; (this TSyntax syntax) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSyntax WithoutTrivia&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TSyntax&gt;(!!TSyntax syntax) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrivia``1(``0)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithoutTrivia(Of TSyntax As SyntaxNode) (syntax As TSyntax) As TSyntax" />
        <MemberSignature Language="F#" Value="static member WithoutTrivia : 'Syntax -&gt; 'Syntax (requires 'Syntax :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrivia syntax" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSyntax&gt;&#xA; where TSyntax : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TSyntax WithoutTrivia(TSyntax syntax);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TSyntax</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSyntax">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="syntax" Type="TSyntax" RefType="this" />
        </Parameters>
        <Docs>
          <typeparam name="TSyntax">To be added.</typeparam>
          <param name="syntax">To be added.</param>
          <summary>
            Creates a new node from this node without leading or trailing trivia.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrivia``1(``0)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithTrailingTrivia&lt;TSyntax&gt;">
        <MemberSignature Language="C#" Value="public static TSyntax WithTrailingTrivia&lt;TSyntax&gt; (this TSyntax node, params Microsoft.CodeAnalysis.SyntaxTrivia[] trivia) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSyntax WithTrailingTrivia&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TSyntax&gt;(!!TSyntax node, valuetype Microsoft.CodeAnalysis.SyntaxTrivia[] trivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithTrailingTrivia(Of TSyntax As SyntaxNode) (node As TSyntax, ParamArray trivia As SyntaxTrivia()) As TSyntax" />
        <MemberSignature Language="F#" Value="static member WithTrailingTrivia : 'Syntax * Microsoft.CodeAnalysis.SyntaxTrivia[] -&gt; 'Syntax (requires 'Syntax :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia (node, trivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSyntax&gt;&#xA; where TSyntax : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TSyntax WithTrailingTrivia(TSyntax node, ... cli::array &lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ trivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TSyntax</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSyntax">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TSyntax" RefType="this" />
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <typeparam name="TSyntax">To be added.</typeparam>
          <param name="node">To be added.</param>
          <param name="trivia">To be added.</param>
          <summary>
            Creates a new node from this node with the trailing trivia replaced.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithTrailingTrivia&lt;TSyntax&gt;">
        <MemberSignature Language="C#" Value="public static TSyntax WithTrailingTrivia&lt;TSyntax&gt; (this TSyntax node, Microsoft.CodeAnalysis.SyntaxTriviaList trivia) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSyntax WithTrailingTrivia&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TSyntax&gt;(!!TSyntax node, valuetype Microsoft.CodeAnalysis.SyntaxTriviaList trivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTriviaList)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithTrailingTrivia(Of TSyntax As SyntaxNode) (node As TSyntax, trivia As SyntaxTriviaList) As TSyntax" />
        <MemberSignature Language="F#" Value="static member WithTrailingTrivia : 'Syntax * Microsoft.CodeAnalysis.SyntaxTriviaList -&gt; 'Syntax (requires 'Syntax :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia (node, trivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSyntax&gt;&#xA; where TSyntax : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TSyntax WithTrailingTrivia(TSyntax node, Microsoft::CodeAnalysis::SyntaxTriviaList trivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TSyntax</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSyntax">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TSyntax" RefType="this" />
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" />
        </Parameters>
        <Docs>
          <typeparam name="TSyntax">To be added.</typeparam>
          <param name="node">To be added.</param>
          <param name="trivia">To be added.</param>
          <summary>
            Creates a new node from this node with the trailing trivia replaced.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTriviaList)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithTrailingTrivia&lt;TSyntax&gt;">
        <MemberSignature Language="C#" Value="public static TSyntax WithTrailingTrivia&lt;TSyntax&gt; (this TSyntax node, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSyntax WithTrailingTrivia&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TSyntax&gt;(!!TSyntax node, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithTrailingTrivia(Of TSyntax As SyntaxNode) (node As TSyntax, trivia As IEnumerable(Of SyntaxTrivia)) As TSyntax" />
        <MemberSignature Language="F#" Value="static member WithTrailingTrivia : 'Syntax * seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; 'Syntax (requires 'Syntax :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia (node, trivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSyntax&gt;&#xA; where TSyntax : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TSyntax WithTrailingTrivia(TSyntax node, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ trivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TSyntax</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSyntax">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TSyntax" RefType="this" />
          <Parameter Name="trivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        </Parameters>
        <Docs>
          <typeparam name="TSyntax">To be added.</typeparam>
          <param name="node">To be added.</param>
          <param name="trivia">To be added.</param>
          <summary>
            Creates a new node from this node with the trailing trivia replaced.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="WithTriviaFrom&lt;TSyntax&gt;">
        <MemberSignature Language="C#" Value="public static TSyntax WithTriviaFrom&lt;TSyntax&gt; (this TSyntax syntax, Microsoft.CodeAnalysis.SyntaxNode node) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSyntax WithTriviaFrom&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TSyntax&gt;(!!TSyntax syntax, class Microsoft.CodeAnalysis.SyntaxNode node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTriviaFrom``1(``0,Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithTriviaFrom(Of TSyntax As SyntaxNode) (syntax As TSyntax, node As SyntaxNode) As TSyntax" />
        <MemberSignature Language="F#" Value="static member WithTriviaFrom : 'Syntax * Microsoft.CodeAnalysis.SyntaxNode -&gt; 'Syntax (requires 'Syntax :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTriviaFrom (syntax, node)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSyntax&gt;&#xA; where TSyntax : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TSyntax WithTriviaFrom(TSyntax syntax, Microsoft::CodeAnalysis::SyntaxNode ^ node);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TSyntax</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TSyntax">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="syntax" Type="TSyntax" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" />
        </Parameters>
        <Docs>
          <typeparam name="TSyntax">To be added.</typeparam>
          <param name="syntax">To be added.</param>
          <param name="node">To be added.</param>
          <summary>
            Creates a new node from this node with both the leading and trailing trivia of the specified node.
            </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.SyntaxNodeExtensions" Member="M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTriviaFrom``1(``0,Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
      </Targets>
      <Member MemberName="GetText">
        <MemberSignature Language="C#" Value="public static string GetText (this Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static string GetText(valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.GeneratedExtensionSyntaxFacts.GetText(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetText (kind As SyntaxKind) As String" />
        <MemberSignature Language="F#" Value="static member GetText : Microsoft.CodeAnalysis.VisualBasic.SyntaxKind -&gt; string" Usage="Microsoft.CodeAnalysis.VisualBasic.GeneratedExtensionSyntaxFacts.GetText kind" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ GetText(Microsoft::CodeAnalysis::VisualBasic::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" RefType="this" />
        </Parameters>
        <Docs>
          <param name="kind">To be added.</param>
          <summary>
 Return keyword or punctuation text based on SyntaxKind
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.GeneratedExtensionSyntaxFacts" Member="M:Microsoft.CodeAnalysis.VisualBasic.GeneratedExtensionSyntaxFacts.GetText(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.VisualBasic.LanguageVersion" />
      </Targets>
      <Member MemberName="MapSpecifiedToEffectiveVersion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.LanguageVersion MapSpecifiedToEffectiveVersion (this Microsoft.CodeAnalysis.VisualBasic.LanguageVersion version);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.LanguageVersion MapSpecifiedToEffectiveVersion(valuetype Microsoft.CodeAnalysis.VisualBasic.LanguageVersion version) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts.MapSpecifiedToEffectiveVersion(Microsoft.CodeAnalysis.VisualBasic.LanguageVersion)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function MapSpecifiedToEffectiveVersion (version As LanguageVersion) As LanguageVersion" />
        <MemberSignature Language="F#" Value="static member MapSpecifiedToEffectiveVersion : Microsoft.CodeAnalysis.VisualBasic.LanguageVersion -&gt; Microsoft.CodeAnalysis.VisualBasic.LanguageVersion" Usage="Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts.MapSpecifiedToEffectiveVersion version" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::LanguageVersion MapSpecifiedToEffectiveVersion(Microsoft::CodeAnalysis::VisualBasic::LanguageVersion version);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.LanguageVersion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="version" Type="Microsoft.CodeAnalysis.VisualBasic.LanguageVersion" RefType="this" />
        </Parameters>
        <Docs>
          <param name="version">To be added.</param>
          <summary>
 Map a language version (such as Default, Latest, Or VisualBasicN) to a specific version (VisualBasicN).
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts" Member="M:Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts.MapSpecifiedToEffectiveVersion(Microsoft.CodeAnalysis.VisualBasic.LanguageVersion)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.VisualBasic.LanguageVersion" />
      </Targets>
      <Member MemberName="ToDisplayString">
        <MemberSignature Language="C#" Value="public static string ToDisplayString (this Microsoft.CodeAnalysis.VisualBasic.LanguageVersion version);" />
        <MemberSignature Language="ILAsm" Value=".method public static string ToDisplayString(valuetype Microsoft.CodeAnalysis.VisualBasic.LanguageVersion version) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts.ToDisplayString(Microsoft.CodeAnalysis.VisualBasic.LanguageVersion)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDisplayString (version As LanguageVersion) As String" />
        <MemberSignature Language="F#" Value="static member ToDisplayString : Microsoft.CodeAnalysis.VisualBasic.LanguageVersion -&gt; string" Usage="Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts.ToDisplayString version" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ ToDisplayString(Microsoft::CodeAnalysis::VisualBasic::LanguageVersion version);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="version" Type="Microsoft.CodeAnalysis.VisualBasic.LanguageVersion" RefType="this" />
        </Parameters>
        <Docs>
          <param name="version">To be added.</param>
          <summary>
 Displays the version number in the format understood on the command-line (/langver flag).
 For instance, "9", "15", "latest".
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts" Member="M:Microsoft.CodeAnalysis.VisualBasic.LanguageVersionFacts.ToDisplayString(Microsoft.CodeAnalysis.VisualBasic.LanguageVersion)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax" />
      </Targets>
      <Member MemberName="Attributes">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax&gt; Attributes (this Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseSyntax);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax&gt; Attributes(class Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseSyntax) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Attributes(Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)" />
        <MemberSignature Language="F#" Value="static member Attributes : Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax -&gt; Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax&gt;" Usage="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Attributes asClauseSyntax" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxList&lt;Microsoft::CodeAnalysis::VisualBasic::Syntax::AttributeListSyntax ^&gt; Attributes(Microsoft::CodeAnalysis::VisualBasic::Syntax::AsClauseSyntax ^ asClauseSyntax);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="asClauseSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax" RefType="this" />
        </Parameters>
        <Docs>
          <param name="asClauseSyntax">To be added.</param>
          <summary>
 Returns the AttributeBlockSyntax of the given AsClauseSyntax if specified.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Attributes(Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="NormalizeWhitespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace (this Microsoft.CodeAnalysis.SyntaxToken token, string indentation, bool elasticTrivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace(valuetype Microsoft.CodeAnalysis.SyntaxToken token, string indentation, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeWhitespace (token As SyntaxToken, indentation As String, elasticTrivia As Boolean) As SyntaxToken" />
        <MemberSignature Language="F#" Value="static member NormalizeWhitespace : Microsoft.CodeAnalysis.SyntaxToken * string * bool -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace (token, indentation, elasticTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxToken NormalizeWhitespace(Microsoft::CodeAnalysis::SyntaxToken token, System::String ^ indentation, bool elasticTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <param name="indentation">To be added.</param>
          <param name="elasticTrivia">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="NormalizeWhitespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace (this Microsoft.CodeAnalysis.SyntaxToken token, string indentation = &quot;    &quot;, string eol = &quot;\r\n&quot;, bool elasticTrivia = false, bool useDefaultCasing = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace(valuetype Microsoft.CodeAnalysis.SyntaxToken token, string indentation, string eol, bool elasticTrivia, bool useDefaultCasing) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.String,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeWhitespace (token As SyntaxToken, Optional indentation As String = &quot;    &quot;, Optional eol As String = &quot;\r\n&quot;, Optional elasticTrivia As Boolean = false, Optional useDefaultCasing As Boolean = false) As SyntaxToken" />
        <MemberSignature Language="F#" Value="static member NormalizeWhitespace : Microsoft.CodeAnalysis.SyntaxToken * string * string * bool * bool -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace (token, indentation, eol, elasticTrivia, useDefaultCasing)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="eol" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
          <Parameter Name="useDefaultCasing" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <param name="indentation">To be added.</param>
          <param name="eol">To be added.</param>
          <param name="elasticTrivia">To be added.</param>
          <param name="useDefaultCasing">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.String,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />
      </Targets>
      <Member MemberName="NormalizeWhitespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace (this Microsoft.CodeAnalysis.SyntaxTriviaList trivia, string indentation = &quot;    &quot;, string eol = &quot;\r\n&quot;, bool elasticTrivia = false, bool useDefaultCasing = false);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace(valuetype Microsoft.CodeAnalysis.SyntaxTriviaList trivia, string indentation, string eol, bool elasticTrivia, bool useDefaultCasing) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,System.Boolean,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeWhitespace (trivia As SyntaxTriviaList, Optional indentation As String = &quot;    &quot;, Optional eol As String = &quot;\r\n&quot;, Optional elasticTrivia As Boolean = false, Optional useDefaultCasing As Boolean = false) As SyntaxTriviaList" />
        <MemberSignature Language="F#" Value="static member NormalizeWhitespace : Microsoft.CodeAnalysis.SyntaxTriviaList * string * string * bool * bool -&gt; Microsoft.CodeAnalysis.SyntaxTriviaList" Usage="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace (trivia, indentation, eol, elasticTrivia, useDefaultCasing)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTriviaList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" RefType="this" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="eol" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
          <Parameter Name="useDefaultCasing" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <param name="trivia">To be added.</param>
          <param name="indentation">To be added.</param>
          <param name="eol">To be added.</param>
          <param name="elasticTrivia">To be added.</param>
          <param name="useDefaultCasing">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,System.Boolean,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="NormalizeWhitespace&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static TNode NormalizeWhitespace&lt;TNode&gt; (this TNode node, bool useDefaultCasing, string indentation, bool elasticTrivia) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static !!TNode NormalizeWhitespace&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(!!TNode node, bool useDefaultCasing, string indentation, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace``1(``0,System.Boolean,System.String,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeWhitespace(Of TNode As SyntaxNode) (node As TNode, useDefaultCasing As Boolean, indentation As String, elasticTrivia As Boolean) As TNode" />
        <MemberSignature Language="F#" Value="static member NormalizeWhitespace : 'Node * bool * string * bool -&gt; 'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace (node, useDefaultCasing, indentation, elasticTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static TNode NormalizeWhitespace(TNode node, bool useDefaultCasing, System::String ^ indentation, bool elasticTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TNode</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TNode" RefType="this" />
          <Parameter Name="useDefaultCasing" Type="System.Boolean" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="node">To be added.</param>
          <param name="useDefaultCasing">To be added.</param>
          <param name="indentation">To be added.</param>
          <param name="elasticTrivia">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace``1(``0,System.Boolean,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="NormalizeWhitespace&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static TNode NormalizeWhitespace&lt;TNode&gt; (this TNode node, bool useDefaultCasing, string indentation = &quot;    &quot;, string eol = &quot;\r\n&quot;, bool elasticTrivia = false) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static !!TNode NormalizeWhitespace&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(!!TNode node, bool useDefaultCasing, string indentation, string eol, bool elasticTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace``1(``0,System.Boolean,System.String,System.String,System.Boolean)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NormalizeWhitespace(Of TNode As SyntaxNode) (node As TNode, useDefaultCasing As Boolean, Optional indentation As String = &quot;    &quot;, Optional eol As String = &quot;\r\n&quot;, Optional elasticTrivia As Boolean = false) As TNode" />
        <MemberSignature Language="F#" Value="static member NormalizeWhitespace : 'Node * bool * string * string * bool -&gt; 'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace (node, useDefaultCasing, indentation, eol, elasticTrivia)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>TNode</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="node" Type="TNode" RefType="this" />
          <Parameter Name="useDefaultCasing" Type="System.Boolean" />
          <Parameter Name="indentation" Type="System.String" />
          <Parameter Name="eol" Type="System.String" />
          <Parameter Name="elasticTrivia" Type="System.Boolean" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="node">To be added.</param>
          <param name="useDefaultCasing">To be added.</param>
          <param name="indentation">To be added.</param>
          <param name="eol">To be added.</param>
          <param name="elasticTrivia">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.NormalizeWhitespace``1(``0,System.Boolean,System.String,System.String,System.Boolean)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:System.Collections.Generic.IEnumerable`1" />
      </Targets>
      <Member MemberName="ToSyntaxTriviaList">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTriviaList ToSyntaxTriviaList (this System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; sequence);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxTriviaList ToSyntaxTriviaList(class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; sequence) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.ToSyntaxTriviaList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToSyntaxTriviaList (sequence As IEnumerable(Of SyntaxTrivia)) As SyntaxTriviaList" />
        <MemberSignature Language="F#" Value="static member ToSyntaxTriviaList : seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; Microsoft.CodeAnalysis.SyntaxTriviaList" Usage="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.ToSyntaxTriviaList sequence" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxTriviaList ToSyntaxTriviaList(System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ sequence);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTriviaList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="sequence" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" RefType="this" />
        </Parameters>
        <Docs>
          <param name="sequence">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.ToSyntaxTriviaList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="TryGetInferredMemberName">
        <MemberSignature Language="C#" Value="public static string TryGetInferredMemberName (this Microsoft.CodeAnalysis.SyntaxNode syntax);" />
        <MemberSignature Language="ILAsm" Value=".method public static string TryGetInferredMemberName(class Microsoft.CodeAnalysis.SyntaxNode syntax) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.TryGetInferredMemberName(Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryGetInferredMemberName (syntax As SyntaxNode) As String" />
        <MemberSignature Language="F#" Value="static member TryGetInferredMemberName : Microsoft.CodeAnalysis.SyntaxNode -&gt; string" Usage="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.TryGetInferredMemberName syntax" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ TryGetInferredMemberName(Microsoft::CodeAnalysis::SyntaxNode ^ syntax);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="syntax" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
        </Parameters>
        <Docs>
          <param name="syntax">To be added.</param>
          <summary>
 Given an initializer expression infer the name of anonymous property or tuple element.
 Returns Nothing if unsuccessful
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.TryGetInferredMemberName(Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax" />
      </Targets>
      <Member MemberName="Type">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax Type (this Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseSyntax);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax Type(class Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax asClauseSyntax) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Type(Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)" />
        <MemberSignature Language="F#" Value="static member Type : Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax -&gt; Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax" Usage="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Type asClauseSyntax" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::Syntax::TypeSyntax ^ Type(Microsoft::CodeAnalysis::VisualBasic::Syntax::AsClauseSyntax ^ asClauseSyntax);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="asClauseSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax" RefType="this" />
        </Parameters>
        <Docs>
          <param name="asClauseSyntax">To be added.</param>
          <summary>
 Returns the TypeSyntax of the given AsClauseSyntax if specified.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Type(Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax" />
      </Targets>
      <Member MemberName="Type">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax Type (this Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax newExpressionSyntax);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax Type(class Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax newExpressionSyntax) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Type(Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax)" />
        <MemberSignature Language="F#" Value="static member Type : Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax -&gt; Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax" Usage="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Type newExpressionSyntax" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::Syntax::TypeSyntax ^ Type(Microsoft::CodeAnalysis::VisualBasic::Syntax::NewExpressionSyntax ^ newExpressionSyntax);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="newExpressionSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax" RefType="this" />
        </Parameters>
        <Docs>
          <param name="newExpressionSyntax">To be added.</param>
          <summary>
 Returns the TypeSyntax of the given NewExpressionSyntax if specified.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.Type(Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax" />
      </Targets>
      <Member MemberName="WithIdentifier">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax WithIdentifier (this Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax simpleName, Microsoft.CodeAnalysis.SyntaxToken identifier);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax WithIdentifier(class Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax simpleName, valuetype Microsoft.CodeAnalysis.SyntaxToken identifier) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.WithIdentifier(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithIdentifier (simpleName As SimpleNameSyntax, identifier As SyntaxToken) As SimpleNameSyntax" />
        <MemberSignature Language="F#" Value="static member WithIdentifier : Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax * Microsoft.CodeAnalysis.SyntaxToken -&gt; Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax" Usage="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.WithIdentifier (simpleName, identifier)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::Syntax::SimpleNameSyntax ^ WithIdentifier(Microsoft::CodeAnalysis::VisualBasic::Syntax::SimpleNameSyntax ^ simpleName, Microsoft::CodeAnalysis::SyntaxToken identifier);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="simpleName" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax" RefType="this" />
          <Parameter Name="identifier" Type="Microsoft.CodeAnalysis.SyntaxToken" />
        </Parameters>
        <Docs>
          <param name="simpleName" />
          <param name="identifier" />
          <summary>
 Updates the given SimpleNameSyntax node with the given identifier token.
 This function is a wrapper that calls WithIdentifier on derived syntax nodes.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions.WithIdentifier(Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.TypedConstant" />
      </Targets>
      <Member MemberName="ToVisualBasicString">
        <MemberSignature Language="C#" Value="public static string ToVisualBasicString (this Microsoft.CodeAnalysis.TypedConstant constant);" />
        <MemberSignature Language="ILAsm" Value=".method public static string ToVisualBasicString(valuetype Microsoft.CodeAnalysis.TypedConstant constant) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.TypedConstantExtensions.ToVisualBasicString(Microsoft.CodeAnalysis.TypedConstant)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToVisualBasicString (constant As TypedConstant) As String" />
        <MemberSignature Language="F#" Value="static member ToVisualBasicString : Microsoft.CodeAnalysis.TypedConstant -&gt; string" Usage="Microsoft.CodeAnalysis.VisualBasic.TypedConstantExtensions.ToVisualBasicString constant" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ ToVisualBasicString(Microsoft::CodeAnalysis::TypedConstant constant);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="constant" Type="Microsoft.CodeAnalysis.TypedConstant" RefType="this" />
        </Parameters>
        <Docs>
          <param name="constant">To be added.</param>
          <summary>
 Returns the System.String that represents the current TypedConstant.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.TypedConstantExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.TypedConstantExtensions.ToVisualBasicString(Microsoft.CodeAnalysis.TypedConstant)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTokenList" />
      </Targets>
      <Member MemberName="Add">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTokenList Add (this Microsoft.CodeAnalysis.SyntaxTokenList list, params Microsoft.CodeAnalysis.SyntaxToken[] items);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxTokenList Add(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, valuetype Microsoft.CodeAnalysis.SyntaxToken[] items) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Add(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Add (list As SyntaxTokenList, ParamArray items As SyntaxToken()) As SyntaxTokenList" />
        <MemberSignature Language="F#" Value="static member Add : Microsoft.CodeAnalysis.SyntaxTokenList * Microsoft.CodeAnalysis.SyntaxToken[] -&gt; Microsoft.CodeAnalysis.SyntaxTokenList" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Add (list, items)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxTokenList Add(Microsoft::CodeAnalysis::SyntaxTokenList list, ... cli::array &lt;Microsoft::CodeAnalysis::SyntaxToken&gt; ^ items);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTokenList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
          <Parameter Name="items" Type="Microsoft.CodeAnalysis.SyntaxToken[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="list">To be added.</param>
          <param name="items">To be added.</param>
          <summary>
 Add one or more tokens to the end of the list.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Add(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="AliasImports">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IAliasSymbol&gt; AliasImports (this Microsoft.CodeAnalysis.Compilation compilation);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.IAliasSymbol&gt; AliasImports(class Microsoft.CodeAnalysis.Compilation compilation) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AliasImports(Microsoft.CodeAnalysis.Compilation)" />
        <MemberSignature Language="F#" Value="static member AliasImports : Microsoft.CodeAnalysis.Compilation -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IAliasSymbol&gt;" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AliasImports compilation" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::IAliasSymbol ^&gt; AliasImports(Microsoft::CodeAnalysis::Compilation ^ compilation);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.IAliasSymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="compilation">A source Compilation object.</param>
          <summary>
 Gets the compilation AliasImports property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AliasImports(Microsoft.CodeAnalysis.Compilation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeControlFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax statement);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax statement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
        <MemberSignature Language="F#" Value="static member AnalyzeControlFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax -&gt; Microsoft.CodeAnalysis.ControlFlowAnalysis" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeControlFlow (semanticModel, statement)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::ControlFlowAnalysis ^ AnalyzeControlFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::VisualBasic::Syntax::StatementSyntax ^ statement);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="statement" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="statement">To be added.</param>
          <summary>
 Analyze control-flow within a part of a method body.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeControlFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax lastStatement);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax firstStatement, class Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax lastStatement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
        <MemberSignature Language="F#" Value="static member AnalyzeControlFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax * Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax -&gt; Microsoft.CodeAnalysis.ControlFlowAnalysis" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeControlFlow (semanticModel, firstStatement, lastStatement)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::ControlFlowAnalysis ^ AnalyzeControlFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::VisualBasic::Syntax::StatementSyntax ^ firstStatement, Microsoft::CodeAnalysis::VisualBasic::Syntax::StatementSyntax ^ lastStatement);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ControlFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax" />
          <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="firstStatement">To be added.</param>
          <param name="lastStatement">To be added.</param>
          <summary>
 Analyze control-flow within a part of a method body.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeDataFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)" />
        <MemberSignature Language="F#" Value="static member AnalyzeDataFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax -&gt; Microsoft.CodeAnalysis.DataFlowAnalysis" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow (semanticModel, expression)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::DataFlowAnalysis ^ AnalyzeDataFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::VisualBasic::Syntax::ExpressionSyntax ^ expression);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <summary>
 Analyze data-flow within an expression. 
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeDataFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax statement);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax statement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
        <MemberSignature Language="F#" Value="static member AnalyzeDataFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax -&gt; Microsoft.CodeAnalysis.DataFlowAnalysis" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow (semanticModel, statement)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::DataFlowAnalysis ^ AnalyzeDataFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::VisualBasic::Syntax::StatementSyntax ^ statement);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="statement" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="statement">To be added.</param>
          <summary>
 Analyze data-flow within a statement.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="AnalyzeDataFlow">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax lastStatement);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax firstStatement, class Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax lastStatement) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
        <MemberSignature Language="F#" Value="static member AnalyzeDataFlow : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax * Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax -&gt; Microsoft.CodeAnalysis.DataFlowAnalysis" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow (semanticModel, firstStatement, lastStatement)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::DataFlowAnalysis ^ AnalyzeDataFlow(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::VisualBasic::Syntax::StatementSyntax ^ firstStatement, Microsoft::CodeAnalysis::VisualBasic::Syntax::StatementSyntax ^ lastStatement);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.DataFlowAnalysis</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="firstStatement" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax" />
          <Parameter Name="lastStatement" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="firstStatement">To be added.</param>
          <param name="lastStatement">To be added.</param>
          <summary>
 Analyze data-flow within a set of contiguous statements.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax,Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IEventSymbol" />
      </Targets>
      <Member MemberName="AssociatedField">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IFieldSymbol AssociatedField (this Microsoft.CodeAnalysis.IEventSymbol eventSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IFieldSymbol AssociatedField(class Microsoft.CodeAnalysis.IEventSymbol eventSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AssociatedField(Microsoft.CodeAnalysis.IEventSymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AssociatedField (eventSymbol As IEventSymbol) As IFieldSymbol" />
        <MemberSignature Language="F#" Value="static member AssociatedField : Microsoft.CodeAnalysis.IEventSymbol -&gt; Microsoft.CodeAnalysis.IFieldSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AssociatedField eventSymbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::IFieldSymbol ^ AssociatedField(Microsoft::CodeAnalysis::IEventSymbol ^ eventSymbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IFieldSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="eventSymbol" Type="Microsoft.CodeAnalysis.IEventSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="eventSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.AssociatedField(Microsoft.CodeAnalysis.IEventSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="ClassifyConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.Compilation compilation, class Microsoft.CodeAnalysis.ITypeSymbol source, class Microsoft.CodeAnalysis.ITypeSymbol destination) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
        <MemberSignature Language="F#" Value="static member ClassifyConversion : Microsoft.CodeAnalysis.Compilation * Microsoft.CodeAnalysis.ITypeSymbol * Microsoft.CodeAnalysis.ITypeSymbol -&gt; Microsoft.CodeAnalysis.VisualBasic.Conversion" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion (compilation, source, destination)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::Conversion ClassifyConversion(Microsoft::CodeAnalysis::Compilation ^ compilation, Microsoft::CodeAnalysis::ITypeSymbol ^ source, Microsoft::CodeAnalysis::ITypeSymbol ^ destination);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
          <Parameter Name="source" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
          <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        </Parameters>
        <Docs>
          <param name="compilation">A source Compilation object.</param>
          <param name="source">A source Typesymbol</param>
          <param name="destination">A destination Typesymbol</param>
          <summary>
 Determines what kind of conversion there is between the specified types.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="ClassifyConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, class Microsoft.CodeAnalysis.ITypeSymbol destination) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol)" />
        <MemberSignature Language="F#" Value="static member ClassifyConversion : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.ITypeSymbol -&gt; Microsoft.CodeAnalysis.VisualBasic.Conversion" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion (semanticModel, expression, destination)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::Conversion ClassifyConversion(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::VisualBasic::Syntax::ExpressionSyntax ^ expression, Microsoft::CodeAnalysis::ITypeSymbol ^ destination);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source semantic model.</param>
          <param name="expression">A source expression syntax.</param>
          <param name="destination">A destination TypeSymbol.</param>
          <summary>
 Determines what kind of conversion there is between the expression syntax and a specified type.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="ClassifyConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion ClassifyConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion ClassifyConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, class Microsoft.CodeAnalysis.ITypeSymbol destination) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol)" />
        <MemberSignature Language="F#" Value="static member ClassifyConversion : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.ITypeSymbol -&gt; Microsoft.CodeAnalysis.VisualBasic.Conversion" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion (semanticModel, position, expression, destination)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::Conversion ClassifyConversion(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::VisualBasic::Syntax::ExpressionSyntax ^ expression, Microsoft::CodeAnalysis::ITypeSymbol ^ destination);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="destination" Type="Microsoft.CodeAnalysis.ITypeSymbol" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source semantic model.</param>
          <param name="position">A position within the expression syntax.</param>
          <param name="expression">A source expression syntax.</param>
          <param name="destination">A destination TypeSymbol.</param>
          <summary>
 Determines what kind of conversion there is between the expression syntax and a specified type.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetAggregateClauseSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.AggregateClauseSymbolInfo GetAggregateClauseSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax aggregateSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.AggregateClauseSymbolInfo GetAggregateClauseSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax aggregateSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAggregateClauseSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetAggregateClauseSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.VisualBasic.AggregateClauseSymbolInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAggregateClauseSymbolInfo (semanticModel, aggregateSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.AggregateClauseSymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="aggregateSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="aggregateSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Returns information about methods associated with AggregateClauseSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAggregateClauseSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetAliasInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax nameSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax nameSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetAliasInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAliasInfo (semanticModel, nameSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="nameSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 If "nameSyntax" resolves to an alias name, return the AliasSymbol corresponding
 to A. Otherwise return null.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetAwaitExpressionInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.AwaitExpressionInfo GetAwaitExpressionInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax awaitExpression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.AwaitExpressionInfo GetAwaitExpressionInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax awaitExpression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetAwaitExpressionInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.VisualBasic.AwaitExpressionInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAwaitExpressionInfo (semanticModel, awaitExpression, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.AwaitExpressionInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="awaitExpression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="awaitExpression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding AwaitExpressionInfo containing semantic info for a specified AwaitExpressionSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="GetBase">
        <MemberSignature Language="C#" Value="public static Nullable&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralBase&gt; GetBase (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Nullable`1&lt;valuetype Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralBase&gt; GetBase(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetBase(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetBase (token As SyntaxToken) As Nullable(Of LiteralBase)" />
        <MemberSignature Language="F#" Value="static member GetBase : Microsoft.CodeAnalysis.SyntaxToken -&gt; Nullable&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralBase&gt;" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetBase token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;Microsoft::CodeAnalysis::VisualBasic::Syntax::LiteralBase&gt; GetBase(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Nullable&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralBase&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">The source SyntaxToken.</param>
          <summary>
 The source token base for Integer literals.  Base can be Decimal, Hex or Octal.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetBase(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetCollectionInitializerSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetCollectionInitializerSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetCollectionInitializerSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetCollectionInitializerSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCollectionInitializerSymbolInfo (semanticModel, expression, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax 
 within <see cref="P:Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax.Initializer" />.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetCollectionRangeVariableSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.CollectionRangeVariableSymbolInfo GetCollectionRangeVariableSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax variableSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.CollectionRangeVariableSymbolInfo GetCollectionRangeVariableSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax variableSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCollectionRangeVariableSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetCollectionRangeVariableSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.VisualBasic.CollectionRangeVariableSymbolInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCollectionRangeVariableSymbolInfo (semanticModel, variableSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.CollectionRangeVariableSymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="variableSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="variableSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Returns information about methods associated with CollectionRangeVariableSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCollectionRangeVariableSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTree" />
      </Targets>
      <Member MemberName="GetCompilationUnitRoot">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax GetCompilationUnitRoot (this Microsoft.CodeAnalysis.SyntaxTree tree);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax GetCompilationUnitRoot(class Microsoft.CodeAnalysis.SyntaxTree tree) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetCompilationUnitRoot (tree As SyntaxTree) As CompilationUnitSyntax" />
        <MemberSignature Language="F#" Value="static member GetCompilationUnitRoot : Microsoft.CodeAnalysis.SyntaxTree -&gt; Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCompilationUnitRoot tree" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::Syntax::CompilationUnitSyntax ^ GetCompilationUnitRoot(Microsoft::CodeAnalysis::SyntaxTree ^ tree);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="tree" Type="Microsoft.CodeAnalysis.SyntaxTree" RefType="this" />
        </Parameters>
        <Docs>
          <param name="tree">The source SyntaxTree.</param>
          <summary>
 Gets the root CompilationUnitSyntax for a specified SyntaxTree.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.IConversionOperation" />
      </Targets>
      <Member MemberName="GetConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion GetConversion (this Microsoft.CodeAnalysis.Operations.IConversionOperation conversionExpression);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion GetConversion(class Microsoft.CodeAnalysis.Operations.IConversionOperation conversionExpression) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetConversion(Microsoft.CodeAnalysis.Operations.IConversionOperation)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetConversion (conversionExpression As IConversionOperation) As Conversion" />
        <MemberSignature Language="F#" Value="static member GetConversion : Microsoft.CodeAnalysis.Operations.IConversionOperation -&gt; Microsoft.CodeAnalysis.VisualBasic.Conversion" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetConversion conversionExpression" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::Conversion GetConversion(Microsoft::CodeAnalysis::Operations::IConversionOperation ^ conversionExpression);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="conversionExpression" Type="Microsoft.CodeAnalysis.Operations.IConversionOperation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="conversionExpression">The conversion expression to get original info from.</param>
          <summary>
 Gets the underlying <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Conversion" /> information from an <see cref="T:Microsoft.CodeAnalysis.Operations.IConversionOperation" /> that was created from Visual Basic code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetConversion(Microsoft.CodeAnalysis.Operations.IConversionOperation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion GetConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion GetConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.SyntaxNode expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetConversion : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.SyntaxNode * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.VisualBasic.Conversion" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetConversion (semanticModel, expression, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.SyntaxNode" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding TypeInfo containing semantic info for a specified ExpressionSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IMethodSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding MethodSymbol for a specified AccessorStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax rangeVariableSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax rangeVariableSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IRangeVariableSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, rangeVariableSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="rangeVariableSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="rangeVariableSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding RangeVariableSymbol for a specified AggregationRangeVariableSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax anonymousObjectCreationExpressionSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax anonymousObjectCreationExpressionSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, anonymousObjectCreationExpressionSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="anonymousObjectCreationExpressionSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="anonymousObjectCreationExpressionSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding  NamedTypeSymbol for a specified  AnonymousObjectCreationExpressionSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ILocalSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ILocalSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding LocalSymbol for a specified CatchStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax rangeVariableSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax rangeVariableSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IRangeVariableSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, rangeVariableSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="rangeVariableSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="rangeVariableSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding RangeVariableSymbol for a specified CollectionRangeVariableSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IMethodSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding symbol for a specified  DeclareStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding NamedTypeSymbol for a specified DelegateStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding NamedTypeSymbol for a specified EnumBlockSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IFieldSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IFieldSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IFieldSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IFieldSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding FieldSymbol for a specified EnumMemberDeclarationSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding NamedTypeSymbol for a specified EnumStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IEventSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IEventSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding EventSymbol for a specified EventBlockSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IEventSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IEventSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding EventSymbol for a specified EventStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax rangeVariableSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax rangeVariableSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IRangeVariableSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, rangeVariableSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IRangeVariableSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="rangeVariableSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="rangeVariableSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding RangeVariableSymbol for a specified ExpressionRangeVariableSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax fieldInitializerSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax fieldInitializerSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IPropertySymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, fieldInitializerSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="fieldInitializerSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source semantic model.</param>
          <param name="fieldInitializerSyntax">A FieldInitializerSyntax object.</param>
          <param name="cancellationToken">A cancellation token.</param>
          <summary>
 Gets the corresponding PropertySymbol for a specified FieldInitializerSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ILabelSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ILabelSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding LabelSymbol for a specified LabelStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IMethodSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding MethodSymbol for a specified MethodBlockBaseSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IMethodSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding MethodSymbol for a specified MethodStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifierSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax identifierSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, identifierSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="identifierSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source semantic model.</param>
          <param name="identifierSyntax">A IdentifierSyntax object.</param>
          <param name="cancellationToken">A cancellation token.</param>
          <summary>
 Gets the corresponding symbol for a specified identifier.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamespaceSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding NamespaceSymbol for a specified NamespaceBlockSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamespaceSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding NamespaceSymbol for a specified NamespaceStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IMethodSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding MethodSymbol for a specified OperatorStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IParameterSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax parameter, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IParameterSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax parameter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IParameterSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, parameter, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IParameterSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="parameter" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="parameter">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding ParameterSymbol for a specified ParameterSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IPropertySymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding PropertySymbol for a specified PropertyBlockSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IPropertySymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IPropertySymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding PropertySymbol for a specified PropertyStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding AliasSymbol for a specified AliasImportsClauseSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.IMethodSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IMethodSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding MethodSymbol for a specified SubNewStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax elementSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax elementSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ISymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, elementSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ISymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="elementSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source semantic model.</param>
          <param name="elementSyntax">A TupleElementSyntax object.</param>
          <param name="cancellationToken">A cancellation token.</param>
          <summary>
 Gets the corresponding symbol for a specified tuple element.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleElementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding NamedTypeSymbol for a specified TypeBlockSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.ITypeParameterSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax typeParameter, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.ITypeParameterSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax typeParameter, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.ITypeParameterSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, typeParameter, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.ITypeParameterSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="typeParameter" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="typeParameter">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding TypeParameterSymbol Symbol for a specified TypeParameterSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetDeclaredSymbol">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax declarationSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetDeclaredSymbol : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol (semanticModel, declarationSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="declarationSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="declarationSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding NamedTypeSymbol for a specified TypeStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="GetDirectives">
        <MemberSignature Language="C#" Value="public static System.Collections.Generic.IList&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax&gt; GetDirectives (this Microsoft.CodeAnalysis.SyntaxNode node, Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,bool&gt; filter = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IList`1&lt;class Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax&gt; GetDirectives(class Microsoft.CodeAnalysis.SyntaxNode node, class System.Func`2&lt;class Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax, bool&gt; filter) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDirectives(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetDirectives (node As SyntaxNode, Optional filter As Func(Of DirectiveTriviaSyntax, Boolean) = null) As IList(Of DirectiveTriviaSyntax)" />
        <MemberSignature Language="F#" Value="static member GetDirectives : Microsoft.CodeAnalysis.SyntaxNode * Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax, bool&gt; -&gt; System.Collections.Generic.IList&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax&gt;" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDirectives (node, filter)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Generic.IList&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="filter" Type="System.Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean&gt;" />
        </Parameters>
        <Docs>
          <param name="node">The source SyntaxNode.</param>
          <param name="filter">The optional DirectiveTrivia Syntax filter predicate.</param>
          <summary>
 Gets the DirectiveTriviaSyntax items for a specified SyntaxNode with optional filtering.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetDirectives(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IEventSymbol" />
      </Targets>
      <Member MemberName="GetFieldAttributes">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.AttributeData&gt; GetFieldAttributes (this Microsoft.CodeAnalysis.IEventSymbol eventSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.AttributeData&gt; GetFieldAttributes(class Microsoft.CodeAnalysis.IEventSymbol eventSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetFieldAttributes(Microsoft.CodeAnalysis.IEventSymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetFieldAttributes (eventSymbol As IEventSymbol) As ImmutableArray(Of AttributeData)" />
        <MemberSignature Language="F#" Value="static member GetFieldAttributes : Microsoft.CodeAnalysis.IEventSymbol -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.AttributeData&gt;" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetFieldAttributes eventSymbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::AttributeData ^&gt; GetFieldAttributes(Microsoft::CodeAnalysis::IEventSymbol ^ eventSymbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.AttributeData&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="eventSymbol" Type="Microsoft.CodeAnalysis.IEventSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="eventSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetFieldAttributes(Microsoft.CodeAnalysis.IEventSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="GetFirstDirective">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax GetFirstDirective (this Microsoft.CodeAnalysis.SyntaxNode node, Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,bool&gt; predicate = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax GetFirstDirective(class Microsoft.CodeAnalysis.SyntaxNode node, class System.Func`2&lt;class Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax, bool&gt; predicate) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetFirstDirective (node As SyntaxNode, Optional predicate As Func(Of DirectiveTriviaSyntax, Boolean) = null) As DirectiveTriviaSyntax" />
        <MemberSignature Language="F#" Value="static member GetFirstDirective : Microsoft.CodeAnalysis.SyntaxNode * Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax, bool&gt; -&gt; Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetFirstDirective (node, predicate)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="predicate" Type="System.Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean&gt;" />
        </Parameters>
        <Docs>
          <param name="node">The source SyntaxNode.</param>
          <param name="predicate">The optional DirectiveTriviaSyntax filter predicate.</param>
          <summary>
 Gets the first DirectiveTriviaSyntax item for a specified SyntaxNode.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetForEachStatementInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo GetForEachStatementInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax node);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo GetForEachStatementInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax)" />
        <MemberSignature Language="F#" Value="static member GetForEachStatementInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax -&gt; Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetForEachStatementInfo (semanticModel, node)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::ForEachStatementInfo GetForEachStatementInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::VisualBasic::Syntax::ForEachBlockSyntax ^ node);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <summary>
 Gets the corresponding ForEachStatementInfo containing semantic info for a specified ForBlockSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetForEachStatementInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo GetForEachStatementInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax node);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo GetForEachStatementInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax)" />
        <MemberSignature Language="F#" Value="static member GetForEachStatementInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax -&gt; Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetForEachStatementInfo (semanticModel, node)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::ForEachStatementInfo GetForEachStatementInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::VisualBasic::Syntax::ForEachStatementSyntax ^ node);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <summary>
 Gets the corresponding ForEachStatementInfo containing semantic info for a specified ForEachStatementSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="GetIdentifierText">
        <MemberSignature Language="C#" Value="public static string GetIdentifierText (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static string GetIdentifierText(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetIdentifierText(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetIdentifierText (token As SyntaxToken) As String" />
        <MemberSignature Language="F#" Value="static member GetIdentifierText : Microsoft.CodeAnalysis.SyntaxToken -&gt; string" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetIdentifierText token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ GetIdentifierText(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.String</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>
 Returns the Identifiertext for a specified SyntaxToken.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetIdentifierText(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.IArgumentOperation" />
      </Targets>
      <Member MemberName="GetInConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion GetInConversion (this Microsoft.CodeAnalysis.Operations.IArgumentOperation argument);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion GetInConversion(class Microsoft.CodeAnalysis.Operations.IArgumentOperation argument) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetInConversion(Microsoft.CodeAnalysis.Operations.IArgumentOperation)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetInConversion (argument As IArgumentOperation) As Conversion" />
        <MemberSignature Language="F#" Value="static member GetInConversion : Microsoft.CodeAnalysis.Operations.IArgumentOperation -&gt; Microsoft.CodeAnalysis.VisualBasic.Conversion" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetInConversion argument" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::Conversion GetInConversion(Microsoft::CodeAnalysis::Operations::IArgumentOperation ^ argument);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="argument" Type="Microsoft.CodeAnalysis.Operations.IArgumentOperation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="argument">The argument to get original info from.</param>
          <summary>
 Gets the underlying <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Conversion" /> information for InConversion of <see cref="T:Microsoft.CodeAnalysis.Operations.IArgumentOperation" /> that was created from Visual Basic code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetInConversion(Microsoft.CodeAnalysis.Operations.IArgumentOperation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" />
      </Targets>
      <Member MemberName="GetInConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion GetInConversion (this Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation compoundAssignment);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion GetInConversion(class Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation compoundAssignment) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetInConversion(Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetInConversion (compoundAssignment As ICompoundAssignmentOperation) As Conversion" />
        <MemberSignature Language="F#" Value="static member GetInConversion : Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation -&gt; Microsoft.CodeAnalysis.VisualBasic.Conversion" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetInConversion compoundAssignment" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::Conversion GetInConversion(Microsoft::CodeAnalysis::Operations::ICompoundAssignmentOperation ^ compoundAssignment);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compoundAssignment" Type="Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="compoundAssignment">To be added.</param>
          <summary>
 Gets the underlying <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Conversion" /> information from this <see cref="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" />. This
 conversion is applied before the operator is applied to the result of this conversion and <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Value" />.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetInConversion(Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="GetLastDirective">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax GetLastDirective (this Microsoft.CodeAnalysis.SyntaxNode node, Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,bool&gt; predicate = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax GetLastDirective(class Microsoft.CodeAnalysis.SyntaxNode node, class System.Func`2&lt;class Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax, bool&gt; predicate) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetLastDirective (node As SyntaxNode, Optional predicate As Func(Of DirectiveTriviaSyntax, Boolean) = null) As DirectiveTriviaSyntax" />
        <MemberSignature Language="F#" Value="static member GetLastDirective : Microsoft.CodeAnalysis.SyntaxNode * Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax, bool&gt; -&gt; Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetLastDirective (node, predicate)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="predicate" Type="System.Func&lt;Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean&gt;" />
        </Parameters>
        <Docs>
          <param name="node">The source node</param>
          <param name="predicate">The optional DirectiveTriviaSyntax filter predicate.</param>
          <summary>
 Gets the last DirectiveTriviaSyntax item for a specified SyntaxNode.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax,System.Boolean})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetMemberGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetMemberGroup : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetMemberGroup (semanticModel, attribute, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="attribute">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding ImmutableArray of Symbols for a specified AttributeSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetMemberGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetMemberGroup : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetMemberGroup (semanticModel, expression, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding ImmutableArray of Symbols for a specified ExpressionSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.INamespaceSymbol" />
      </Targets>
      <Member MemberName="GetModuleMembers">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamedTypeSymbol&gt; GetModuleMembers (this Microsoft.CodeAnalysis.INamespaceSymbol namespace);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.INamedTypeSymbol&gt; GetModuleMembers(class Microsoft.CodeAnalysis.INamespaceSymbol namespace) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetModuleMembers(Microsoft.CodeAnalysis.INamespaceSymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetModuleMembers (namespace As INamespaceSymbol) As ImmutableArray(Of INamedTypeSymbol)" />
        <MemberSignature Language="F#" Value="static member GetModuleMembers : Microsoft.CodeAnalysis.INamespaceSymbol -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamedTypeSymbol&gt;" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetModuleMembers namespace" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::INamedTypeSymbol ^&gt; GetModuleMembers(Microsoft::CodeAnalysis::INamespaceSymbol ^ namespace);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamedTypeSymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="namespace" Type="Microsoft.CodeAnalysis.INamespaceSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="namespace">To be added.</param>
          <summary>
 Gets all module members in a namespace.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetModuleMembers(Microsoft.CodeAnalysis.INamespaceSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.INamespaceSymbol" />
      </Targets>
      <Member MemberName="GetModuleMembers">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamedTypeSymbol&gt; GetModuleMembers (this Microsoft.CodeAnalysis.INamespaceSymbol namespace, string name);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.INamedTypeSymbol&gt; GetModuleMembers(class Microsoft.CodeAnalysis.INamespaceSymbol namespace, string name) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetModuleMembers(Microsoft.CodeAnalysis.INamespaceSymbol,System.String)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetModuleMembers (namespace As INamespaceSymbol, name As String) As ImmutableArray(Of INamedTypeSymbol)" />
        <MemberSignature Language="F#" Value="static member GetModuleMembers : Microsoft.CodeAnalysis.INamespaceSymbol * string -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamedTypeSymbol&gt;" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetModuleMembers (namespace, name)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::INamedTypeSymbol ^&gt; GetModuleMembers(Microsoft::CodeAnalysis::INamespaceSymbol ^ namespace, System::String ^ name);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamedTypeSymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="namespace" Type="Microsoft.CodeAnalysis.INamespaceSymbol" RefType="this" />
          <Parameter Name="name" Type="System.String" />
        </Parameters>
        <Docs>
          <param name="namespace">To be added.</param>
          <param name="name">The name of the namespace.</param>
          <summary>
 Gets all module members in a specified namespace.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetModuleMembers(Microsoft.CodeAnalysis.INamespaceSymbol,System.String)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.IArgumentOperation" />
      </Targets>
      <Member MemberName="GetOutConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion GetOutConversion (this Microsoft.CodeAnalysis.Operations.IArgumentOperation argument);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion GetOutConversion(class Microsoft.CodeAnalysis.Operations.IArgumentOperation argument) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetOutConversion(Microsoft.CodeAnalysis.Operations.IArgumentOperation)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetOutConversion (argument As IArgumentOperation) As Conversion" />
        <MemberSignature Language="F#" Value="static member GetOutConversion : Microsoft.CodeAnalysis.Operations.IArgumentOperation -&gt; Microsoft.CodeAnalysis.VisualBasic.Conversion" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetOutConversion argument" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::Conversion GetOutConversion(Microsoft::CodeAnalysis::Operations::IArgumentOperation ^ argument);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="argument" Type="Microsoft.CodeAnalysis.Operations.IArgumentOperation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="argument">The argument to get original info from.</param>
          <summary>
 Gets the underlying <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Conversion" /> information for OutConversion of <see cref="T:Microsoft.CodeAnalysis.Operations.IArgumentOperation" /> that was created from Visual Basic code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetOutConversion(Microsoft.CodeAnalysis.Operations.IArgumentOperation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" />
      </Targets>
      <Member MemberName="GetOutConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion GetOutConversion (this Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation compoundAssignment);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion GetOutConversion(class Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation compoundAssignment) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetOutConversion(Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetOutConversion (compoundAssignment As ICompoundAssignmentOperation) As Conversion" />
        <MemberSignature Language="F#" Value="static member GetOutConversion : Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation -&gt; Microsoft.CodeAnalysis.VisualBasic.Conversion" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetOutConversion compoundAssignment" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::Conversion GetOutConversion(Microsoft::CodeAnalysis::Operations::ICompoundAssignmentOperation ^ compoundAssignment);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compoundAssignment" Type="Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="compoundAssignment">To be added.</param>
          <summary>
 Gets the underlying <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Conversion" /> information from this <see cref="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation" />. This
 conversion is applied after the operator is applied, before the result is assigned to <see cref="P:Microsoft.CodeAnalysis.Operations.IAssignmentOperation.Target" />.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetOutConversion(Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetPreprocessingSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.PreprocessingSymbolInfo GetPreprocessingSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax node);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.PreprocessingSymbolInfo GetPreprocessingSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)" />
        <MemberSignature Language="F#" Value="static member GetPreprocessingSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax -&gt; Microsoft.CodeAnalysis.PreprocessingSymbolInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetPreprocessingSymbolInfo (semanticModel, node)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::PreprocessingSymbolInfo GetPreprocessingSymbolInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, Microsoft::CodeAnalysis::VisualBasic::Syntax::IdentifierNameSyntax ^ node);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.PreprocessingSymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="node">To be added.</param>
          <summary>
 If the given node is within a preprocessing directive, gets the preprocessing symbol info for it.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="GetSpecialType">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamedTypeSymbol GetSpecialType (this Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.SpecialType typeId);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamedTypeSymbol GetSpecialType(class Microsoft.CodeAnalysis.Compilation compilation, valuetype Microsoft.CodeAnalysis.SpecialType typeId) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpecialType(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.SpecialType)" />
        <MemberSignature Language="F#" Value="static member GetSpecialType : Microsoft.CodeAnalysis.Compilation * Microsoft.CodeAnalysis.SpecialType -&gt; Microsoft.CodeAnalysis.INamedTypeSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpecialType (compilation, typeId)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::INamedTypeSymbol ^ GetSpecialType(Microsoft::CodeAnalysis::Compilation ^ compilation, Microsoft::CodeAnalysis::SpecialType typeId);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamedTypeSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
          <Parameter Name="typeId" Type="Microsoft.CodeAnalysis.SpecialType" />
        </Parameters>
        <Docs>
          <param name="compilation">A source Compilation object.</param>
          <param name="typeId">The SpecialType to get.</param>
          <summary>
 Gets the special type symbol in current compilation.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpecialType(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.SpecialType)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeAliasInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax nameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax nameSyntax, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeAliasInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.IAliasSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeAliasInfo (semanticModel, position, nameSyntax, bindingOption)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::IAliasSymbol ^ GetSpeculativeAliasInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::VisualBasic::Syntax::IdentifierNameSyntax ^ nameSyntax, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.IAliasSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="nameSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="nameSyntax">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
 Binds the name in the context of the specified location and sees if it resolves to an
 alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeConversion">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Conversion GetSpeculativeConversion (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Conversion GetSpeculativeConversion(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeConversion : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.VisualBasic.Conversion" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeConversion (semanticModel, position, expression, bindingOption)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::Conversion GetSpeculativeConversion(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::VisualBasic::Syntax::ExpressionSyntax ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Conversion</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeMemberGroup">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt; GetSpeculativeMemberGroup (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.ISymbol&gt; GetSpeculativeMemberGroup(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeMemberGroup(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeMemberGroup : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeMemberGroup (semanticModel, position, expression)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::ISymbol ^&gt; GetSpeculativeMemberGroup(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::VisualBasic::Syntax::ExpressionSyntax ^ expression);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.ISymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <summary>
 Gets the corresponding ImmutableArray of Symbols for a speculating an ExpressionSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeMemberGroup(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeSymbolInfo (semanticModel, position, attribute)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SymbolInfo GetSpeculativeSymbolInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::VisualBasic::Syntax::AttributeSyntax ^ attribute);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="attribute">To be added.</param>
          <summary>
 Gets the corresponding SymbolInfo containing semantic info for specified  AttributeSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeSymbolInfo (semanticModel, position, expression, bindingOption)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SymbolInfo GetSpeculativeSymbolInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::VisualBasic::Syntax::ExpressionSyntax ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
 Gets the corresponding SymbolInfo containing semantic info for a specified AttributeSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSpeculativeTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberSignature Language="F#" Value="static member GetSpeculativeTypeInfo : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeTypeInfo (semanticModel, position, expression, bindingOption)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::TypeInfo GetSpeculativeTypeInfo(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::VisualBasic::Syntax::ExpressionSyntax ^ expression, Microsoft::CodeAnalysis::SpeculativeBindingOption bindingOption);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
 Gets the corresponding TypeInfo  containing semantic info for a speculating an ExpressionSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo (semanticModel, attribute, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="attribute">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding SymbolInfo containing semantic info for a specified AttributeSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax crefReference, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax crefReference, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo (semanticModel, crefReference, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="crefReference" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="crefReference">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding SymbolInfo containing semantic info for a specified CrefReferenceSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax variableSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax variableSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo (semanticModel, variableSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="variableSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="variableSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Returns Select method associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax" /> within a <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax" />, 
 or <see cref="F:Microsoft.CodeAnalysis.SymbolInfo.None" /> otherwise if none is.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo (semanticModel, expression, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding SymbolInfo containing semantic info for a specified ExpressionSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax functionSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax functionSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo (semanticModel, functionSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="functionSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="functionSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Returns aggregate function associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax" />.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax orderingSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax orderingSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo (semanticModel, orderingSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="orderingSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="orderingSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Returns OrderBy/OrderByDescending/ThenBy/ThenByDescending method associated with <see cref="T:Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax" />.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetSymbolInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax clauseSyntax, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax clauseSyntax, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetSymbolInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.SymbolInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo (semanticModel, clauseSyntax, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SymbolInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="clauseSyntax" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="clauseSyntax">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Returns symbol information for a query clause.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="GetTypeCharacter">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter GetTypeCharacter (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter GetTypeCharacter(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeCharacter(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetTypeCharacter (token As SyntaxToken) As TypeCharacter" />
        <MemberSignature Language="F#" Value="static member GetTypeCharacter : Microsoft.CodeAnalysis.SyntaxToken -&gt; Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeCharacter token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::Syntax::TypeCharacter GetTypeCharacter(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">The source SyntaxToken.</param>
          <summary>
 Returns the Type character for a given syntax token.  This returns type character for Identifiers or Integer, Floating Point or Decimal Literals.
 Examples: Dim a$   or Dim l1 = 1L
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeCharacter(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetTypeInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeInfo (semanticModel, attribute, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="attribute">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>
 Gets the corresponding TypeInfo containing semantic info for a specified AttributeSyntax.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="GetTypeInfo">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo (this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = null);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(class Microsoft.CodeAnalysis.SemanticModel semanticModel, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax expression, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
        <MemberSignature Language="F#" Value="static member GetTypeInfo : Microsoft.CodeAnalysis.SemanticModel * Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax * System.Threading.CancellationToken -&gt; Microsoft.CodeAnalysis.TypeInfo" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeInfo (semanticModel, expression, cancellationToken)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.TypeInfo</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="expression" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax" />
          <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="expression">To be added.</param>
          <param name="cancellationToken">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax,System.Threading.CancellationToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IMethodSymbol" />
      </Targets>
      <Member MemberName="HandledEvents">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.VisualBasic.HandledEvent&gt; HandledEvents (this Microsoft.CodeAnalysis.IMethodSymbol methodSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.VisualBasic.HandledEvent&gt; HandledEvents(class Microsoft.CodeAnalysis.IMethodSymbol methodSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.HandledEvents(Microsoft.CodeAnalysis.IMethodSymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function HandledEvents (methodSymbol As IMethodSymbol) As ImmutableArray(Of HandledEvent)" />
        <MemberSignature Language="F#" Value="static member HandledEvents : Microsoft.CodeAnalysis.IMethodSymbol -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.VisualBasic.HandledEvent&gt;" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.HandledEvents methodSymbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::VisualBasic::HandledEvent ^&gt; HandledEvents(Microsoft::CodeAnalysis::IMethodSymbol ^ methodSymbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.VisualBasic.HandledEvent&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="methodSymbol" Type="Microsoft.CodeAnalysis.IMethodSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="methodSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.HandledEvents(Microsoft.CodeAnalysis.IMethodSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IEventSymbol" />
      </Targets>
      <Member MemberName="HasAssociatedField">
        <MemberSignature Language="C#" Value="public static bool HasAssociatedField (this Microsoft.CodeAnalysis.IEventSymbol eventSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool HasAssociatedField(class Microsoft.CodeAnalysis.IEventSymbol eventSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.HasAssociatedField(Microsoft.CodeAnalysis.IEventSymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function HasAssociatedField (eventSymbol As IEventSymbol) As Boolean" />
        <MemberSignature Language="F#" Value="static member HasAssociatedField : Microsoft.CodeAnalysis.IEventSymbol -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.HasAssociatedField eventSymbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool HasAssociatedField(Microsoft::CodeAnalysis::IEventSymbol ^ eventSymbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="eventSymbol" Type="Microsoft.CodeAnalysis.IEventSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="eventSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.HasAssociatedField(Microsoft.CodeAnalysis.IEventSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTokenList" />
      </Targets>
      <Member MemberName="Insert">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxTokenList Insert (this Microsoft.CodeAnalysis.SyntaxTokenList list, int index, params Microsoft.CodeAnalysis.SyntaxToken[] items);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxTokenList Insert(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, int32 index, valuetype Microsoft.CodeAnalysis.SyntaxToken[] items) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Insert (list As SyntaxTokenList, index As Integer, ParamArray items As SyntaxToken()) As SyntaxTokenList" />
        <MemberSignature Language="F#" Value="static member Insert : Microsoft.CodeAnalysis.SyntaxTokenList * int * Microsoft.CodeAnalysis.SyntaxToken[] -&gt; Microsoft.CodeAnalysis.SyntaxTokenList" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Insert (list, index, items)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxTokenList Insert(Microsoft::CodeAnalysis::SyntaxTokenList list, int index, ... cli::array &lt;Microsoft::CodeAnalysis::SyntaxToken&gt; ^ items);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxTokenList</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
          <Parameter Name="index" Type="System.Int32" />
          <Parameter Name="items" Type="Microsoft.CodeAnalysis.SyntaxToken[]">
            <Attributes>
              <Attribute>
                <AttributeName>System.ParamArray</AttributeName>
              </Attribute>
            </Attributes>
          </Parameter>
        </Parameters>
        <Docs>
          <param name="list">To be added.</param>
          <param name="index">To be added.</param>
          <param name="items">To be added.</param>
          <summary>
 Insert one or more tokens in the list at the specified index.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsBracketed">
        <MemberSignature Language="C#" Value="public static bool IsBracketed (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsBracketed(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsBracketed(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsBracketed (token As SyntaxToken) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsBracketed : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsBracketed token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsBracketed(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">The source SyntaxToken.</param>
          <summary>
 Checks to see if SyntaxToken is a bracketed identifier.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsBracketed(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ILocalSymbol" />
      </Targets>
      <Member MemberName="IsCatch">
        <MemberSignature Language="C#" Value="public static bool IsCatch (this Microsoft.CodeAnalysis.ILocalSymbol localSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsCatch(class Microsoft.CodeAnalysis.ILocalSymbol localSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsCatch(Microsoft.CodeAnalysis.ILocalSymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsCatch (localSymbol As ILocalSymbol) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsCatch : Microsoft.CodeAnalysis.ILocalSymbol -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsCatch localSymbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsCatch(Microsoft::CodeAnalysis::ILocalSymbol ^ localSymbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="localSymbol" Type="Microsoft.CodeAnalysis.ILocalSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="localSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsCatch(Microsoft.CodeAnalysis.ILocalSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsContextualKeyword">
        <MemberSignature Language="C#" Value="public static bool IsContextualKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsContextualKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsContextualKeyword (token As SyntaxToken) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsContextualKeyword : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsContextualKeyword token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsContextualKeyword(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>
 Determines if the token represents a contextual keyword
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IPropertySymbol" />
      </Targets>
      <Member MemberName="IsDefault">
        <MemberSignature Language="C#" Value="public static bool IsDefault (this Microsoft.CodeAnalysis.IPropertySymbol propertySymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsDefault(class Microsoft.CodeAnalysis.IPropertySymbol propertySymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsDefault(Microsoft.CodeAnalysis.IPropertySymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsDefault (propertySymbol As IPropertySymbol) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsDefault : Microsoft.CodeAnalysis.IPropertySymbol -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsDefault propertySymbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsDefault(Microsoft::CodeAnalysis::IPropertySymbol ^ propertySymbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="propertySymbol" Type="Microsoft.CodeAnalysis.IPropertySymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="propertySymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsDefault(Microsoft.CodeAnalysis.IPropertySymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ILocalSymbol" />
      </Targets>
      <Member MemberName="IsFor">
        <MemberSignature Language="C#" Value="public static bool IsFor (this Microsoft.CodeAnalysis.ILocalSymbol localSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsFor(class Microsoft.CodeAnalysis.ILocalSymbol localSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsFor(Microsoft.CodeAnalysis.ILocalSymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsFor (localSymbol As ILocalSymbol) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsFor : Microsoft.CodeAnalysis.ILocalSymbol -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsFor localSymbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsFor(Microsoft::CodeAnalysis::ILocalSymbol ^ localSymbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="localSymbol" Type="Microsoft.CodeAnalysis.ILocalSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="localSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsFor(Microsoft.CodeAnalysis.ILocalSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ILocalSymbol" />
      </Targets>
      <Member MemberName="IsForEach">
        <MemberSignature Language="C#" Value="public static bool IsForEach (this Microsoft.CodeAnalysis.ILocalSymbol localSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsForEach(class Microsoft.CodeAnalysis.ILocalSymbol localSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsForEach(Microsoft.CodeAnalysis.ILocalSymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsForEach (localSymbol As ILocalSymbol) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsForEach : Microsoft.CodeAnalysis.ILocalSymbol -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsForEach localSymbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsForEach(Microsoft::CodeAnalysis::ILocalSymbol ^ localSymbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="localSymbol" Type="Microsoft.CodeAnalysis.ILocalSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="localSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsForEach(Microsoft.CodeAnalysis.ILocalSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IEventSymbol" />
      </Targets>
      <Member MemberName="IsImplicitlyDeclared">
        <MemberSignature Language="C#" Value="public static bool IsImplicitlyDeclared (this Microsoft.CodeAnalysis.IEventSymbol eventSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsImplicitlyDeclared(class Microsoft.CodeAnalysis.IEventSymbol eventSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsImplicitlyDeclared(Microsoft.CodeAnalysis.IEventSymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsImplicitlyDeclared (eventSymbol As IEventSymbol) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsImplicitlyDeclared : Microsoft.CodeAnalysis.IEventSymbol -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsImplicitlyDeclared eventSymbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsImplicitlyDeclared(Microsoft::CodeAnalysis::IEventSymbol ^ eventSymbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="eventSymbol" Type="Microsoft.CodeAnalysis.IEventSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="eventSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsImplicitlyDeclared(Microsoft.CodeAnalysis.IEventSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsKeyword">
        <MemberSignature Language="C#" Value="public static bool IsKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsKeyword (token As SyntaxToken) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsKeyword : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsKeyword token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsKeyword(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">The source SyntaxToken.</param>
          <summary>
 Determines if the token represents a reserved or contextual keyword
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IParameterSymbol" />
      </Targets>
      <Member MemberName="IsMe">
        <MemberSignature Language="C#" Value="public static bool IsMe (this Microsoft.CodeAnalysis.IParameterSymbol parameterSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsMe(class Microsoft.CodeAnalysis.IParameterSymbol parameterSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsMe(Microsoft.CodeAnalysis.IParameterSymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMe (parameterSymbol As IParameterSymbol) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsMe : Microsoft.CodeAnalysis.IParameterSymbol -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsMe parameterSymbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsMe(Microsoft::CodeAnalysis::IParameterSymbol ^ parameterSymbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="parameterSymbol" Type="Microsoft.CodeAnalysis.IParameterSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="parameterSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsMe(Microsoft.CodeAnalysis.IParameterSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ISymbol" />
      </Targets>
      <Member MemberName="IsMustOverride">
        <MemberSignature Language="C#" Value="public static bool IsMustOverride (this Microsoft.CodeAnalysis.ISymbol symbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsMustOverride(class Microsoft.CodeAnalysis.ISymbol symbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsMustOverride(Microsoft.CodeAnalysis.ISymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsMustOverride (symbol As ISymbol) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsMustOverride : Microsoft.CodeAnalysis.ISymbol -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsMustOverride symbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsMustOverride(Microsoft::CodeAnalysis::ISymbol ^ symbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="symbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsMustOverride(Microsoft.CodeAnalysis.ISymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ISymbol" />
      </Targets>
      <Member MemberName="IsNotOverridable">
        <MemberSignature Language="C#" Value="public static bool IsNotOverridable (this Microsoft.CodeAnalysis.ISymbol symbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsNotOverridable(class Microsoft.CodeAnalysis.ISymbol symbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsNotOverridable(Microsoft.CodeAnalysis.ISymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsNotOverridable (symbol As ISymbol) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsNotOverridable : Microsoft.CodeAnalysis.ISymbol -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsNotOverridable symbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsNotOverridable(Microsoft::CodeAnalysis::ISymbol ^ symbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="symbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsNotOverridable(Microsoft.CodeAnalysis.ISymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IMethodSymbol" />
      </Targets>
      <Member MemberName="IsOverloads">
        <MemberSignature Language="C#" Value="public static bool IsOverloads (this Microsoft.CodeAnalysis.IMethodSymbol methodSymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsOverloads(class Microsoft.CodeAnalysis.IMethodSymbol methodSymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverloads(Microsoft.CodeAnalysis.IMethodSymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsOverloads (methodSymbol As IMethodSymbol) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsOverloads : Microsoft.CodeAnalysis.IMethodSymbol -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverloads methodSymbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsOverloads(Microsoft::CodeAnalysis::IMethodSymbol ^ methodSymbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="methodSymbol" Type="Microsoft.CodeAnalysis.IMethodSymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="methodSymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverloads(Microsoft.CodeAnalysis.IMethodSymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.IPropertySymbol" />
      </Targets>
      <Member MemberName="IsOverloads">
        <MemberSignature Language="C#" Value="public static bool IsOverloads (this Microsoft.CodeAnalysis.IPropertySymbol propertySymbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsOverloads(class Microsoft.CodeAnalysis.IPropertySymbol propertySymbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverloads(Microsoft.CodeAnalysis.IPropertySymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsOverloads (propertySymbol As IPropertySymbol) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsOverloads : Microsoft.CodeAnalysis.IPropertySymbol -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverloads propertySymbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsOverloads(Microsoft::CodeAnalysis::IPropertySymbol ^ propertySymbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="propertySymbol" Type="Microsoft.CodeAnalysis.IPropertySymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="propertySymbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverloads(Microsoft.CodeAnalysis.IPropertySymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ISymbol" />
      </Targets>
      <Member MemberName="IsOverridable">
        <MemberSignature Language="C#" Value="public static bool IsOverridable (this Microsoft.CodeAnalysis.ISymbol symbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsOverridable(class Microsoft.CodeAnalysis.ISymbol symbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverridable(Microsoft.CodeAnalysis.ISymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsOverridable (symbol As ISymbol) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsOverridable : Microsoft.CodeAnalysis.ISymbol -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverridable symbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsOverridable(Microsoft::CodeAnalysis::ISymbol ^ symbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="symbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverridable(Microsoft.CodeAnalysis.ISymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ISymbol" />
      </Targets>
      <Member MemberName="IsOverrides">
        <MemberSignature Language="C#" Value="public static bool IsOverrides (this Microsoft.CodeAnalysis.ISymbol symbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsOverrides(class Microsoft.CodeAnalysis.ISymbol symbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverrides(Microsoft.CodeAnalysis.ISymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsOverrides (symbol As ISymbol) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsOverrides : Microsoft.CodeAnalysis.ISymbol -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverrides symbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsOverrides(Microsoft::CodeAnalysis::ISymbol ^ symbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="symbol">To be added.</param>
          <summary>To be added.</summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsOverrides(Microsoft.CodeAnalysis.ISymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsPreprocessorKeyword">
        <MemberSignature Language="C#" Value="public static bool IsPreprocessorKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsPreprocessorKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsPreprocessorKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsPreprocessorKeyword (token As SyntaxToken) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsPreprocessorKeyword : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsPreprocessorKeyword token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsPreprocessorKeyword(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">The source SyntaxToken.</param>
          <summary>
 Determines if the token  represents a preprocessor keyword
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsPreprocessorKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsReservedKeyword">
        <MemberSignature Language="C#" Value="public static bool IsReservedKeyword (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsReservedKeyword(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsReservedKeyword (token As SyntaxToken) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsReservedKeyword : Microsoft.CodeAnalysis.SyntaxToken -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsReservedKeyword token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsReservedKeyword(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">The source SyntaxToken.</param>
          <summary>
 Determines if the token represents a reserved keyword
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.ISymbol" />
      </Targets>
      <Member MemberName="IsShared">
        <MemberSignature Language="C#" Value="public static bool IsShared (this Microsoft.CodeAnalysis.ISymbol symbol);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsShared(class Microsoft.CodeAnalysis.ISymbol symbol) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsShared(Microsoft.CodeAnalysis.ISymbol)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsShared (symbol As ISymbol) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsShared : Microsoft.CodeAnalysis.ISymbol -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsShared symbol" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsShared(Microsoft::CodeAnalysis::ISymbol ^ symbol);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="symbol" Type="Microsoft.CodeAnalysis.ISymbol" RefType="this" />
        </Parameters>
        <Docs>
          <param name="symbol">The source symbol.</param>
          <summary>
 Determines if symbol is Shared.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.IsShared(Microsoft.CodeAnalysis.ISymbol)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxNode node);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind(class Microsoft.CodeAnalysis.SyntaxNode node) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Kind (node As SyntaxNode) As SyntaxKind" />
        <MemberSignature Language="F#" Value="static member Kind : Microsoft.CodeAnalysis.SyntaxNode -&gt; Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind node" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::SyntaxKind Kind(Microsoft::CodeAnalysis::SyntaxNode ^ node);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
        </Parameters>
        <Docs>
          <param name="node">To be added.</param>
          <summary>
 Returns <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> for <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" /> from <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind" /> property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Kind (nodeOrToken As SyntaxNodeOrToken) As SyntaxKind" />
        <MemberSignature Language="F#" Value="static member Kind : Microsoft.CodeAnalysis.SyntaxNodeOrToken -&gt; Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind nodeOrToken" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::SyntaxKind Kind(Microsoft::CodeAnalysis::SyntaxNodeOrToken nodeOrToken);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="nodeOrToken">To be added.</param>
          <summary>
 Returns <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> for <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> from <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind" /> property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxToken token);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxToken token) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Kind (token As SyntaxToken) As SyntaxKind" />
        <MemberSignature Language="F#" Value="static member Kind : Microsoft.CodeAnalysis.SyntaxToken -&gt; Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind token" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::SyntaxKind Kind(Microsoft::CodeAnalysis::SyntaxToken token);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <summary>
 Returns <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> for <see cref="T:Microsoft.CodeAnalysis.SyntaxToken" /> from <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind" /> property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTrivia" />
      </Targets>
      <Member MemberName="Kind">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind (this Microsoft.CodeAnalysis.SyntaxTrivia trivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind Kind(valuetype Microsoft.CodeAnalysis.SyntaxTrivia trivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Kind (trivia As SyntaxTrivia) As SyntaxKind" />
        <MemberSignature Language="F#" Value="static member Kind : Microsoft.CodeAnalysis.SyntaxTrivia -&gt; Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind trivia" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::SyntaxKind Kind(Microsoft::CodeAnalysis::SyntaxTrivia trivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.SyntaxKind</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" RefType="this" />
        </Parameters>
        <Docs>
          <param name="trivia">To be added.</param>
          <summary>
 Returns <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> for <see cref="T:Microsoft.CodeAnalysis.SyntaxTrivia" /> nodes.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="MemberImports">
        <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamespaceOrTypeSymbol&gt; MemberImports (this Microsoft.CodeAnalysis.Compilation compilation);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Collections.Immutable.ImmutableArray`1&lt;class Microsoft.CodeAnalysis.INamespaceOrTypeSymbol&gt; MemberImports(class Microsoft.CodeAnalysis.Compilation compilation) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.MemberImports(Microsoft.CodeAnalysis.Compilation)" />
        <MemberSignature Language="F#" Value="static member MemberImports : Microsoft.CodeAnalysis.Compilation -&gt; System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamespaceOrTypeSymbol&gt;" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.MemberImports compilation" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Immutable::ImmutableArray&lt;Microsoft::CodeAnalysis::INamespaceOrTypeSymbol ^&gt; MemberImports(Microsoft::CodeAnalysis::Compilation ^ compilation);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.INamespaceOrTypeSymbol&gt;</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="compilation">A source Compilation object.</param>
          <summary>
  Gets the compilation MemberImports property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.MemberImports(Microsoft.CodeAnalysis.Compilation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="OptionCompareText">
        <MemberSignature Language="C#" Value="public static bool OptionCompareText (this Microsoft.CodeAnalysis.SemanticModel semanticModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool OptionCompareText(class Microsoft.CodeAnalysis.SemanticModel semanticModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionCompareText(Microsoft.CodeAnalysis.SemanticModel)" />
        <MemberSignature Language="F#" Value="static member OptionCompareText : Microsoft.CodeAnalysis.SemanticModel -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionCompareText semanticModel" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool OptionCompareText(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source Semantic model object.</param>
          <summary>
 Gets the Semantic Model OptionCompareText property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionCompareText(Microsoft.CodeAnalysis.SemanticModel)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="OptionExplicit">
        <MemberSignature Language="C#" Value="public static bool OptionExplicit (this Microsoft.CodeAnalysis.SemanticModel semanticModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool OptionExplicit(class Microsoft.CodeAnalysis.SemanticModel semanticModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionExplicit(Microsoft.CodeAnalysis.SemanticModel)" />
        <MemberSignature Language="F#" Value="static member OptionExplicit : Microsoft.CodeAnalysis.SemanticModel -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionExplicit semanticModel" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool OptionExplicit(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source Semantic model object.</param>
          <summary>
 Gets the Semantic Model OptionExplicit property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionExplicit(Microsoft.CodeAnalysis.SemanticModel)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="OptionInfer">
        <MemberSignature Language="C#" Value="public static bool OptionInfer (this Microsoft.CodeAnalysis.SemanticModel semanticModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool OptionInfer(class Microsoft.CodeAnalysis.SemanticModel semanticModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionInfer(Microsoft.CodeAnalysis.SemanticModel)" />
        <MemberSignature Language="F#" Value="static member OptionInfer : Microsoft.CodeAnalysis.SemanticModel -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionInfer semanticModel" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool OptionInfer(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source Semantic model object.</param>
          <summary>
 Gets the Semantic Model OptionInfer property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionInfer(Microsoft.CodeAnalysis.SemanticModel)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="OptionStrict">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.VisualBasic.OptionStrict OptionStrict (this Microsoft.CodeAnalysis.SemanticModel semanticModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.VisualBasic.OptionStrict OptionStrict(class Microsoft.CodeAnalysis.SemanticModel semanticModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionStrict(Microsoft.CodeAnalysis.SemanticModel)" />
        <MemberSignature Language="F#" Value="static member OptionStrict : Microsoft.CodeAnalysis.SemanticModel -&gt; Microsoft.CodeAnalysis.VisualBasic.OptionStrict" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionStrict semanticModel" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::VisualBasic::OptionStrict OptionStrict(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.VisualBasic.OptionStrict</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
        </Parameters>
        <Docs>
          <param name="semanticModel">A source Semantic model object.</param>
          <summary>
 Gets the Semantic Model OptionStrict property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.OptionStrict(Microsoft.CodeAnalysis.SemanticModel)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="ReplaceTrivia">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia (this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, Microsoft.CodeAnalysis.SyntaxTrivia newTrivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(valuetype Microsoft.CodeAnalysis.SyntaxToken token, valuetype Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia newTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceTrivia (token As SyntaxToken, oldTrivia As SyntaxTrivia, newTrivia As SyntaxTrivia) As SyntaxToken" />
        <MemberSignature Language="F#" Value="static member ReplaceTrivia : Microsoft.CodeAnalysis.SyntaxToken * Microsoft.CodeAnalysis.SyntaxTrivia * Microsoft.CodeAnalysis.SyntaxTrivia -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ReplaceTrivia (token, oldTrivia, newTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxToken ReplaceTrivia(Microsoft::CodeAnalysis::SyntaxToken token, Microsoft::CodeAnalysis::SyntaxTrivia oldTrivia, Microsoft::CodeAnalysis::SyntaxTrivia newTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="oldTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
          <Parameter Name="newTrivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" />
        </Parameters>
        <Docs>
          <param name="token">The source SyntaxToken to change trivia on.</param>
          <param name="oldTrivia">The original Trivia.</param>
          <param name="newTrivia">The updated Trivia.</param>
          <summary>
  Replaces trivia on a specified SyntaxToken.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="ReplaceTrivia">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia (this Microsoft.CodeAnalysis.SyntaxToken token, System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia);" />
        <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(valuetype Microsoft.CodeAnalysis.SyntaxToken token, class System.Collections.Generic.IEnumerable`1&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; trivia, class System.Func`3&lt;valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia, valuetype Microsoft.CodeAnalysis.SyntaxTrivia&gt; computeReplacementTrivia) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReplaceTrivia (token As SyntaxToken, trivia As IEnumerable(Of SyntaxTrivia), computeReplacementTrivia As Func(Of SyntaxTrivia, SyntaxTrivia, SyntaxTrivia)) As SyntaxToken" />
        <MemberSignature Language="F#" Value="static member ReplaceTrivia : Microsoft.CodeAnalysis.SyntaxToken * seq&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt; * Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia&gt; -&gt; Microsoft.CodeAnalysis.SyntaxToken" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ReplaceTrivia (token, trivia, computeReplacementTrivia)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::SyntaxToken ReplaceTrivia(Microsoft::CodeAnalysis::SyntaxToken token, System::Collections::Generic::IEnumerable&lt;Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ trivia, Func&lt;Microsoft::CodeAnalysis::SyntaxTrivia, Microsoft::CodeAnalysis::SyntaxTrivia, Microsoft::CodeAnalysis::SyntaxTrivia&gt; ^ computeReplacementTrivia);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.SyntaxToken</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="trivia" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
          <Parameter Name="computeReplacementTrivia" Type="System.Func&lt;Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia&gt;" />
        </Parameters>
        <Docs>
          <param name="token">To be added.</param>
          <param name="trivia">To be added.</param>
          <param name="computeReplacementTrivia">To be added.</param>
          <summary>
  Replaces trivia on a specified SyntaxToken.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.Compilation" />
      </Targets>
      <Member MemberName="RootNamespace">
        <MemberSignature Language="C#" Value="public static Microsoft.CodeAnalysis.INamespaceSymbol RootNamespace (this Microsoft.CodeAnalysis.Compilation compilation);" />
        <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.CodeAnalysis.INamespaceSymbol RootNamespace(class Microsoft.CodeAnalysis.Compilation compilation) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.RootNamespace(Microsoft.CodeAnalysis.Compilation)" />
        <MemberSignature Language="F#" Value="static member RootNamespace : Microsoft.CodeAnalysis.Compilation -&gt; Microsoft.CodeAnalysis.INamespaceSymbol" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.RootNamespace compilation" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Microsoft::CodeAnalysis::INamespaceSymbol ^ RootNamespace(Microsoft::CodeAnalysis::Compilation ^ compilation);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>Microsoft.CodeAnalysis.INamespaceSymbol</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="compilation" Type="Microsoft.CodeAnalysis.Compilation" RefType="this" />
        </Parameters>
        <Docs>
          <param name="compilation">A source Compilation object.</param>
          <summary>
 Gets the compilation RootNamespace property.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.RootNamespace(Microsoft.CodeAnalysis.Compilation)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax attribute, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, attribute, speculativeModel)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::VisualBasic::Syntax::AttributeSyntax ^ attribute, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="attribute" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="attribute">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
 Gets the SemanticModel for a AttributeSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax initializer, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax initializer, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, initializer, speculativeModel)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::VisualBasic::Syntax::EqualsValueSyntax ^ initializer, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="initializer" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="initializer">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
 Gets the SemanticModel for a EqualsValueSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax statement, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax statement, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, statement, speculativeModel)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::VisualBasic::Syntax::ExecutableStatementSyntax ^ statement, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="statement" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="statement">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
 Gets the SemanticModel for a ExecutableStatementSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax rangeArgument, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax rangeArgument, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, rangeArgument, speculativeModel)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModel(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::VisualBasic::Syntax::RangeArgumentSyntax ^ rangeArgument, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="rangeArgument" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="rangeArgument">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
 Gets the SemanticModel for a RangeArgumentSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModel">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModel (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type, out Microsoft.CodeAnalysis.SemanticModel speculativeModel, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption = Microsoft.CodeAnalysis.SpeculativeBindingOption.BindAsExpression);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool TryGetSpeculativeSemanticModel(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax type, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel, valuetype Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModel : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax *  * Microsoft.CodeAnalysis.SpeculativeBindingOption -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel (semanticModel, position, type, speculativeModel, bindingOption)" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="type" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
          <Parameter Name="bindingOption" Type="Microsoft.CodeAnalysis.SpeculativeBindingOption" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="type">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <param name="bindingOption">To be added.</param>
          <summary>
 Gets the SemanticModel for a TypeSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SemanticModel" />
      </Targets>
      <Member MemberName="TryGetSpeculativeSemanticModelForMethodBody">
        <MemberSignature Language="C#" Value="public static bool TryGetSpeculativeSemanticModelForMethodBody (this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax method, out Microsoft.CodeAnalysis.SemanticModel speculativeModel);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool TryGetSpeculativeSemanticModelForMethodBody(class Microsoft.CodeAnalysis.SemanticModel semanticModel, int32 position, class Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax method, [out] class Microsoft.CodeAnalysis.SemanticModel&amp; speculativeModel) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
        <MemberSignature Language="F#" Value="static member TryGetSpeculativeSemanticModelForMethodBody : Microsoft.CodeAnalysis.SemanticModel * int * Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax *  -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModelForMethodBody (semanticModel, position, method, speculativeModel)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryGetSpeculativeSemanticModelForMethodBody(Microsoft::CodeAnalysis::SemanticModel ^ semanticModel, int position, Microsoft::CodeAnalysis::VisualBasic::Syntax::MethodBlockBaseSyntax ^ method, [Runtime::InteropServices::Out] Microsoft::CodeAnalysis::SemanticModel ^ % speculativeModel);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="semanticModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="this" />
          <Parameter Name="position" Type="System.Int32" />
          <Parameter Name="method" Type="Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax" />
          <Parameter Name="speculativeModel" Type="Microsoft.CodeAnalysis.SemanticModel" RefType="out" />
        </Parameters>
        <Docs>
          <param name="semanticModel">To be added.</param>
          <param name="position">To be added.</param>
          <param name="method">To be added.</param>
          <param name="speculativeModel">To be added.</param>
          <summary>
 Gets the SemanticModel for a MethodBlockBaseSyntax at a given position, used in Semantic Info for items not appearing in source code.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax,Microsoft.CodeAnalysis.SemanticModel@)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTokenList" />
      </Targets>
      <Member MemberName="Any">
        <MemberSignature Language="C#" Value="public static bool Any (this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool Any(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any (list As SyntaxTokenList, kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member Any : Microsoft.CodeAnalysis.SyntaxTokenList * Microsoft.CodeAnalysis.VisualBasic.SyntaxKind -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasicExtensions.Any (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(Microsoft::CodeAnalysis::SyntaxTokenList list, Microsoft::CodeAnalysis::VisualBasic::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list">To be added.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to test for.</param>
          <summary>
 Tests whether a list contains token of a particular kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />
      </Targets>
      <Member MemberName="Any">
        <MemberSignature Language="C#" Value="public static bool Any (this Microsoft.CodeAnalysis.SyntaxTriviaList list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool Any(valuetype Microsoft.CodeAnalysis.SyntaxTriviaList list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any (list As SyntaxTriviaList, kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member Any : Microsoft.CodeAnalysis.SyntaxTriviaList * Microsoft.CodeAnalysis.VisualBasic.SyntaxKind -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasicExtensions.Any (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(Microsoft::CodeAnalysis::SyntaxTriviaList list, Microsoft::CodeAnalysis::VisualBasic::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list">To be added.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to test for.</param>
          <summary>
 Tests whether a list contains trivia of a particular kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />
      </Targets>
      <Member MemberName="Any&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static bool Any&lt;TNode&gt; (this Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static bool Any&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SeparatedSyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TNode As SyntaxNode) (list As SeparatedSyntaxList(Of TNode), kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member Any : Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; * Microsoft.CodeAnalysis.VisualBasic.SyntaxKind -&gt; bool (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.VisualBasicExtensions.Any (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(Microsoft::CodeAnalysis::SeparatedSyntaxList&lt;TNode&gt; list, Microsoft::CodeAnalysis::VisualBasic::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">To be added.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to test for.</param>
          <summary>
 Tests whether a list contains node of a particular kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxList`1" />
      </Targets>
      <Member MemberName="Any&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static bool Any&lt;TNode&gt; (this Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static bool Any&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TNode As SyntaxNode) (list As SyntaxList(Of TNode), kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member Any : Microsoft.CodeAnalysis.SyntaxList&lt;'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; * Microsoft.CodeAnalysis.VisualBasic.SyntaxKind -&gt; bool (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.VisualBasicExtensions.Any (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(Microsoft::CodeAnalysis::SyntaxList&lt;TNode&gt; list, Microsoft::CodeAnalysis::VisualBasic::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">To be added.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to test for.</param>
          <summary>
 Tests whether a list contains node of a particular kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.Any``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTokenList" />
      </Targets>
      <Member MemberName="IndexOf">
        <MemberSignature Language="C#" Value="public static int IndexOf (this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static int32 IndexOf(valuetype Microsoft.CodeAnalysis.SyntaxTokenList list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf (list As SyntaxTokenList, kind As SyntaxKind) As Integer" />
        <MemberSignature Language="F#" Value="static member IndexOf : Microsoft.CodeAnalysis.SyntaxTokenList * Microsoft.CodeAnalysis.VisualBasic.SyntaxKind -&gt; int" Usage="Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Microsoft::CodeAnalysis::SyntaxTokenList list, Microsoft::CodeAnalysis::VisualBasic::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTokenList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list">Token list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to find.</param>
          <summary>
 Returns the index of the first token of a specified kind in the token list.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />
      </Targets>
      <Member MemberName="IndexOf">
        <MemberSignature Language="C#" Value="public static int IndexOf (this Microsoft.CodeAnalysis.SyntaxTriviaList list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static int32 IndexOf(valuetype Microsoft.CodeAnalysis.SyntaxTriviaList list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf (list As SyntaxTriviaList, kind As SyntaxKind) As Integer" />
        <MemberSignature Language="F#" Value="static member IndexOf : Microsoft.CodeAnalysis.SyntaxTriviaList * Microsoft.CodeAnalysis.VisualBasic.SyntaxKind -&gt; int" Usage="Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Microsoft::CodeAnalysis::SyntaxTriviaList list, Microsoft::CodeAnalysis::VisualBasic::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxTriviaList" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="list">Trivia list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to find.</param>
          <summary>
 Returns the index of the first trivia of a specified kind in the trivia list.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />
      </Targets>
      <Member MemberName="IndexOf&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static int IndexOf&lt;TNode&gt; (this Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static int32 IndexOf&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SeparatedSyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of TNode As SyntaxNode) (list As SeparatedSyntaxList(Of TNode), kind As SyntaxKind) As Integer" />
        <MemberSignature Language="F#" Value="static member IndexOf : Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; * Microsoft.CodeAnalysis.VisualBasic.SyntaxKind -&gt; int (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Microsoft::CodeAnalysis::SeparatedSyntaxList&lt;TNode&gt; list, Microsoft::CodeAnalysis::VisualBasic::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">Node list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to find.</param>
          <summary>
 Returns the index of the first node of a specified kind in the node list.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxList`1" />
      </Targets>
      <Member MemberName="IndexOf&lt;TNode&gt;">
        <MemberSignature Language="C#" Value="public static int IndexOf&lt;TNode&gt; (this Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt; list, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode;" />
        <MemberSignature Language="ILAsm" Value=".method public static int32 IndexOf&lt;(class Microsoft.CodeAnalysis.SyntaxNode) TNode&gt;(valuetype Microsoft.CodeAnalysis.SyntaxList`1&lt;!!TNode&gt; list, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of TNode As SyntaxNode) (list As SyntaxList(Of TNode), kind As SyntaxKind) As Integer" />
        <MemberSignature Language="F#" Value="static member IndexOf : Microsoft.CodeAnalysis.SyntaxList&lt;'Node (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)&gt; * Microsoft.CodeAnalysis.VisualBasic.SyntaxKind -&gt; int (requires 'Node :&gt; Microsoft.CodeAnalysis.SyntaxNode)" Usage="Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf (list, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNode&gt;&#xA; where TNode : Microsoft::CodeAnalysis::SyntaxNode[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Microsoft::CodeAnalysis::SyntaxList&lt;TNode&gt; list, Microsoft::CodeAnalysis::VisualBasic::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Int32</ReturnType>
        </ReturnValue>
        <TypeParameters>
          <TypeParameter Name="TNode">
            <Constraints>
              <BaseTypeName>Microsoft.CodeAnalysis.SyntaxNode</BaseTypeName>
            </Constraints>
          </TypeParameter>
        </TypeParameters>
        <Parameters>
          <Parameter Name="list" Type="Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <typeparam name="TNode">To be added.</typeparam>
          <param name="list">Node list.</param>
          <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" /> to find.</param>
          <summary>
 Returns the index of the first node of a specified kind in the node list.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IndexOf``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNode" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsKind(class Microsoft.CodeAnalysis.SyntaxNode node, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsKind (node As SyntaxNode, kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsKind : Microsoft.CodeAnalysis.SyntaxNode * Microsoft.CodeAnalysis.VisualBasic.SyntaxKind -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind (node, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsKind(Microsoft::CodeAnalysis::SyntaxNode ^ node, Microsoft::CodeAnalysis::VisualBasic::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="node" Type="Microsoft.CodeAnalysis.SyntaxNode" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="node">The Source SyntaxNode.</param>
          <param name="kind">The SyntaxKind to test for.</param>
          <summary>
 Determines if SyntaxNode is a specified kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsKind(valuetype Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsKind (nodeOrToken As SyntaxNodeOrToken, kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsKind : Microsoft.CodeAnalysis.SyntaxNodeOrToken * Microsoft.CodeAnalysis.VisualBasic.SyntaxKind -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind (nodeOrToken, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsKind(Microsoft::CodeAnalysis::SyntaxNodeOrToken nodeOrToken, Microsoft::CodeAnalysis::VisualBasic::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="nodeOrToken" Type="Microsoft.CodeAnalysis.SyntaxNodeOrToken" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="nodeOrToken">The source SyntaxNodeOrToken.</param>
          <param name="kind">The SyntaxKind to test for.</param>
          <summary>
 Determines if a SyntaxNodeOrToken is a specified kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxToken" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsKind(valuetype Microsoft.CodeAnalysis.SyntaxToken token, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsKind (token As SyntaxToken, kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsKind : Microsoft.CodeAnalysis.SyntaxToken * Microsoft.CodeAnalysis.VisualBasic.SyntaxKind -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind (token, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsKind(Microsoft::CodeAnalysis::SyntaxToken token, Microsoft::CodeAnalysis::VisualBasic::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="token" Type="Microsoft.CodeAnalysis.SyntaxToken" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="token">The Source SyntaxToken.</param>
          <param name="kind">The SyntaxKind to test for.</param>
          <summary>
 Determines if SyntaxToken is a specified kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
    <ExtensionMethod>
      <Targets>
        <Target Type="T:Microsoft.CodeAnalysis.SyntaxTrivia" />
      </Targets>
      <Member MemberName="IsKind">
        <MemberSignature Language="C#" Value="public static bool IsKind (this Microsoft.CodeAnalysis.SyntaxTrivia trivia, Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind);" />
        <MemberSignature Language="ILAsm" Value=".method public static bool IsKind(valuetype Microsoft.CodeAnalysis.SyntaxTrivia trivia, valuetype Microsoft.CodeAnalysis.VisualBasic.SyntaxKind kind) cil managed" />
        <MemberSignature Language="DocId" Value="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
        <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsKind (trivia As SyntaxTrivia, kind As SyntaxKind) As Boolean" />
        <MemberSignature Language="F#" Value="static member IsKind : Microsoft.CodeAnalysis.SyntaxTrivia * Microsoft.CodeAnalysis.VisualBasic.SyntaxKind -&gt; bool" Usage="Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind (trivia, kind)" />
        <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsKind(Microsoft::CodeAnalysis::SyntaxTrivia trivia, Microsoft::CodeAnalysis::VisualBasic::SyntaxKind kind);" />
        <MemberType>ExtensionMethod</MemberType>
        <ReturnValue>
          <ReturnType>System.Boolean</ReturnType>
        </ReturnValue>
        <Parameters>
          <Parameter Name="trivia" Type="Microsoft.CodeAnalysis.SyntaxTrivia" RefType="this" />
          <Parameter Name="kind" Type="Microsoft.CodeAnalysis.VisualBasic.SyntaxKind" />
        </Parameters>
        <Docs>
          <param name="trivia">The Source SyntaxTrivia.</param>
          <param name="kind">The SyntaxKind to test for.</param>
          <summary>
 Determines if SyntaxTrivia is a specified kind.
 </summary>
        </Docs>
        <Link Type="Microsoft.CodeAnalysis.VisualBasicExtensions" Member="M:Microsoft.CodeAnalysis.VisualBasicExtensions.IsKind(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.VisualBasic.SyntaxKind)" />
      </Member>
    </ExtensionMethod>
  </ExtensionMethods>
</Overview>
